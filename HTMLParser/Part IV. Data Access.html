<div class="part" title="Part&nbsp;IV.&nbsp;Data Access">
 <div class="titlepage">
  <div>
   <div>
    <h1 class="title"><a name="spring-data-tier"></a>Part&nbsp;IV.&nbsp;Data Access</h1>
   </div>
  </div>
 </div> 
 <div class="partintro" title="Data Access">
  <div></div> 
  <p>This part of the reference documentation is concerned with data access and the interaction between the data access layer and the business or service layer.</p> 
  <p>Springs comprehensive transaction management support is covered in some detail, followed by thorough coverage of the various data access frameworks and technologies that the Spring Framework integrates with.</p> 
  <div class="itemizedlist">
   <ul class="itemizedlist" type="disc">
    <li class="listitem"> <a class="xref" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#transaction" title="11.&nbsp;Transaction Management">Chapter&nbsp;11, <i>Transaction Management</i></a> </li>
    <li class="listitem"> <a class="xref" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#dao" title="12.&nbsp;DAO support">Chapter&nbsp;12, <i>DAO support</i></a> </li>
    <li class="listitem"> <a class="xref" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#jdbc" title="13.&nbsp;Data access with JDBC">Chapter&nbsp;13, <i>Data access with JDBC</i></a> </li>
    <li class="listitem"> <a class="xref" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#orm" title="14.&nbsp;Object Relational Mapping (ORM) Data Access">Chapter&nbsp;14, <i>Object Relational Mapping (ORM) Data Access</i></a> </li>
    <li class="listitem"> <a class="xref" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#oxm" title="15.&nbsp;Marshalling XML using O/X Mappers">Chapter&nbsp;15, <i>Marshalling XML using O/X Mappers</i></a> </li>
   </ul>
  </div> 
 </div> 
 <div class="chapter" title="11.&nbsp;Transaction Management">
  <div class="titlepage">
   <div>
    <div>
     <h2 class="title"><a name="transaction"></a>11.&nbsp;Transaction Management</h2>
    </div>
   </div>
  </div> 
  <div class="section" title="11.1&nbsp;Introduction to Spring Framework transaction management">
   <div class="titlepage">
    <div>
     <div>
      <h2 class="title" style="clear: both"><a name="transaction-intro"></a>11.1&nbsp;Introduction to Spring Framework transaction management</h2>
     </div>
    </div>
   </div> 
   <p>Comprehensive transaction support is among the most compelling reasons to use the Spring Framework. The Spring Framework provides a consistent abstraction for transaction management that delivers the following benefits:</p> 
   <div class="itemizedlist">
    <ul class="itemizedlist" type="disc">
     <li class="listitem"> Consistent programming model across different transaction APIs such as Java Transaction API (JTA), JDBC, Hibernate, Java Persistence API (JPA), and Java Data Objects (JDO). </li>
     <li class="listitem"> Support for <a class="link" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#transaction-declarative" title="11.5&nbsp;Declarative transaction management">declarative transaction management</a>. </li>
     <li class="listitem"> Simpler API for <a class="link" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#transaction-programmatic" title="11.6&nbsp;Programmatic transaction management">programmatic</a> transaction management than complex transaction APIs such as JTA. </li>
     <li class="listitem"> Excellent integration with Springs data access abstractions. </li>
    </ul>
   </div> 
   <p>The following sections describe the Spring Frameworks transaction value-adds and technologies. (The chapter also includes discussions of best practices, application server integration, and solutions to common problems.)</p> 
   <div class="itemizedlist">
    <ul class="itemizedlist" type="disc">
     <li class="listitem"> <a class="link" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#transaction-motivation" title="11.2&nbsp;Advantages of the Spring Frameworks transaction support model">Advantages of the Spring Frameworks transaction support model</a> describes <span class="emphasis"><em>why</em></span> you would use the Spring Frameworks transaction abstraction instead of EJB Container-Managed Transactions (CMT) or choosing to drive local transactions through a proprietary API such as Hibernate. </li>
     <li class="listitem"> <a class="link" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#transaction-strategies" title="11.3&nbsp;Understanding the Spring Framework transaction abstraction">Understanding the Spring Framework transaction abstraction</a> outlines the core classes and describes how to configure and obtain <code class="literal">DataSource</code> instances from a variety of sources. </li>
     <li class="listitem"> <a class="link" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#tx-resource-synchronization" title="11.4&nbsp;Synchronizing resources with transactions">Synchronizing resources with transactions</a>describes how the application code ensures that resources are created, reused, and cleaned up properly. </li>
     <li class="listitem"> <a class="link" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#transaction-declarative" title="11.5&nbsp;Declarative transaction management">Declarative transaction management</a> describes support for declarative transaction management. </li>
     <li class="listitem"> <a class="link" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#transaction-programmatic" title="11.6&nbsp;Programmatic transaction management">Programmatic transaction management</a> covers support for programmatic (that is, explicitly coded) transaction management. </li>
    </ul>
   </div> 
  </div> 
  <div class="section" title="11.2&nbsp;Advantages of the Spring Frameworks transaction support model">
   <div class="titlepage">
    <div>
     <div>
      <h2 class="title" style="clear: both"><a name="transaction-motivation"></a>11.2&nbsp;Advantages of the Spring Frameworks transaction support model</h2>
     </div>
    </div>
   </div> 
   <p>Traditionally, Java EE developers have had two choices for transaction management: <span class="emphasis"><em>global</em></span> or <span class="emphasis"><em>local</em></span> transactions, both of which have profound limitations. Global and local transaction management is reviewed in the next two sections, followed by a discussion of how the Spring Frameworks transaction management support addresses the limitations of the global and local transaction models.</p> 
   <div class="section" title="11.2.1&nbsp;Global transactions">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="transaction-global"></a>11.2.1&nbsp;Global transactions</h3>
      </div>
     </div>
    </div> 
    <p>Global transactions enable you to work with multiple transactional resources, typically relational databases and message queues. The application server manages global transactions through the JTA, which is a cumbersome API to use (partly due to its exception model). Furthermore, a JTA <code class="literal">UserTransaction</code> normally needs to be sourced from JNDI, meaning that you <span class="emphasis"><em>also</em></span> need to use JNDI in order to use JTA. Obviously the use of global transactions would limit any potential reuse of application code, as JTA is normally only available in an application server environment.</p> 
    <p>Previously, the preferred way to use global transactions was via EJB <span class="emphasis"><em>CMT</em></span> (<span class="emphasis"><em>Container Managed Transaction</em></span>): CMT is a form of <span class="emphasis"><em>declarative transaction management</em></span> (as distinguished from <span class="emphasis"><em>programmatic transaction management</em></span>). EJB CMT removes the need for transaction-related JNDI lookups, although of course the use of EJB itself necessitates the use of JNDI. It removes most but not all of the need to write Java code to control transactions. The significant downside is that CMT is tied to JTA and an application server environment. Also, it is only available if one chooses to implement business logic in EJBs, or at least behind a transactional EJB facade. The negatives of EJB in general are so great that this is not an attractive proposition, especially in the face of compelling alternatives for declarative transaction management.</p> 
   </div> 
   <div class="section" title="11.2.2&nbsp;Local transactions">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="transaction-local"></a>11.2.2&nbsp;Local transactions</h3>
      </div>
     </div>
    </div> 
    <p>Local transactions are resource-specific, such as a transaction associated with a JDBC connection. Local transactions may be easier to use, but have significant disadvantages: they cannot work across multiple transactional resources. For example, code that manages transactions using a JDBC connection cannot run within a global JTA transaction. Because the application server is not involved in transaction management, it cannot help ensure correctness across multiple resources. (It is worth noting that most applications use a single transaction resource.) Another downside is that local transactions are invasive to the programming model.</p> 
   </div> 
   <div class="section" title="11.2.3&nbsp;Spring Frameworks consistent programming model">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="transaction-programming-model"></a>11.2.3&nbsp;Spring Frameworks consistent programming model</h3>
      </div>
     </div>
    </div> 
    <p>Spring resolves the disadvantages of global and local transactions. It enables application developers to use a <span class="emphasis"><em>consistent</em></span> programming model <span class="emphasis"><em>in any environment</em></span>. You write your code once, and it can benefit from different transaction management strategies in different environments. The Spring Framework provides both declarative and programmatic transaction management. Most users prefer declarative transaction management, which is recommended in most cases.</p> 
    <p>With programmatic transaction management, developers work with the Spring Framework transaction abstraction, which can run over any underlying transaction infrastructure. With the preferred declarative model, developers typically write little or no code related to transaction management, and hence do not depend on the Spring Framework transaction API, or any other transaction API.</p> 
    <div class="sidebar" title="Do you need an application server for transaction management?">
     <p class="title"><b>Do you need an application server for transaction management?</b></p> 
     <p>The Spring Frameworks transaction management support changes traditional rules as to when an enterprise Java application requires an application server.</p> 
     <p>In particular, you do not need an application server simply for declarative transactions through EJBs. In fact, even if your application server has powerful JTA capabilities, you may decide that the Spring Frameworks declarative transactions offer more power and a more productive programming model than EJB CMT.</p> 
     <p>Typically you need an application servers JTA capability only if your application needs to handle transactions across multiple resources, which is not a requirement for many applications. Many high-end applications use a single, highly scalable database (such as Oracle RAC) instead. Standalone transaction managers such as <a class="ulink" href="http://www.atomikos.com/" target="_top">Atomikos Transactions</a> and <a class="ulink" href="http://jotm.objectweb.org/" target="_top">JOTM</a> are other options. Of course, you may need other application server capabilities such as Java Message Service (JMS) and J2EE Connector Architecture (JCA).</p> 
     <p>The Spring Framework <span class="emphasis"><em>gives you the choice of when to scale your application to a fully loaded application server</em></span>. Gone are the days when the only alternative to using EJB CMT or JTA was to write code with local transactions such as those on JDBC connections, and face a hefty rework if you need that code to run within global, container-managed transactions. With the Spring Framework, only some of the bean definitions in your configuration file, rather than your code, need to change.</p> 
    </div> 
   </div> 
  </div> 
  <div class="section" title="11.3&nbsp;Understanding the Spring Framework transaction abstraction">
   <div class="titlepage">
    <div>
     <div>
      <h2 class="title" style="clear: both"><a name="transaction-strategies"></a>11.3&nbsp;Understanding the Spring Framework transaction abstraction</h2>
     </div>
    </div>
   </div> 
   <p>The key to the Spring transaction abstraction is the notion of a <span class="emphasis"><em>transaction strategy</em></span>. A transaction strategy is defined by the <code class="literal">org.springframework.transaction.PlatformTransactionManager</code> interface:</p> 
   <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> PlatformTransactionManager {

    TransactionStatus getTransaction(
            TransactionDefinition definition) <span class="hl-keyword">throws</span> TransactionException;

    <span class="hl-keyword">void</span> commit(TransactionStatus status) <span class="hl-keyword">throws</span> TransactionException;

    <span class="hl-keyword">void</span> rollback(TransactionStatus status) <span class="hl-keyword">throws</span> TransactionException;
}</pre> 
   <p>This is primarily a service provider interface (SPI), although it can be used <a class="link" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#transaction-programmatic-ptm" title="11.6.2&nbsp;Using the PlatformTransactionManager">programmatically</a> from your application code. Because <code class="literal">PlatformTransactionManager</code> is an <span class="emphasis"><em>interface</em></span>, it can be easily mocked or stubbed as necessary. It is not tied to a lookup strategy such as JNDI. <code class="literal">PlatformTransactionManager</code> implementations are defined like any other object (or bean) in the Spring Framework IoC container. This benefit alone makes Spring Framework transactions a worthwhile abstraction even when you work with JTA. Transactional code can be tested much more easily than if it used JTA directly.</p> 
   <p>Again in keeping with Springs philosophy, the <code class="literal">TransactionException</code> that can be thrown by any of the <code class="literal">PlatformTransactionManager</code> interfaces methods is <span class="emphasis"><em>unchecked</em></span> (that is, it extends the <code class="literal">java.lang.RuntimeException</code> class). Transaction infrastructure failures are almost invariably fatal. In rare cases where application code can actually recover from a transaction failure, the application developer can still choose to catch and handle <code class="literal">TransactionException</code>. The salient point is that developers are not <span class="emphasis"><em>forced</em></span> to do so.</p> 
   <p>The <code class="literal">getTransaction(..)</code> method returns a <code class="literal">TransactionStatus</code> object, depending on a <code class="literal">TransactionDefinition</code> parameter. The returned <code class="literal">TransactionStatus</code> might represent a new transaction, or can represent an existing transaction if a matching transaction exists in the current call stack. The implication in this latter case is that, as with Java EE transaction contexts, a <code class="literal">TransactionStatus</code> is associated with a <span class="emphasis"><em>thread</em></span> of execution.</p> 
   <p>The <code class="literal">TransactionDefinition</code> interface specifies:</p> 
   <div class="itemizedlist">
    <ul class="itemizedlist" type="disc">
     <li class="listitem"> <span class="emphasis"><em>Isolation</em></span>: The degree to which this transaction is isolated from the work of other transactions. For example, can this transaction see uncommitted writes from other transactions? </li>
     <li class="listitem"> <span class="emphasis"><em>Propagation</em></span>: Typically, all code executed within a transaction scope will run in that transaction. However, you have the option of specifying the behavior in the event that a transactional method is executed when a transaction context already exists. For example, code can continue running in the existing transaction (the common case); or the existing transaction can be suspended and a new transaction created. <span class="emphasis"><em>Spring offers all of the transaction propagation options familiar from EJB CMT</em></span>. To read about the semantics of transaction propagation in Spring, see <a class="xref" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#tx-propagation" title="11.5.7&nbsp;Transaction propagation">Section&nbsp;11.5.7, Transaction propagation</a>. </li>
     <li class="listitem"> <span class="emphasis"><em>Timeout</em></span>: How long this transaction runs before timing out and being rolled back automatically by the underlying transaction infrastructure. </li>
     <li class="listitem"> <span class="emphasis"><em>Read-only status</em></span>: A read-only transaction can be used when your code reads but does not modify data. Read-only transactions can be a useful optimization in some cases, such as when you are using Hibernate. </li>
    </ul>
   </div> 
   <p>These settings reflect standard transactional concepts. If necessary, refer to resources that discuss transaction isolation levels and other core transaction concepts. Understanding these concepts is essential to using the Spring Framework or any transaction management solution.</p> 
   <p>The <code class="literal">TransactionStatus</code> interface provides a simple way for transactional code to control transaction execution and query transaction status. The concepts should be familiar, as they are common to all transaction APIs:</p> 
   <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> TransactionStatus <span class="hl-keyword">extends</span> SavepointManager {

    <span class="hl-keyword">boolean</span> isNewTransaction();

    <span class="hl-keyword">boolean</span> hasSavepoint();

    <span class="hl-keyword">void</span> setRollbackOnly();

    <span class="hl-keyword">boolean</span> isRollbackOnly();

    <span class="hl-keyword">void</span> flush();

    <span class="hl-keyword">boolean</span> isCompleted();

}</pre> 
   <p>Regardless of whether you opt for declarative or programmatic transaction management in Spring, defining the correct <code class="literal">PlatformTransactionManager</code> implementation is absolutely essential. You typically define this implementation through dependency injection.</p> 
   <p><code class="literal">PlatformTransactionManager</code> implementations normally require knowledge of the environment in which they work: JDBC, JTA, Hibernate, and so on. The following examples show how you can define a local <code class="literal">PlatformTransactionManager</code> implementation. (This example works with plain JDBC.)</p> 
   <p>You define a JDBC <code class="literal">DataSource</code></p> 
   <pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;dataSource&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span> <span class="hl-attribute">destroy-method</span>=<span class="hl-value">&quot;close&quot;</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;driverClassName&quot;</span> <span class="hl-attribute">value</span>=<span class="hl-value">&quot;${jdbc.driverClassName}&quot;</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;url&quot;</span> <span class="hl-attribute">value</span>=<span class="hl-value">&quot;${jdbc.url}&quot;</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;username&quot;</span> <span class="hl-attribute">value</span>=<span class="hl-value">&quot;${jdbc.username}&quot;</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;password&quot;</span> <span class="hl-attribute">value</span>=<span class="hl-value">&quot;${jdbc.password}&quot;</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre> 
   <p>The related <code class="literal">PlatformTransactionManager</code> bean definition will then have a reference to the <code class="literal">DataSource</code> definition. It will look like this:</p> 
   <pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;txManager&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;dataSource&quot;</span> <span class="hl-attribute">ref</span>=<span class="hl-value">&quot;dataSource&quot;</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre> 
   <p>If you use JTA in a Java EE container then you use a container <code class="literal">DataSource</code>, obtained through JNDI, in conjunction with Springs <code class="literal">JtaTransactionManager</code>. This is what the JTA and JNDI lookup version would look like:</p> 
   <pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">&quot;http://www.springframework.org/schema/beans&quot;</span>
    <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>
    <span class="hl-attribute">xmlns:jee</span>=<span class="hl-value">&quot;http://www.springframework.org/schema/jee&quot;</span>
    <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">&quot;
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/jee
        http://www.springframework.org/schema/jee/spring-jee.xsd&quot;</span><span class="hl-tag">&gt;</span>

    <span class="hl-tag">&lt;jee:jndi-lookup</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;dataSource&quot;</span> <span class="hl-attribute">jndi-name</span>=<span class="hl-value">&quot;jdbc/jpetstore&quot;</span><span class="hl-tag">/&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;txManager&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;org.springframework.transaction.jta.JtaTransactionManager&quot;</span><span class="hl-tag"> /&gt;</span>

    <span class="hl-comment">&lt;!-- other &lt;bean/&gt; definitions here --&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre> 
   <p>The <code class="literal">JtaTransactionManager</code> does not need to know about the <code class="literal">DataSource</code>, or any other specific resources, because it uses the containers global transaction management infrastructure.</p> 
   <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;">
    <table border="0" summary="Note">
     <tbody>
      <tr>
       <td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Framework Reference Documentation_files/note.png" /></td>
       <th align="left">Note</th>
      </tr>
      <tr>
       <td align="left" valign="top"> <p>The above definition of the <code class="literal">dataSource</code> bean uses the <code class="literal">&lt;jndi-lookup/&gt;</code> tag from the <code class="literal">jee</code> namespace. For more information on schema-based configuration, see <a class="xref" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#xsd-config" title="33.&nbsp;XML Schema-based configuration">Chapter&nbsp;33, <i>XML Schema-based configuration</i></a>, and for more information on the <code class="literal">&lt;jee/&gt;</code> tags see the section entitled <a class="xref" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#xsd-config-body-schemas-jee" title="33.2.3&nbsp;the jee schema">Section&nbsp;33.2.3, the jee schema</a>.</p> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p>You can also use Hibernate local transactions easily, as shown in the following examples. In this case, you need to define a Hibernate <code class="literal">LocalSessionFactoryBean</code>, which your application code will use to obtain Hibernate <code class="literal">Session</code> instances.</p> 
   <p>The <code class="literal">DataSource</code> bean definition will be similar to the local JDBC example shown previously and thus is not shown in the following example.</p> 
   <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;">
    <table border="0" summary="Note">
     <tbody>
      <tr>
       <td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Framework Reference Documentation_files/note.png" /></td>
       <th align="left">Note</th>
      </tr>
      <tr>
       <td align="left" valign="top"> <p>If the <code class="literal">DataSource</code>, used by any non-JTA transaction manager, is looked up via JNDI and managed by a Java EE container, then it should be non-transactional because the Spring Framework, rather than the Java EE container, will manage the transactions.</p> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p>The <code class="literal">txManager</code> bean in this case is of the <code class="literal">HibernateTransactionManager</code> type. In the same way as the <code class="literal">DataSourceTransactionManager</code> needs a reference to the <code class="literal">DataSource</code>, the <code class="literal">HibernateTransactionManager</code> needs a reference to the <code class="literal">SessionFactory</code>.</p> 
   <pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;sessionFactory&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;org.springframework.orm.hibernate3.LocalSessionFactoryBean&quot;</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;dataSource&quot;</span> <span class="hl-attribute">ref</span>=<span class="hl-value">&quot;dataSource&quot;</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;mappingResources&quot;</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;list&gt;</span>
            <span class="hl-tag">&lt;value&gt;</span>org/springframework/samples/petclinic/hibernate/petclinic.hbm.xml<span class="hl-tag">&lt;/value&gt;</span>
        <span class="hl-tag">&lt;/list&gt;</span>
    <span class="hl-tag">&lt;/property&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;hibernateProperties&quot;</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;value&gt;</span>
            hibernate.dialect=${hibernate.dialect}
        <span class="hl-tag">&lt;/value&gt;</span>
    <span class="hl-tag">&lt;/property&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;txManager&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;org.springframework.orm.hibernate3.HibernateTransactionManager&quot;</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;sessionFactory&quot;</span> <span class="hl-attribute">ref</span>=<span class="hl-value">&quot;sessionFactory&quot;</span><span class="hl-tag"> /&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre> 
   <p>If you are using Hibernate and Java EE container-managed JTA transactions, then you should simply use the same <code class="literal">JtaTransactionManager</code> as in the previous JTA example for JDBC.</p> 
   <pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;txManager&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;org.springframework.transaction.jta.JtaTransactionManager&quot;</span><span class="hl-tag">/&gt;</span></pre> 
   <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;">
    <table border="0" summary="Note">
     <tbody>
      <tr>
       <td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Framework Reference Documentation_files/note.png" /></td>
       <th align="left">Note</th>
      </tr>
      <tr>
       <td align="left" valign="top"> <p>If you use JTA , then your transaction manager definition will look the same regardless of what data access technology you use, be it JDBC, Hibernate JPA or any other supported technology. This is due to the fact that JTA transactions are global transactions, which can enlist any transactional resource.</p> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p>In all these cases, application code does not need to change. You can change how transactions are managed merely by changing configuration, even if that change means moving from local to global transactions or vice versa.</p> 
  </div> 
  <div class="section" title="11.4&nbsp;Synchronizing resources with transactions">
   <div class="titlepage">
    <div>
     <div>
      <h2 class="title" style="clear: both"><a name="tx-resource-synchronization"></a>11.4&nbsp;Synchronizing resources with transactions</h2>
     </div>
    </div>
   </div> 
   <p>It should now be clear how you create different transaction managers, and how they are linked to related resources that need to be synchronized to transactions (for example <code class="literal">DataSourceTransactionManager</code> to a JDBC <code class="literal">DataSource</code>, <code class="literal">HibernateTransactionManager</code> to a Hibernate <code class="literal">SessionFactory</code>, and so forth). This section describes how the application code, directly or indirectly using a persistence API such as JDBC, Hibernate, or JDO, ensures that these resources are created, reused, and cleaned up properly. The section also discusses how transaction synchronization is triggered (optionally) through the relevant <code class="literal">PlatformTransactionManager</code>.</p> 
   <div class="section" title="11.4.1&nbsp;High-level synchronization approach">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="tx-resource-synchronization-high"></a>11.4.1&nbsp;High-level synchronization approach</h3>
      </div>
     </div>
    </div> 
    <p>The preferred approach is to use Springs highest level template based persistence integration APIs or to use native ORM APIs with transaction- aware factory beans or proxies for managing the native resource factories. These transaction-aware solutions internally handle resource creation and reuse, cleanup, optional transaction synchronization of the resources, and exception mapping. Thus user data access code does not have to address these tasks, but can be focused purely on non-boilerplate persistence logic. Generally, you use the native ORM API or take a <span class="emphasis"><em>template</em></span> approach for JDBC access by using the <code class="literal">JdbcTemplate</code>. These solutions are detailed in subsequent chapters of this reference documentation.</p> 
   </div> 
   <div class="section" title="11.4.2&nbsp;Low-level synchronization approach">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="tx-resource-synchronization-low"></a>11.4.2&nbsp;Low-level synchronization approach</h3>
      </div>
     </div>
    </div> 
    <p>Classes such as <code class="literal">DataSourceUtils</code> (for JDBC), <code class="literal">EntityManagerFactoryUtils</code> (for JPA), <code class="literal">SessionFactoryUtils</code> (for Hibernate), <code class="literal">PersistenceManagerFactoryUtils</code> (for JDO), and so on exist at a lower level. When you want the application code to deal directly with the resource types of the native persistence APIs, you use these classes to ensure that proper Spring Framework-managed instances are obtained, transactions are (optionally) synchronized, and exceptions that occur in the process are properly mapped to a consistent API.</p> 
    <p>For example, in the case of JDBC, instead of the traditional JDBC approach of calling the <code class="literal">getConnection()</code> method on the <code class="literal">DataSource</code>, you instead use Springs <code class="literal">org.springframework.jdbc.datasource.DataSourceUtils</code> class as follows:</p> 
    <pre class="programlisting">Connection conn = DataSourceUtils.getConnection(dataSource);</pre> 
    <p>If an existing transaction already has a connection synchronized (linked) to it, that instance is returned. Otherwise, the method call triggers the creation of a new connection, which is (optionally) synchronized to any existing transaction, and made available for subsequent reuse in that same transaction. As mentioned, any <code class="literal">SQLException</code> is wrapped in a Spring Framework <code class="literal">CannotGetJdbcConnectionException</code>, one of the Spring Frameworks hierarchy of unchecked DataAccessExceptions. This approach gives you more information than can be obtained easily from the <code class="literal">SQLException</code>, and ensures portability across databases, even across different persistence technologies.</p> 
    <p>This approach also works without Spring transaction management (transaction synchronization is optional), so you can use it whether or not you are using Spring for transaction management.</p> 
    <p>Of course, once you have used Springs JDBC support, JPA support or Hibernate support, you will generally prefer not to use <code class="literal">DataSourceUtils</code> or the other helper classes, because you will be much happier working through the Spring abstraction than directly with the relevant APIs. For example, if you use the Spring <code class="literal">JdbcTemplate</code> or <code class="literal">jdbc.object</code> package to simplify your use of JDBC, correct connection retrieval occurs behind the scenes and you wont need to write any special code.</p> 
   </div> 
   <div class="section" title="11.4.3&nbsp;TransactionAwareDataSourceProxy">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="tx-resource-synchronization-tadsp"></a>11.4.3&nbsp;TransactionAwareDataSourceProxy</h3>
      </div>
     </div>
    </div> 
    <p>At the very lowest level exists the <code class="literal">TransactionAwareDataSourceProxy</code> class. This is a proxy for a target <code class="literal">DataSource</code>, which wraps the target <code class="literal">DataSource</code> to add awareness of Spring-managed transactions. In this respect, it is similar to a transactional JNDI <code class="literal">DataSource</code> as provided by a Java EE server.</p> 
    <p>It should almost never be necessary or desirable to use this class, except when existing code must be called and passed a standard JDBC <code class="literal">DataSource</code> interface implementation. In that case, it is possible that this code is usable, but participating in Spring managed transactions. It is preferable to write your new code by using the higher level abstractions mentioned above.</p> 
   </div> 
  </div> 
  <div class="section" title="11.5&nbsp;Declarative transaction management">
   <div class="titlepage">
    <div>
     <div>
      <h2 class="title" style="clear: both"><a name="transaction-declarative"></a>11.5&nbsp;Declarative transaction management</h2>
     </div>
    </div>
   </div> 
   <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;">
    <table border="0" summary="Note">
     <tbody>
      <tr>
       <td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Framework Reference Documentation_files/note.png" /></td>
       <th align="left">Note</th>
      </tr>
      <tr>
       <td align="left" valign="top"> <p>Most Spring Framework users choose declarative transaction management. This option has the least impact on application code, and hence is most consistent with the ideals of a <span class="emphasis"><em>non-invasive</em></span> lightweight container.</p> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <p>The Spring Frameworks declarative transaction management is made possible with Spring aspect-oriented programming (AOP), although, as the transactional aspects code comes with the Spring Framework distribution and may be used in a boilerplate fashion, AOP concepts do not generally have to be understood to make effective use of this code.</p> 
   <p>The Spring Frameworks declarative transaction management is similar to EJB CMT in that you can specify transaction behavior (or lack of it) down to individual method level. It is possible to make a <code class="literal">setRollbackOnly()</code> call within a transaction context if necessary. The differences between the two types of transaction management are:</p> 
   <div class="itemizedlist">
    <ul class="itemizedlist" type="disc">
     <li class="listitem"> Unlike EJB CMT, which is tied to JTA, the Spring Frameworks declarative transaction management works in any environment. It can work with JTA transactions or local transactions using JDBC, JPA, Hibernate or JDO by simply adjusting the configuration files. </li>
     <li class="listitem"> You can apply the Spring Framework declarative transaction management to any class, not merely special classes such as EJBs. </li>
     <li class="listitem"> The Spring Framework offers declarative <a class="link" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#transaction-declarative-rolling-back" title="11.5.3&nbsp;Rolling back a declarative transaction"><span class="emphasis"><em>rollback rules</em></span>,</a>a feature with no EJB equivalent. Both programmatic and declarative support for rollback rules is provided. </li>
     <li class="listitem"> The Spring Framework enables you to customize transactional behavior, by using AOP. For example, you can insert custom behavior in the case of transaction rollback. You can also add arbitrary advice, along with the transactional advice. With EJB CMT, you cannot influence the containers transaction management except with <code class="literal">setRollbackOnly()</code>. </li>
     <li class="listitem"> The Spring Framework does not support propagation of transaction contexts across remote calls, as do high-end application servers. If you need this feature, we recommend that you use EJB. However, consider carefully before using such a feature, because normally, one does not want transactions to span remote calls. </li>
    </ul>
   </div> 
   <div class="sidebar" title="Where is TransactionProxyFactoryBean?">
    <p class="title"><b>Where is TransactionProxyFactoryBean?</b></p> 
    <p>Declarative transaction configuration in versions of Spring 2.0 and above differs considerably from previous versions of Spring. The main difference is that there is no longer any need to configure <code class="literal">TransactionProxyFactoryBean</code> beans.</p> 
    <p>The pre-Spring 2.0 configuration style is still 100% valid configuration; think of the new <code class="literal">&lt;tx:tags/&gt;</code> as simply defining <code class="literal">TransactionProxyFactoryBean</code> beans on your behalf.</p> 
   </div> 
   <p>The concept of rollback rules is important: they enable you to specify which exceptions (and throwables) should cause automatic rollback. You specify this declaratively, in configuration, not in Java code. So, although you can still call <code class="literal">setRollbackOnly()</code> on the <code class="literal">TransactionStatus</code> object to roll back the current transaction back, most often you can specify a rule that <code class="literal">MyApplicationException</code> must always result in rollback. The significant advantage to this option is that business objects do not depend on the transaction infrastructure. For example, they typically do not need to import Spring transaction APIs or other Spring APIs.</p> 
   <p>Although EJB container default behavior automatically rolls back the transaction on a <span class="emphasis"><em>system exception</em></span> (usually a runtime exception), EJB CMT does not roll back the transaction automatically on an<span class="emphasis"><em>application exception</em></span> (that is, a checked exception other than <code class="literal">java.rmi.RemoteException</code>). While the Spring default behavior for declarative transaction management follows EJB convention (roll back is automatic only on unchecked exceptions), it is often useful to customize this behavior.</p> 
   <div class="section" title="11.5.1&nbsp;Understanding the Spring Frameworks declarative transaction implementation">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="tx-decl-explained"></a>11.5.1&nbsp;Understanding the Spring Frameworks declarative transaction implementation</h3>
      </div>
     </div>
    </div> 
    <p>It is not sufficient to tell you simply to annotate your classes with the <code class="literal">@Transactional</code> annotation, add <code class="literal">@EnableTransactionManagement</code> to your configuration, and then expect you to understand how it all works. This section explains the inner workings of the Spring Frameworks declarative transaction infrastructure in the event of transaction-related issues.</p> 
    <p>The most important concepts to grasp with regard to the Spring Frameworks declarative transaction support are that this support is enabled <a class="link" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#aop-understanding-aop-proxies" title="8.6.1&nbsp;Understanding AOP proxies"><span class="emphasis"><em>via AOP proxies</em></span></a>, and that the transactional advice is driven by <span class="emphasis"><em>metadata</em></span> (currently XML- or annotation-based). The combination of AOP with transactional metadata yields an AOP proxy that uses a <code class="literal">TransactionInterceptor</code> in conjunction with an appropriate <code class="literal">PlatformTransactionManager</code> implementation to drive transactions <span class="emphasis"><em>around method invocations</em></span>.</p> 
    <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;">
     <table border="0" summary="Note">
      <tbody>
       <tr>
        <td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Framework Reference Documentation_files/note.png" /></td>
        <th align="left">Note</th>
       </tr>
       <tr>
        <td align="left" valign="top"> <p>Spring AOP is covered in <a class="xref" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#aop" title="8.&nbsp;Aspect Oriented Programming with Spring">Chapter&nbsp;8, <i>Aspect Oriented Programming with Spring</i></a>.</p> </td>
       </tr>
      </tbody>
     </table>
    </div> 
    <p>Conceptually, calling a method on a transactional proxy looks like this</p> 
    <div class="figure">
     <a name="d4e9788"></a>
     <p class="title"><b>Figure&nbsp;11.1.&nbsp;</b></p>
     <div class="figure-contents"> 
      <div class="mediaobject">
       <img src="./Spring Framework Reference Documentation_files/tx.png" alt="tx" />
      </div> 
     </div>
    </div>
    <br class="figure-break" /> 
   </div> 
   <div class="section" title="11.5.2&nbsp;Example of declarative transaction implementation">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="transaction-declarative-first-example"></a>11.5.2&nbsp;Example of declarative transaction implementation</h3>
      </div>
     </div>
    </div> 
    <p>Consider the following interface, and its attendant implementation. This example uses <code class="literal">Foo</code> and <code class="literal">Bar</code> classes as placeholders so that you can concentrate on the transaction usage without focusing on a particular domain model. For the purposes of this example, the fact that the <code class="literal">DefaultFooService</code> class throws <code class="literal">UnsupportedOperationException</code> instances in the body of each implemented method is good; it allows you to see transactions created and then rolled back in response to the <code class="literal">UnsupportedOperationException</code> instance.</p> 
    <pre class="programlisting"><span class="hl-comment">// the service interface that we want to make transactional</span>

<span class="hl-keyword">package</span> x.y.service;

<span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> FooService {

    Foo getFoo(String fooName);

    Foo getFoo(String fooName, String barName);

    <span class="hl-keyword">void</span> insertFoo(Foo foo);

    <span class="hl-keyword">void</span> updateFoo(Foo foo);

}</pre> 
    <pre class="programlisting"><span class="hl-comment">// an implementation of the above interface</span>

<span class="hl-keyword">package</span> x.y.service;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> DefaultFooService <span class="hl-keyword">implements</span> FooService {

    <span class="hl-keyword">public</span> Foo getFoo(String fooName) {
        <span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> UnsupportedOperationException();
    }

    <span class="hl-keyword">public</span> Foo getFoo(String fooName, String barName) {
        <span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> UnsupportedOperationException();
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> insertFoo(Foo foo) {
        <span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> UnsupportedOperationException();
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> updateFoo(Foo foo) {
        <span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> UnsupportedOperationException();
    }

}</pre> 
    <p>Assume that the first two methods of the <code class="literal">FooService</code> interface, <code class="literal">getFoo(String)</code> and <code class="literal">getFoo(String, String)</code>, must execute in the context of a transaction with read-only semantics, and that the other methods, <code class="literal">insertFoo(Foo)</code> and <code class="literal">updateFoo(Foo)</code>, must execute in the context of a transaction with read-write semantics. The following configuration is explained in detail in the next few paragraphs.</p> 
    <pre class="programlisting"><span class="hl-comment">&lt;!-- from the file </span><span class="emphasis"><em>context.xml</em></span> --&gt;
<span class="hl-directive" style="color: maroon">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">&quot;http://www.springframework.org/schema/beans&quot;</span>
    <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>
    <span class="hl-attribute">xmlns:aop</span>=<span class="hl-value">&quot;http://www.springframework.org/schema/aop&quot;</span>
    <span class="hl-attribute">xmlns:tx</span>=<span class="hl-value">&quot;http://www.springframework.org/schema/tx&quot;</span>
    <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">&quot;
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx
        http://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span><span class="hl-tag">&gt;</span>

    <span class="hl-comment">&lt;!-- this is the service object that we want to make transactional --&gt;</span>
    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;fooService&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;x.y.service.DefaultFooService&quot;</span><span class="hl-tag">/&gt;</span>

    <span class="hl-comment">&lt;!-- the transactional advice (what </span><span class="emphasis"><em>happens</em></span>; see the <span class="hl-tag">&lt;aop:advisor/&gt;</span> bean below) --&gt;
    <span class="hl-tag">&lt;tx:advice</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;txAdvice&quot;</span> <span class="hl-attribute">transaction-manager</span>=<span class="hl-value">&quot;txManager&quot;</span><span class="hl-tag">&gt;</span>
        <span class="hl-comment">&lt;!-- the transactional semantics... --&gt;</span>
        <span class="hl-tag">&lt;tx:attributes&gt;</span>
            <span class="hl-comment">&lt;!-- all methods starting with </span><span class="emphasis"><em>get</em></span> are read-only --&gt;
            <span class="hl-tag">&lt;tx:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;get*&quot;</span> <span class="hl-attribute">read-only</span>=<span class="hl-value">&quot;true&quot;</span><span class="hl-tag">/&gt;</span>
            <span class="hl-comment">&lt;!-- other methods use the default transaction settings (see below) --&gt;</span>
            <span class="hl-tag">&lt;tx:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;</span><span class="strong"><strong>&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- ensure that the above transactional advice runs for any execution of an operation defined by the FooService interface --&gt; &lt;aop:config&gt; &lt;aop:pointcut id=&quot;fooServiceOperation&quot; expression=&quot;execution(</strong></span> x.y.service.FooService.*(..))&quot;/&gt;
        <span class="hl-tag">&lt;aop:advisor</span> <span class="hl-attribute">advice-ref</span>=<span class="hl-value">&quot;txAdvice&quot;</span> <span class="hl-attribute">pointcut-ref</span>=<span class="hl-value">&quot;fooServiceOperation&quot;</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/aop:config&gt;</span>

    <span class="hl-comment">&lt;!-- don't forget the DataSource --&gt;</span>
    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;dataSource&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span> <span class="hl-attribute">destroy-method</span>=<span class="hl-value">&quot;close&quot;</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;driverClassName&quot;</span> <span class="hl-attribute">value</span>=<span class="hl-value">&quot;oracle.jdbc.driver.OracleDriver&quot;</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;url&quot;</span> <span class="hl-attribute">value</span>=<span class="hl-value">&quot;jdbc:oracle:thin:@rj-t42:1521:elvis&quot;</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;username&quot;</span> <span class="hl-attribute">value</span>=<span class="hl-value">&quot;scott&quot;</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;password&quot;</span> <span class="hl-attribute">value</span>=<span class="hl-value">&quot;tiger&quot;</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

    <span class="hl-comment">&lt;!-- similarly, don't forget the PlatformTransactionManager --&gt;</span>
    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;txManager&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;dataSource&quot;</span> <span class="hl-attribute">ref</span>=<span class="hl-value">&quot;dataSource&quot;</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

    <span class="hl-comment">&lt;!-- other &lt;bean/&gt; definitions here --&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre> 
    <p>Examine the preceding configuration. You want to make a service object, the <code class="literal">fooService</code> bean, transactional. The transaction semantics to apply are encapsulated in the <code class="literal">&lt;tx:advice/&gt;</code> definition. The <code class="literal">&lt;tx:advice/&gt;</code> definition reads as &quot;<span class="emphasis"><em> all methods on starting with <code class="literal">'get'</code> are to execute in the context of a read-only transaction, and all other methods are to execute with the default transaction semantics</em></span>&quot;. The <code class="literal">transaction-manager</code> attribute of the <code class="literal">&lt;tx:advice/&gt;</code> tag is set to the name of the <code class="literal">PlatformTransactionManager</code> bean that is going to <span class="emphasis"><em>drive</em></span> the transactions, in this case, the <code class="literal">txManager</code> bean.</p> 
    <div class="tip" title="Tip" style="margin-left: 0.5in; margin-right: 0.5in;">
     <table border="0" summary="Tip">
      <tbody>
       <tr>
        <td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="./Spring Framework Reference Documentation_files/tip.png" /></td>
        <th align="left">Tip</th>
       </tr>
       <tr>
        <td align="left" valign="top"> <p>You can omit the <code class="literal">transaction-manager</code> attribute in the transactional advice ( <code class="literal">&lt;tx:advice/&gt;</code>) if the bean name of the <code class="literal">PlatformTransactionManager</code> that you want to wire in has the name <code class="literal">transactionManager</code>. If the <code class="literal">PlatformTransactionManager</code> bean that you want to wire in has any other name, then you must use the <code class="literal">transaction-manager</code> attribute explicitly, as in the preceding example.</p> </td>
       </tr>
      </tbody>
     </table>
    </div> 
    <p>The <code class="literal">&lt;aop:config/&gt;</code> definition ensures that the transactional advice defined by the <code class="literal">txAdvice</code> bean executes at the appropriate points in the program. First you define a pointcut that matches the execution of any operation defined in the <code class="literal">FooService</code> interface ( <code class="literal">fooServiceOperation</code>). Then you associate the pointcut with the <code class="literal">txAdvice</code> using an advisor. The result indicates that at the execution of a <code class="literal">fooServiceOperation</code>, the advice defined by <code class="literal">txAdvice</code> will be run.</p> 
    <p>The expression defined within the <code class="literal">&lt;aop:pointcut/&gt;</code> element is an AspectJ pointcut expression; see <a class="xref" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#aop" title="8.&nbsp;Aspect Oriented Programming with Spring">Chapter&nbsp;8, <i>Aspect Oriented Programming with Spring</i></a> for more details on pointcut expressions in Spring.</p> 
    <p>A common requirement is to make an entire service layer transactional. The best way to do this is simply to change the pointcut expression to match any operation in your service layer. For example:</p> 
    <pre class="programlisting"><span class="hl-tag">&lt;aop:config&gt;</span>
    <span class="hl-tag">&lt;aop:pointcut</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;fooServiceMethods&quot;</span> <span class="hl-attribute">expression</span>=<span class="hl-value">&quot;execution(* x.y.service.</span><span class="strong"><strong>.</strong></span>(..))&quot;/&gt;
    <span class="hl-tag">&lt;aop:advisor</span> <span class="hl-attribute">advice-ref</span>=<span class="hl-value">&quot;txAdvice&quot;</span> <span class="hl-attribute">pointcut-ref</span>=<span class="hl-value">&quot;fooServiceMethods&quot;</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/aop:config&gt;</span></pre> 
    <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;">
     <table border="0" summary="Note">
      <tbody>
       <tr>
        <td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Framework Reference Documentation_files/note.png" /></td>
        <th align="left">Note</th>
       </tr>
       <tr>
        <td align="left" valign="top"> <p><span class="emphasis"><em>In this example it is assumed that all your service interfaces are defined in the <code class="literal">x.y.service</code> package; see <a class="xref" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#aop" title="8.&nbsp;Aspect Oriented Programming with Spring">Chapter&nbsp;8, <i>Aspect Oriented Programming with Spring</i></a> for more details.</em></span></p> </td>
       </tr>
      </tbody>
     </table>
    </div> 
    <p>Now that weve analyzed the configuration, you may be asking yourself, &quot;<span class="emphasis"><em>Okay but what does all this configuration actually do?</em></span>&quot;.</p> 
    <p>The above configuration will be used to create a transactional proxy around the object that is created from the <code class="literal">fooService</code> bean definition. The proxy will be configured with the transactional advice, so that when an appropriate method is invoked <span class="emphasis"><em>on the proxy</em></span>, a transaction is started, suspended, marked as read-only, and so on, depending on the transaction configuration associated with that method. Consider the following program that test drives the above configuration:</p> 
    <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">final</span> <span class="hl-keyword">class</span> Boot {

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">void</span> main(<span class="hl-keyword">final</span> String[] args) <span class="hl-keyword">throws</span> Exception {
        ApplicationContext ctx = <span class="hl-keyword">new</span> ClassPathXmlApplicationContext(<span class="hl-string">&quot;context.xml&quot;</span>, Boot.<span class="hl-keyword">class</span>);
        FooService fooService = (FooService) ctx.getBean(<span class="hl-string">&quot;fooService&quot;</span>);
        fooService.insertFoo (<span class="hl-keyword">new</span> Foo());
    }
}</pre> 
    <p>The output from running the preceding program will resemble the following. (The Log4J output and the stack trace from the UnsupportedOperationException thrown by the insertFoo(..) method of the DefaultFooService class have been truncated for clarity.)</p> 
    <pre class="programlisting"><span class="hl-comment">&lt;!-- the Spring container is starting up... --&gt;</span>
[AspectJInvocationContextExposingAdvisorAutoProxyCreator] - Creating implicit proxy for bean <span class="emphasis"><em>fooService</em></span> with 0 common interceptors and 1 specific interceptors

<span class="hl-comment">&lt;!-- the DefaultFooService is actually proxied --&gt;</span>
[JdkDynamicAopProxy] - Creating JDK dynamic proxy for [x.y.service.DefaultFooService]

<span class="hl-comment">&lt;!-- ... the insertFoo(..) method is now being invoked on the proxy --&gt;</span>
[TransactionInterceptor] - Getting transaction for x.y.service.FooService.insertFoo

<span class="hl-comment">&lt;!-- the transactional advice kicks in here... --&gt;</span>
[DataSourceTransactionManager] - Creating new transaction with name [x.y.service.FooService.insertFoo]
[DataSourceTransactionManager] - Acquired Connection [org.apache.commons.dbcp.PoolableConnection@a53de4] for JDBC transaction

<span class="hl-comment">&lt;!-- the insertFoo(..) method from DefaultFooService throws an exception... --&gt;</span>
[RuleBasedTransactionAttribute] - Applying rules to determine whether transaction should rollback on java.lang.UnsupportedOperationException
[TransactionInterceptor] - Invoking rollback for transaction on x.y.service.FooService.insertFoo due to throwable [java.lang.UnsupportedOperationException]

<span class="hl-comment">&lt;!-- and the transaction is rolled back (by default, RuntimeException instances cause rollback) --&gt;</span>
[DataSourceTransactionManager] - Rolling back JDBC transaction on Connection [org.apache.commons.dbcp.PoolableConnection@a53de4]
[DataSourceTransactionManager] - Releasing JDBC Connection after transaction
[DataSourceUtils] - Returning JDBC Connection to DataSource

Exception in thread &quot;main&quot; java.lang.UnsupportedOperationException at x.y.service.DefaultFooService.insertFoo(DefaultFooService.java:14)
<span class="hl-comment">&lt;!-- AOP infrastructure stack trace elements removed for clarity --&gt;</span>
at $Proxy0.insertFoo(Unknown Source)
at Boot.main(Boot.java:11)</pre> 
   </div> 
   <div class="section" title="11.5.3&nbsp;Rolling back a declarative transaction">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="transaction-declarative-rolling-back"></a>11.5.3&nbsp;Rolling back a declarative transaction</h3>
      </div>
     </div>
    </div> 
    <p>The previous section outlined the basics of how to specify transactional settings for classes, typically service layer classes, declaratively in your application. This section describes how you can control the rollback of transactions in a simple declarative fashion.</p> 
    <p>The recommended way to indicate to the Spring Frameworks transaction infrastructure that a transactions work is to be rolled back is to throw an <code class="literal">Exception</code> from code that is currently executing in the context of a transaction. The Spring Frameworks transaction infrastructure code will catch any unhandled <code class="literal">Exception</code> as it bubbles up the call stack, and make a determination whether to mark the transaction for rollback.</p> 
    <p>In its default configuration, the Spring Frameworks transaction infrastructure code <span class="emphasis"><em>only</em></span> marks a transaction for rollback in the case of runtime, unchecked exceptions; that is, when the thrown exception is an instance or subclass of <code class="literal">RuntimeException</code>. ( <code class="literal">Error</code> s will also - by default - result in a rollback). Checked exceptions that are thrown from a transactional method do <span class="emphasis"><em>not</em></span> result in rollback in the default configuration.</p> 
    <p>You can configure exactly which <code class="literal">Exception</code> types mark a transaction for rollback, including checked exceptions. The following XML snippet demonstrates how you configure rollback for a checked, application-specific <code class="literal">Exception</code> type.</p> 
    <pre class="programlisting"><span class="hl-tag">&lt;tx:advice</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;txAdvice&quot;</span> <span class="hl-attribute">transaction-manager</span>=<span class="hl-value">&quot;txManager&quot;</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;tx:attributes&gt;</span>
    <span class="hl-tag">&lt;tx:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;get*&quot;</span> <span class="hl-attribute">read-only</span>=<span class="hl-value">&quot;true&quot;</span> <span class="hl-attribute">rollback-for</span>=<span class="hl-value">&quot;NoProductInStockException&quot;</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;tx:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;*&quot;</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/tx:attributes&gt;</span>
<span class="hl-tag">&lt;/tx:advice&gt;</span></pre> 
    <p>You can also specify <span class="emphasis"><em>no rollback rules</em></span>, if you do <span class="emphasis"><em>not</em></span> want a transaction rolled back when an exception is thrown. The following example tells the Spring Frameworks transaction infrastructure to commit the attendant transaction even in the face of an unhandled <code class="literal">InstrumentNotFoundException</code>.</p> 
    <pre class="programlisting"><span class="hl-tag">&lt;tx:advice</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;txAdvice&quot;</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;tx:attributes&gt;</span>
    <span class="hl-tag">&lt;tx:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;updateStock&quot;</span> <span class="hl-attribute">no-rollback-for</span>=<span class="hl-value">&quot;InstrumentNotFoundException&quot;</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;tx:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;*&quot;</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/tx:attributes&gt;</span>
<span class="hl-tag">&lt;/tx:advice&gt;</span></pre> 
    <p>When the Spring Frameworks transaction infrastructure catches an exception and is consults configured rollback rules to determine whether to mark the transaction for rollback, the <span class="emphasis"><em>strongest</em></span> matching rule wins. So in the case of the following configuration, any exception other than an <code class="literal">InstrumentNotFoundException</code> results in a rollback of the attendant transaction.</p> 
    <pre class="programlisting"><span class="hl-tag">&lt;tx:advice</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;txAdvice&quot;</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;tx:attributes&gt;</span>
    <span class="hl-tag">&lt;tx:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;*&quot;</span> <span class="hl-attribute">rollback-for</span>=<span class="hl-value">&quot;Throwable&quot;</span> <span class="hl-attribute">no-rollback-for</span>=<span class="hl-value">&quot;InstrumentNotFoundException&quot;</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/tx:attributes&gt;</span>
<span class="hl-tag">&lt;/tx:advice&gt;</span></pre> 
    <p>You can also indicate a required rollback <span class="emphasis"><em>programmatically</em></span>. Although very simple, this process is quite invasive, and tightly couples your code to the Spring Frameworks transaction infrastructure:</p> 
    <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">void</span> resolvePosition() {
    <span class="hl-keyword">try</span> {
        <span class="hl-comment">// some business logic...</span>
    } <span class="hl-keyword">catch</span> (NoProductInStockException ex) {
        <span class="hl-comment">// trigger rollback programmatically</span>
        TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
    }
}</pre> 
    <p>You are strongly encouraged to use the declarative approach to rollback if at all possible. Programmatic rollback is available should you absolutely need it, but its usage flies in the face of achieving a clean POJO-based architecture.</p> 
   </div> 
   <div class="section" title="11.5.4&nbsp;Configuring different transactional semantics for different beans">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="transaction-declarative-diff-tx"></a>11.5.4&nbsp;Configuring different transactional semantics for different beans</h3>
      </div>
     </div>
    </div> 
    <p>Consider the scenario where you have a number of service layer objects, and you want to apply a <span class="emphasis"><em>totally different</em></span> transactional configuration to each of them. You do this by defining distinct <code class="literal">&lt;aop:advisor/&gt;</code> elements with differing <code class="literal">pointcut</code> and <code class="literal">advice-ref</code> attribute values.</p> 
    <p>As a point of comparison, first assume that all of your service layer classes are defined in a root <code class="literal">x.y.service</code> package. To make all beans that are instances of classes defined in that package (or in subpackages) and that have names ending in <code class="literal">Service</code> have the default transactional configuration, you would write the following:</p> 
    <pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">&quot;http://www.springframework.org/schema/beans&quot;</span>
    <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>
    <span class="hl-attribute">xmlns:aop</span>=<span class="hl-value">&quot;http://www.springframework.org/schema/aop&quot;</span>
    <span class="hl-attribute">xmlns:tx</span>=<span class="hl-value">&quot;http://www.springframework.org/schema/tx&quot;</span>
    <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">&quot;
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx
        http://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span><span class="hl-tag">&gt;</span>

    <span class="hl-tag">&lt;aop:config&gt;</span>

        <span class="hl-tag">&lt;aop:pointcut</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;serviceOperation&quot;</span>
                <span class="hl-attribute">expression</span>=<span class="hl-value">&quot;execution(* x.y.service..</span><span class="strong"><strong>Service.</strong></span>(..))&quot;/&gt;

        <span class="hl-tag">&lt;aop:advisor</span> <span class="hl-attribute">pointcut-ref</span>=<span class="hl-value">&quot;serviceOperation&quot;</span> <span class="hl-attribute">advice-ref</span>=<span class="hl-value">&quot;txAdvice&quot;</span><span class="hl-tag">/&gt;</span>

    <span class="hl-tag">&lt;/aop:config&gt;</span>

    <span class="hl-comment">&lt;!-- these two beans will be transactional... --&gt;</span>
    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;fooService&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;x.y.service.DefaultFooService&quot;</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;barService&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;x.y.service.extras.SimpleBarService&quot;</span><span class="hl-tag">/&gt;</span>

    <span class="hl-comment">&lt;!-- ... and these two beans won't --&gt;</span>
    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;anotherService&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;org.xyz.SomeService&quot;</span><span class="hl-tag">/&gt;</span> <span class="hl-comment">&lt;!-- (not in the right package) --&gt;</span>
    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;barManager&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;x.y.service.SimpleBarManager&quot;</span><span class="hl-tag">/&gt;</span> <span class="hl-comment">&lt;!-- (doesn't end in </span><span class="emphasis"><em>Service</em></span>) --&gt;

    <span class="hl-tag">&lt;tx:advice</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;txAdvice&quot;</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;tx:attributes&gt;</span>
            <span class="hl-tag">&lt;tx:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;get*&quot;</span> <span class="hl-attribute">read-only</span>=<span class="hl-value">&quot;true&quot;</span><span class="hl-tag">/&gt;</span>
            <span class="hl-tag">&lt;tx:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;*&quot;</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;/tx:attributes&gt;</span>
    <span class="hl-tag">&lt;/tx:advice&gt;</span>

    <span class="hl-comment">&lt;!-- other transaction infrastructure beans such as a PlatformTransactionManager omitted... --&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre> 
    <p>The following example shows how to configure two distinct beans with totally different transactional settings.</p> 
    <pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">&quot;http://www.springframework.org/schema/beans&quot;</span>
    <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>
    <span class="hl-attribute">xmlns:aop</span>=<span class="hl-value">&quot;http://www.springframework.org/schema/aop&quot;</span>
    <span class="hl-attribute">xmlns:tx</span>=<span class="hl-value">&quot;http://www.springframework.org/schema/tx&quot;</span>
    <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">&quot;
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx
        http://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span><span class="hl-tag">&gt;</span>

    <span class="hl-tag">&lt;aop:config&gt;</span>

        <span class="hl-tag">&lt;aop:pointcut</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;defaultServiceOperation&quot;</span>
                <span class="hl-attribute">expression</span>=<span class="hl-value">&quot;execution(* x.y.service.</span><span class="strong"><strong>Service.</strong></span>(..))&quot;/&gt;

        <span class="hl-tag">&lt;aop:pointcut</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;noTxServiceOperation&quot;</span>
                <span class="hl-attribute">expression</span>=<span class="hl-value">&quot;execution(* x.y.service.ddl.DefaultDdlManager.</span><span class="strong"><strong>(..))&quot;/&gt; &lt;aop:advisor pointcut-ref=&quot;defaultServiceOperation&quot; advice-ref=&quot;defaultTxAdvice&quot;/&gt; &lt;aop:advisor pointcut-ref=&quot;noTxServiceOperation&quot; advice-ref=&quot;noTxAdvice&quot;/&gt; &lt;/aop:config&gt; &lt;!-- this bean will be transactional (see the <span class="emphasis"><em>defaultServiceOperation</em></span> pointcut) --&gt; &lt;bean id=&quot;fooService&quot; class=&quot;x.y.service.DefaultFooService&quot;/&gt; &lt;!-- this bean will also be transactional, but with totally different transactional settings --&gt; &lt;bean id=&quot;anotherFooService&quot; class=&quot;x.y.service.ddl.DefaultDdlManager&quot;/&gt; &lt;tx:advice id=&quot;defaultTxAdvice&quot;&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;get</strong></span>&quot; read-only=&quot;true&quot;/&gt;
            <span class="hl-tag">&lt;tx:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;</span><span class="strong"><strong>&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;tx:advice id=&quot;noTxAdvice&quot;&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;</strong></span>&quot; propagation=&quot;NEVER&quot;/&gt;
        <span class="hl-tag">&lt;/tx:attributes&gt;</span>
    <span class="hl-tag">&lt;/tx:advice&gt;</span>

    <span class="hl-comment">&lt;!-- other transaction infrastructure beans such as a PlatformTransactionManager omitted... --&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre> 
   </div> 
   <div class="section" title="11.5.5&nbsp;&lt;tx:advice/&gt; settings">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="transaction-declarative-txadvice-settings"></a>11.5.5&nbsp;&lt;tx:advice/&gt; settings</h3>
      </div>
     </div>
    </div> 
    <p>This section summarizes the various transactional settings that can be specified using the <code class="literal">&lt;tx:advice/&gt;</code> tag. The default <code class="literal">&lt;tx:advice/&gt;</code> settings are:</p> 
    <div class="itemizedlist">
     <ul class="itemizedlist" type="disc">
      <li class="listitem"> <a class="link" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#tx-propagation" title="11.5.7&nbsp;Transaction propagation">Propagation setting</a> is <code class="literal">REQUIRED.</code> </li>
      <li class="listitem"> Isolation level is <code class="literal">DEFAULT.</code> </li>
      <li class="listitem"> Transaction is read/write. </li>
      <li class="listitem"> Transaction timeout defaults to the default timeout of the underlying transaction system, or none if timeouts are not supported. </li>
      <li class="listitem"> Any <code class="literal">RuntimeException</code> triggers rollback, and any checked <code class="literal">Exception</code> does not. </li>
     </ul>
    </div> 
    <p>You can change these default settings; the various attributes of the <code class="literal">&lt;tx:method/&gt;</code> tags that are nested within <code class="literal">&lt;tx:advice/&gt;</code> and <code class="literal">&lt;tx:attributes/&gt;</code> tags are summarized below:</p> 
    <div class="table">
     <a name="tx-method-settings"></a>
     <p class="title"><b>Table&nbsp;11.1.&nbsp;&lt;tx:method/&gt; settings</b></p>
     <div class="table-contents"> 
      <table summary="&lt;tx:method/&gt; settings" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; ">
       <colgroup>
        <col />
        <col />
        <col />
        <col />
       </colgroup>
       <thead>
        <tr>
         <th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">Attribute</th>
         <th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">Required?</th>
         <th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">Default</th>
         <th style="border-bottom: 0.5pt solid ; " align="left" valign="top">Description</th>
        </tr>
       </thead>
       <tbody>
        <tr>
         <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">name</code></p></td>
         <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Yes</p></td>
         <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">&nbsp;</td>
         <td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Method name(s) with which the transaction attributes are to be associated. The wildcard (*) character can be used to associate the same transaction attribute settings with a number of methods; for example, <code class="literal">get*</code>, <code class="literal">handle*</code>, <code class="literal">on*Event</code>, and so forth.</p></td>
        </tr>
        <tr>
         <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">propagation</code></p></td>
         <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>No</p></td>
         <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>REQUIRED</p></td>
         <td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Transaction propagation behavior.</p></td>
        </tr>
        <tr>
         <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">isolation</code></p></td>
         <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>No</p></td>
         <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>DEFAULT</p></td>
         <td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Transaction isolation level.</p></td>
        </tr>
        <tr>
         <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">timeout</code></p></td>
         <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>No</p></td>
         <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>-1</p></td>
         <td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Transaction timeout value (in seconds).</p></td>
        </tr>
        <tr>
         <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">read-only</code></p></td>
         <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>No</p></td>
         <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>false</p></td>
         <td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Is this transaction read-only?</p></td>
        </tr>
        <tr>
         <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">rollback-for</code></p></td>
         <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>No</p></td>
         <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">&nbsp;</td>
         <td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">Exception(s)</code> that trigger rollback; comma-delimited. For example, <code class="literal">com.foo.MyBusinessException,ServletException.</code></p></td>
        </tr>
        <tr>
         <td style="border-right: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">no-rollback-for</code></p></td>
         <td style="border-right: 0.5pt solid ; " align="left" valign="top"><p>No</p></td>
         <td style="border-right: 0.5pt solid ; " align="left" valign="top">&nbsp;</td>
         <td style="" align="left" valign="top"><p><code class="literal">Exception(s)</code> that do <span class="emphasis"><em>not</em></span> trigger rollback; comma-delimited. For example, <code class="literal">com.foo.MyBusinessException,ServletException.</code></p></td>
        </tr>
       </tbody>
      </table> 
     </div>
    </div>
    <br class="table-break" /> 
   </div> 
   <div class="section" title="11.5.6&nbsp;Using @Transactional">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="transaction-declarative-annotations"></a>11.5.6&nbsp;Using @Transactional</h3>
      </div>
     </div>
    </div> 
    <p>In addition to the XML-based declarative approach to transaction configuration, you can use an annotation-based approach. Declaring transaction semantics directly in the Java source code puts the declarations much closer to the affected code. There is not much danger of undue coupling, because code that is meant to be used transactionally is almost always deployed that way anyway.</p> 
    <p>The ease-of-use afforded by the use of the <code class="literal">@Transactional</code> annotation is best illustrated with an example, which is explained in the text that follows. Consider the following class definition:</p> 
    <pre class="programlisting"><span class="hl-comment">// the service class that we want to make transactional</span>
<span class="strong"><strong>@Transactional</strong></span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> DefaultFooService <span class="hl-keyword">implements</span> FooService {

    Foo getFoo(String fooName);

    Foo getFoo(String fooName, String barName);

    <span class="hl-keyword">void</span> insertFoo(Foo foo);

    <span class="hl-keyword">void</span> updateFoo(Foo foo);
}</pre> 
    <p>When the above POJO is defined as a bean in a Spring IoC container, the bean instance can be made transactional by adding merely <span class="emphasis"><em>one</em></span> line of XML configuration:</p> 
    <pre class="programlisting"><span class="hl-comment">&lt;!-- from the file </span><span class="emphasis"><em>context.xml</em></span> --&gt;
<span class="hl-directive" style="color: maroon">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">&quot;http://www.springframework.org/schema/beans&quot;</span>
    <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>
    <span class="hl-attribute">xmlns:aop</span>=<span class="hl-value">&quot;http://www.springframework.org/schema/aop&quot;</span>
    <span class="hl-attribute">xmlns:tx</span>=<span class="hl-value">&quot;http://www.springframework.org/schema/tx&quot;</span>
    <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">&quot;
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx
        http://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span><span class="hl-tag">&gt;</span>

    <span class="hl-comment">&lt;!-- this is the service object that we want to make transactional --&gt;</span>
    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;fooService&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;x.y.service.DefaultFooService&quot;</span><span class="hl-tag">/&gt;</span>

    <span class="hl-comment">&lt;!-- enable the configuration of transactional behavior based on annotations --&gt;</span>
    <span class="emphasis"><em>&lt;tx:annotation-driven transaction-manager=&quot;txManager&quot;/&gt;</em></span><span class="hl-comment">&lt;!-- a PlatformTransactionManager is still required --&gt;</span>
    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;txManager&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span><span class="hl-tag">&gt;</span>
        <span class="hl-comment">&lt;!-- (this dependency is defined somewhere else) --&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;dataSource&quot;</span> <span class="hl-attribute">ref</span>=<span class="hl-value">&quot;dataSource&quot;</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

    <span class="hl-comment">&lt;!-- other &lt;bean/&gt; definitions here --&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre> 
    <div class="tip" title="Tip" style="margin-left: 0.5in; margin-right: 0.5in;">
     <table border="0" summary="Tip">
      <tbody>
       <tr>
        <td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="./Spring Framework Reference Documentation_files/tip.png" /></td>
        <th align="left">Tip</th>
       </tr>
       <tr>
        <td align="left" valign="top"> <p>You can omit the <code class="literal">transaction-manager</code> attribute in the <code class="literal">&lt;tx:annotation-driven/&gt;</code> tag if the bean name of the <code class="literal">PlatformTransactionManager</code> that you want to wire in has the name <code class="literal">transactionManager</code>. If the <code class="literal">PlatformTransactionManager</code> bean that you want to dependency-inject has any other name, then you have to use the <code class="literal">transaction-manager</code> attribute explicitly, as in the preceding example.</p> </td>
       </tr>
      </tbody>
     </table>
    </div> 
    <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;">
     <table border="0" summary="Note">
      <tbody>
       <tr>
        <td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Framework Reference Documentation_files/note.png" /></td>
        <th align="left">Note</th>
       </tr>
       <tr>
        <td align="left" valign="top"> <p>The <code class="literal">@EnableTransactionManagement</code> annotation provides equivalent support if you are using Java based configuration. Simply add the annotation to a <code class="literal">@Configuration</code> class. See Javadoc for full details.</p> </td>
       </tr>
      </tbody>
     </table>
    </div> 
    <div class="sidebar" title="Method visibility and @Transactional">
     <p class="title"><b>Method visibility and @Transactional</b></p> 
     <p>When using proxies, you should apply the <code class="literal">@Transactional</code> annotation only to methods with <span class="emphasis"><em>public</em></span> visibility. If you do annotate protected, private or package-visible methods with the <code class="literal">@Transactional</code> annotation, no error is raised, but the annotated method does not exhibit the configured transactional settings. Consider the use of AspectJ (see below) if you need to annotate non-public methods.</p> 
    </div> 
    <p>You can place the <code class="literal">@Transactional</code> annotation before an interface definition, a method on an interface, a class definition, or a <span class="emphasis"><em>public</em></span> method on a class. However, the mere presence of the <code class="literal">@Transactional</code> annotation is not enough to activate the transactional behavior. The <code class="literal">@Transactional</code> annotation is simply metadata that can be consumed by some runtime infrastructure that is <code class="literal">@Transactional</code>-aware and that can use the metadata to configure the appropriate beans with transactional behavior. In the preceding example, the <code class="literal">&lt;tx:annotation-driven/&gt;</code> element <span class="emphasis"><em>switches on</em></span> the transactional behavior.</p> 
    <div class="tip" title="Tip" style="margin-left: 0.5in; margin-right: 0.5in;">
     <table border="0" summary="Tip">
      <tbody>
       <tr>
        <td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="./Spring Framework Reference Documentation_files/tip.png" /></td>
        <th align="left">Tip</th>
       </tr>
       <tr>
        <td align="left" valign="top"> <p>Spring recommends that you only annotate concrete classes (and methods of concrete classes) with the <code class="literal">@Transactional</code> annotation, as opposed to annotating interfaces. You certainly can place the <code class="literal">@Transactional</code> annotation on an interface (or an interface method), but this works only as you would expect it to if you are using interface-based proxies. The fact that Java annotations are <span class="emphasis"><em>not inherited from interfaces</em></span> means that if you are using class-based proxies ( <code class="literal">proxy-target-class=&quot;true&quot;</code>) or the weaving-based aspect ( <code class="literal">mode=&quot;aspectj&quot;</code>), then the transaction settings are not recognized by the proxying and weaving infrastructure, and the object will not be wrapped in a transactional proxy, which would be decidedly <span class="emphasis"><em>bad</em></span>.</p> </td>
       </tr>
      </tbody>
     </table>
    </div> 
    <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;">
     <table border="0" summary="Note">
      <tbody>
       <tr>
        <td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Framework Reference Documentation_files/note.png" /></td>
        <th align="left">Note</th>
       </tr>
       <tr>
        <td align="left" valign="top"> <p>In proxy mode (which is the default), only external method calls coming in through the proxy are intercepted. This means that self-invocation, in effect, a method within the target object calling another method of the target object, will not lead to an actual transaction at runtime even if the invoked method is marked with <code class="literal">@Transactional</code>.</p> </td>
       </tr>
      </tbody>
     </table>
    </div> 
    <p>Consider the use of AspectJ mode (see mode attribute in table below) if you expect self-invocations to be wrapped with transactions as well. In this case, there will not be a proxy in the first place; instead, the target class will be weaved (that is, its byte code will be modified) in order to turn <code class="literal">@Transactional</code> into runtime behavior on any kind of method.</p> 
    <div class="table">
     <a name="tx-annotation-driven-settings"></a>
     <p class="title"><b>Table&nbsp;11.2.&nbsp;Annotation driven transaction settings</b></p>
     <div class="table-contents"> 
      <table summary="Annotation driven transaction settings" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; ">
       <colgroup>
        <col />
        <col />
        <col />
        <col />
       </colgroup>
       <thead>
        <tr>
         <th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">XML Attribute</th>
         <th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">Annotation Attribute</th>
         <th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">Default</th>
         <th style="border-bottom: 0.5pt solid ; " align="left" valign="top">Description</th>
        </tr>
       </thead>
       <tbody>
        <tr>
         <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">transaction-manager</code></p></td>
         <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>N/A (See <code class="literal">TransactionManagementConfigurer</code> Javadoc)</p></td>
         <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>transactionManager</p></td>
         <td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Name of transaction manager to use. Only required if the name of the transaction manager is not <code class="literal">transactionManager</code>, as in the example above.</p></td>
        </tr>
        <tr>
         <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">mode</code></p></td>
         <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">mode</code></p></td>
         <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>proxy</p></td>
         <td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>The default mode &quot;proxy&quot; processes annotated beans to be proxied using Springs AOP framework (following proxy semantics, as discussed above, applying to method calls coming in through the proxy only). The alternative mode &quot;aspectj&quot; instead weaves the affected classes with Springs AspectJ transaction aspect, modifying the target class byte code to apply to any kind of method call. AspectJ weaving requires spring-aspects.jar in the classpath as well as load-time weaving (or compile-time weaving) enabled. (See <a class="xref" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#aop-aj-ltw-spring" title="Spring configuration">the section called Spring configuration</a> for details on how to set up load-time weaving.)</p></td>
        </tr>
        <tr>
         <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">proxy-target-class</code></p></td>
         <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">proxyTargetClass</code></p></td>
         <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>false</p></td>
         <td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Applies to proxy mode only. Controls what type of transactional proxies are created for classes annotated with the <code class="literal">@Transactional</code> annotation. If the <code class="literal">proxy-target-class</code> attribute is set to <code class="literal">true</code>, then class-based proxies are created. If <code class="literal">proxy-target-class</code> is <code class="literal">false</code> or if the attribute is omitted, then standard JDK interface-based proxies are created. (See <a class="xref" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#aop-proxying" title="8.6&nbsp;Proxying mechanisms">Section&nbsp;8.6, Proxying mechanisms</a> for a detailed examination of the different proxy types.)</p></td>
        </tr>
        <tr>
         <td style="border-right: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">order</code></p></td>
         <td style="border-right: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">order</code></p></td>
         <td style="border-right: 0.5pt solid ; " align="left" valign="top"><p>Ordered.LOWEST_PRECEDENCE</p></td>
         <td style="" align="left" valign="top"><p>Defines the order of the transaction advice that is applied to beans annotated with <code class="literal">@Transactional</code>. (For more information about the rules related to ordering of AOP advice, see <a class="xref" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#aop-ataspectj-advice-ordering" title="Advice ordering">the section called Advice ordering</a>.) No specified ordering means that the AOP subsystem determines the order of the advice.</p></td>
        </tr>
       </tbody>
      </table> 
     </div>
    </div>
    <br class="table-break" /> 
    <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;">
     <table border="0" summary="Note">
      <tbody>
       <tr>
        <td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Framework Reference Documentation_files/note.png" /></td>
        <th align="left">Note</th>
       </tr>
       <tr>
        <td align="left" valign="top"> <p>The <code class="literal">proxy-target-class</code> attribute controls what type of transactional proxies are created for classes annotated with the <code class="literal">@Transactional</code> annotation. If <code class="literal">proxy-target-class</code> is set to <code class="literal">true</code>, class-based proxies are created. If <code class="literal">proxy-target-class</code> is <code class="literal">false</code> or if the attribute is omitted, standard JDK interface-based proxies are created. (See <a class="xref" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#aop-proxying" title="8.6&nbsp;Proxying mechanisms">Section&nbsp;8.6, Proxying mechanisms</a> for a discussion of the different proxy types.)</p> </td>
       </tr>
      </tbody>
     </table>
    </div> 
    <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;">
     <table border="0" summary="Note">
      <tbody>
       <tr>
        <td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Framework Reference Documentation_files/note.png" /></td>
        <th align="left">Note</th>
       </tr>
       <tr>
        <td align="left" valign="top"> <p><code class="literal">@EnableTransactionManagement</code> and <code class="literal">&lt;tx:annotation-driven/&gt;</code> only looks for <code class="literal">@Transactional</code> on beans in the same application context they are defined in. This means that, if you put annotation driven configuration in a <code class="literal">WebApplicationContext</code> for a <code class="literal">DispatcherServlet</code>, it only checks for <code class="literal">@Transactional</code> beans in your controllers, and not your services. See <a class="xref" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#mvc-servlet" title="16.2&nbsp;The DispatcherServlet">Section&nbsp;16.2, The DispatcherServlet</a> for more information.</p> </td>
       </tr>
      </tbody>
     </table>
    </div> 
    <p>The most derived location takes precedence when evaluating the transactional settings for a method. In the case of the following example, the <code class="literal">DefaultFooService</code> class is annotated at the class level with the settings for a read-only transaction, but the <code class="literal">@Transactional</code> annotation on the <code class="literal">updateFoo(Foo)</code> method in the same class takes precedence over the transactional settings defined at the class level.</p> 
    <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@Transactional(readOnly = true)</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> DefaultFooService <span class="hl-keyword">implements</span> FooService {

    <span class="hl-keyword">public</span> Foo getFoo(String fooName) {
        <span class="hl-comment">// do something</span>
    }

    <span class="hl-comment">// these settings have precedence for this method</span>
    <i><span class="hl-annotation" style="color: gray">@Transactional(readOnly = false, propagation = Propagation.REQUIRES_NEW)</span></i>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> updateFoo(Foo foo) {
        <span class="hl-comment">// do something</span>
    }
}</pre> 
    <div class="section" title="@Transactional settings">
     <div class="titlepage">
      <div>
       <div>
        <h4 class="title"><a name="transaction-declarative-attransactional-settings"></a>@Transactional settings</h4>
       </div>
      </div>
     </div> 
     <p>The <code class="literal">@Transactional</code> annotation is metadata that specifies that an interface, class, or method must have transactional semantics; for example, &quot;<span class="emphasis"><em>start a brand new read-only transaction when this method is invoked, suspending any existing transaction</em></span>&quot;. The default <code class="literal">@Transactional</code> settings are as follows:</p> 
     <div class="itemizedlist">
      <ul class="itemizedlist" type="disc">
       <li class="listitem"> Propagation setting is <code class="literal">PROPAGATION_REQUIRED.</code> </li>
       <li class="listitem"> Isolation level is <code class="literal">ISOLATION_DEFAULT.</code> </li>
       <li class="listitem"> Transaction is read/write. </li>
       <li class="listitem"> Transaction timeout defaults to the default timeout of the underlying transaction system, or to none if timeouts are not supported. </li>
       <li class="listitem"> Any <code class="literal">RuntimeException</code> triggers rollback, and any checked <code class="literal">Exception</code> does not. </li>
      </ul>
     </div> 
     <p>These default settings can be changed; the various properties of the <code class="literal">@Transactional</code> annotation are summarized in the following table:</p> 
     <div class="table">
      <a name="tx-attransactional-properties"></a>
      <p class="title"><b>Table&nbsp;11.3.&nbsp;@</b></p>
      <div class="table-contents"> 
       <table summary="@" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; ">
        <colgroup>
         <col />
         <col />
         <col />
        </colgroup>
        <thead>
         <tr>
          <th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">Property</th>
          <th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">Type</th>
          <th style="border-bottom: 0.5pt solid ; " align="left" valign="top">Description</th>
         </tr>
        </thead>
        <tbody>
         <tr>
          <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><a class="link" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#tx-multiple-tx-mgrs-with-attransactional" title="Multiple Transaction Managers with @Transactional">value</a></p></td>
          <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>String</p></td>
          <td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Optional qualifier specifying the transaction manager to be used.</p></td>
         </tr>
         <tr>
          <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><a class="link" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#tx-propagation" title="11.5.7&nbsp;Transaction propagation">propagation</a></p></td>
          <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>enum: <code class="literal">Propagation</code></p></td>
          <td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Optional propagation setting.</p></td>
         </tr>
         <tr>
          <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">isolation</code></p></td>
          <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>enum: <code class="literal">Isolation</code></p></td>
          <td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Optional isolation level.</p></td>
         </tr>
         <tr>
          <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">readOnly</code></p></td>
          <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>boolean</p></td>
          <td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Read/write vs. read-only transaction</p></td>
         </tr>
         <tr>
          <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">timeout</code></p></td>
          <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>int (in seconds granularity)</p></td>
          <td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Transaction timeout.</p></td>
         </tr>
         <tr>
          <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">rollbackFor</code></p></td>
          <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Array of <code class="literal">Class</code> objects, which must be derived from <code class="literal">Throwable.</code></p></td>
          <td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Optional array of exception classes that <span class="emphasis"><em>must</em></span> cause rollback.</p></td>
         </tr>
         <tr>
          <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">rollbackForClassName</code></p></td>
          <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Array of class names. Classes must be derived from <code class="literal">Throwable.</code></p></td>
          <td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Optional array of names of exception classes that <span class="emphasis"><em>must</em></span> cause rollback.</p></td>
         </tr>
         <tr>
          <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">noRollbackFor</code></p></td>
          <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Array of <code class="literal">Class</code> objects, which must be derived from <code class="literal">Throwable.</code></p></td>
          <td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Optional array of exception classes that <span class="emphasis"><em>must not</em></span> cause rollback.</p></td>
         </tr>
         <tr>
          <td style="border-right: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">noRollbackForClassName</code></p></td>
          <td style="border-right: 0.5pt solid ; " align="left" valign="top"><p>Array of <code class="literal">String</code> class names, which must be derived from <code class="literal">Throwable.</code></p></td>
          <td style="" align="left" valign="top"><p>Optional array of names of exception classes that <span class="emphasis"><em>must not</em></span> cause rollback.</p></td>
         </tr>
        </tbody>
       </table> 
      </div>
     </div>
     <br class="table-break" /> 
     <p>Currently you cannot have explicit control over the name of a transaction, where <span class="emphasis"><em>name</em></span> means the transaction name that will be shown in a transaction monitor, if applicable (for example, WebLogics transaction monitor), and in logging output. For declarative transactions, the transaction name is always the fully-qualified class name + &quot;.&quot; + method name of the transactionally-advised class. For example, if the <code class="literal">handlePayment(..)</code> method of the <code class="literal">BusinessService</code> class started a transaction, the name of the transaction would be: <code class="literal">com.foo.BusinessService.handlePayment</code>.</p> 
    </div> 
    <div class="section" title="Multiple Transaction Managers with @Transactional">
     <div class="titlepage">
      <div>
       <div>
        <h4 class="title"><a name="tx-multiple-tx-mgrs-with-attransactional"></a>Multiple Transaction Managers with @Transactional</h4>
       </div>
      </div>
     </div> 
     <p>Most Spring applications only need a single transaction manager, but there may be situations where you want multiple independent transaction managers in a single application. The value attribute of the <code class="literal">@Transactional</code> annotation can be used to optionally specify the identity of the <code class="literal">PlatformTransactionManager</code> to be used. This can either be the bean name or the qualifier value of the transaction manager bean. For example, using the qualifier notation, the following Java code</p> 
     <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> TransactionalService {

    <i><span class="hl-annotation" style="color: gray">@Transactional(&quot;order&quot;)</span></i>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setSomething(String name) { ... }

    <i><span class="hl-annotation" style="color: gray">@Transactional(&quot;account&quot;)</span></i>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> doSomething() { ... }
}</pre> 
     <p>could be combined with the following transaction manager bean declarations in the application context.</p> 
     <pre class="programlisting"><span class="hl-tag">&lt;tx:annotation-driven/&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;transactionManager1&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;org.springframework.jdbc.DataSourceTransactionManager&quot;</span><span class="hl-tag">&gt;</span>
        ...
        <span class="hl-tag">&lt;qualifier</span> <span class="hl-attribute">value</span>=<span class="hl-value">&quot;order&quot;</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;transactionManager2&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;org.springframework.jdbc.DataSourceTransactionManager&quot;</span><span class="hl-tag">&gt;</span>
        ...
        <span class="hl-tag">&lt;qualifier</span> <span class="hl-attribute">value</span>=<span class="hl-value">&quot;account&quot;</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span></pre> 
     <p>In this case, the two methods on <code class="literal">TransactionalService</code> will run under separate transaction managers, differentiated by the &quot;order&quot; and &quot;account&quot; qualifiers. The default <code class="literal">&lt;tx:annotation-driven&gt;</code> target bean name <code class="literal">transactionManager</code> will still be used if no specifically qualified PlatformTransactionManager bean is found.</p> 
    </div> 
    <div class="section" title="Custom shortcut annotations">
     <div class="titlepage">
      <div>
       <div>
        <h4 class="title"><a name="tx-custom-attributes"></a>Custom shortcut annotations</h4>
       </div>
      </div>
     </div> 
     <p>If you find you are repeatedly using the same attributes with <code class="literal">@Transactional</code> on many different methods, then <a class="link" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#beans-meta-annotations" title="4.10.2&nbsp;Meta-annotations">Springs meta-annotation support</a> allows you to define custom shortcut annotations for your specific use cases. For example, defining the following annotations</p> 
     <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@Target({ElementType.METHOD, ElementType.TYPE})</span></i>
<i><span class="hl-annotation" style="color: gray">@Retention(RetentionPolicy.RUNTIME)</span></i>
<i><span class="hl-annotation" style="color: gray">@Transactional(&quot;order&quot;)</span></i>
<span class="hl-keyword">public</span> <i><span class="hl-annotation" style="color: gray">@interface</span></i> OrderTx {
}

<i><span class="hl-annotation" style="color: gray">@Target({ElementType.METHOD, ElementType.TYPE})</span></i>
<i><span class="hl-annotation" style="color: gray">@Retention(RetentionPolicy.RUNTIME)</span></i>
<i><span class="hl-annotation" style="color: gray">@Transactional(&quot;account&quot;)</span></i>
<span class="hl-keyword">public</span> <i><span class="hl-annotation" style="color: gray">@interface</span></i> AccountTx {
}</pre> 
     <p>allows us to write the example from the previous section as</p> 
     <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> TransactionalService {

    <i><span class="hl-annotation" style="color: gray">@OrderTx</span></i>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setSomething(String name) { ... }

    <i><span class="hl-annotation" style="color: gray">@AccountTx</span></i>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> doSomething() { ... }
}</pre> 
     <p>Here we have used the syntax to define the transaction manager qualifier, but could also have included propagation behavior, rollback rules, timeouts etc.</p> 
    </div> 
   </div> 
   <div class="section" title="11.5.7&nbsp;Transaction propagation">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="tx-propagation"></a>11.5.7&nbsp;Transaction propagation</h3>
      </div>
     </div>
    </div> 
    <p>This section describes some semantics of transaction propagation in Spring. Please note that this section is not an introduction to transaction propagation proper; rather it details some of the semantics regarding transaction propagation in Spring.</p> 
    <p>In Spring-managed transactions, be aware of the difference between <span class="emphasis"><em>physical</em></span> and <span class="emphasis"><em>logical</em></span> transactions, and how the propagation setting applies to this difference.</p> 
    <div class="section" title="Required">
     <div class="titlepage">
      <div>
       <div>
        <h4 class="title"><a name="tx-propagation-required"></a>Required</h4>
       </div>
      </div>
     </div> 
     <div class="figure">
      <a name="d4e10319"></a>
      <p class="title"><b>Figure&nbsp;11.2.&nbsp;</b></p>
      <div class="figure-contents"> 
       <div class="mediaobject">
        <img src="./Spring Framework Reference Documentation_files/tx_prop_required.png" alt="tx prop required" />
       </div> 
      </div>
     </div>
     <br class="figure-break" /> 
     <p>PROPAGATION_REQUIRED</p> 
     <p>When the propagation setting is <code class="literal">PROPAGATION_REQUIRED</code>, a <span class="emphasis"><em>logical</em></span> transaction scope is created for each method upon which the setting is applied. Each such logical transaction scope can determine rollback-only status individually, with an outer transaction scope being logically independent from the inner transaction scope. Of course, in case of standard <code class="literal">PROPAGATION_REQUIRED</code> behavior, all these scopes will be mapped to the same physical transaction. So a rollback-only marker set in the inner transaction scope does affect the outer transactions chance to actually commit (as you would expect it to).</p> 
     <p>However, in the case where an inner transaction scope sets the rollback-only marker, the outer transaction has not decided on the rollback itself, and so the rollback (silently triggered by the inner transaction scope) is unexpected. A corresponding <code class="literal">UnexpectedRollbackException</code> is thrown at that point. This is <span class="emphasis"><em>expected behavior</em></span> so that the caller of a transaction can never be misled to assume that a commit was performed when it really was not. So if an inner transaction (of which the outer caller is not aware) silently marks a transaction as rollback-only, the outer caller still calls commit. The outer caller needs to receive an <code class="literal">UnexpectedRollbackException</code> to indicate clearly that a rollback was performed instead.</p> 
    </div> 
    <div class="section" title="RequiresNew">
     <div class="titlepage">
      <div>
       <div>
        <h4 class="title"><a name="tx-propagation-requires_new"></a>RequiresNew</h4>
       </div>
      </div>
     </div> 
     <div class="figure">
      <a name="d4e10336"></a>
      <p class="title"><b>Figure&nbsp;11.3.&nbsp;</b></p>
      <div class="figure-contents"> 
       <div class="mediaobject">
        <img src="./Spring Framework Reference Documentation_files/tx_prop_requires_new.png" alt="tx prop requires new" />
       </div> 
      </div>
     </div>
     <br class="figure-break" /> 
     <p>PROPAGATION_REQUIRES_NEW</p> 
     <p><code class="literal">PROPAGATION_REQUIRES_NEW</code>, in contrast to <code class="literal">PROPAGATION_REQUIRED</code>, uses a <span class="emphasis"><em>completely</em></span> independent transaction for each affected transaction scope. In that case, the underlying physical transactions are different and hence can commit or roll back independently, with an outer transaction not affected by an inner transactions rollback status.</p> 
    </div> 
    <div class="section" title="Nested">
     <div class="titlepage">
      <div>
       <div>
        <h4 class="title"><a name="tx-propagation-nested"></a>Nested</h4>
       </div>
      </div>
     </div> 
     <p><code class="literal">PROPAGATION_NESTED</code> uses a <span class="emphasis"><em>single</em></span> physical transaction with multiple savepoints that it can roll back to. Such partial rollbacks allow an inner transaction scope to trigger a rollback <span class="emphasis"><em>for its scope</em></span>, with the outer transaction being able to continue the physical transaction despite some operations having been rolled back. This setting is typically mapped onto JDBC savepoints, so will only work with JDBC resource transactions. See Springs <code class="literal">DataSourceTransactionManager</code>.</p> 
    </div> 
   </div> 
   <div class="section" title="11.5.8&nbsp;Advising transactional operations">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="transaction-declarative-applying-more-than-just-tx-advice"></a>11.5.8&nbsp;Advising transactional operations</h3>
      </div>
     </div>
    </div> 
    <p>Suppose you want to execute <span class="emphasis"><em>both</em></span> transactional <span class="emphasis"><em>and</em></span> some basic profiling advice. How do you effect this in the context of <code class="literal">&lt;tx:annotation-driven/&gt;</code>?</p> 
    <p>When you invoke the <code class="literal">updateFoo(Foo)</code> method, you want to see the following actions:</p> 
    <div class="itemizedlist">
     <ul class="itemizedlist" type="disc">
      <li class="listitem"> Configured profiling aspect starts up. </li>
      <li class="listitem"> Transactional advice executes. </li>
      <li class="listitem"> Method on the advised object executes. </li>
      <li class="listitem"> Transaction commits. </li>
      <li class="listitem"> Profiling aspect reports exact duration of the whole transactional method invocation. </li>
     </ul>
    </div> 
    <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;">
     <table border="0" summary="Note">
      <tbody>
       <tr>
        <td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Framework Reference Documentation_files/note.png" /></td>
        <th align="left">Note</th>
       </tr>
       <tr>
        <td align="left" valign="top"> <p>This chapter is not concerned with explaining AOP in any great detail (except as it applies to transactions). See <a class="xref" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#aop" title="8.&nbsp;Aspect Oriented Programming with Spring">Chapter&nbsp;8, <i>Aspect Oriented Programming with Spring</i></a> for detailed coverage of the following AOP configuration and AOP in general.</p> </td>
       </tr>
      </tbody>
     </table>
    </div> 
    <p>Here is the code for a simple profiling aspect discussed above. The ordering of advice is controlled through the <code class="literal">Ordered</code> interface. For full details on advice ordering, see <a class="xref" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#aop-ataspectj-advice-ordering" title="Advice ordering">the section called Advice ordering</a>. .</p> 
    <pre class="programlisting"><span class="hl-keyword">package</span> x.y;

<span class="hl-keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;
<span class="hl-keyword">import</span> org.springframework.util.StopWatch;
<span class="hl-keyword">import</span> org.springframework.core.Ordered;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> SimpleProfiler <span class="hl-keyword">implements</span> Ordered {

    <span class="hl-keyword">private</span> <span class="hl-keyword">int</span> order;

    <span class="hl-comment">// allows us to control the ordering of advice</span>
    <span class="hl-keyword">public</span> <span class="hl-keyword">int</span> getOrder() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>.order;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setOrder(<span class="hl-keyword">int</span> order) {
        <span class="hl-keyword">this</span>.order = order;
    }

    <span class="hl-comment">// this method </span><span class="strong"><strong>is</strong></span> the around advice
    <span class="hl-keyword">public</span> Object profile(ProceedingJoinPoint call) <span class="hl-keyword">throws</span> Throwable {
        Object returnValue;
        StopWatch clock = <span class="hl-keyword">new</span> StopWatch(getClass().getName());
        <span class="hl-keyword">try</span> {
            clock.start(call.toShortString());
            returnValue = call.proceed();
        } <span class="hl-keyword">finally</span> {
            clock.stop();
            System.out.println(clock.prettyPrint());
        }
        <span class="hl-keyword">return</span> returnValue;
    }
}</pre> 
    <pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">&quot;http://www.springframework.org/schema/beans&quot;</span>
    <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>
    <span class="hl-attribute">xmlns:aop</span>=<span class="hl-value">&quot;http://www.springframework.org/schema/aop&quot;</span>
    <span class="hl-attribute">xmlns:tx</span>=<span class="hl-value">&quot;http://www.springframework.org/schema/tx&quot;</span>
    <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">&quot;
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx
        http://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span><span class="hl-tag">&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;fooService&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;x.y.service.DefaultFooService&quot;</span><span class="hl-tag">/&gt;</span>

    <span class="hl-comment">&lt;!-- this is the aspect --&gt;</span>
    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;profiler&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;x.y.SimpleProfiler&quot;</span><span class="hl-tag">&gt;</span>
        <span class="hl-comment">&lt;!-- execute before the transactional advice (hence the lower order number) --&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;order&quot;</span> <span class="emphasis"><em>value=&quot;1&quot;</em></span>/&gt;
    <span class="hl-tag">&lt;/bean&gt;</span>

    <span class="hl-tag">&lt;tx:annotation-driven</span> <span class="hl-attribute">transaction-manager</span>=<span class="hl-value">&quot;txManager&quot;</span> <span class="emphasis"><em>order=&quot;200&quot;</em></span>/&gt;

    <span class="hl-tag">&lt;aop:config&gt;</span>
            <span class="hl-comment">&lt;!-- this advice will execute around the transactional advice --&gt;</span>
            <span class="hl-tag">&lt;aop:aspect</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;profilingAspect&quot;</span> <span class="hl-attribute">ref</span>=<span class="hl-value">&quot;profiler&quot;</span><span class="hl-tag">&gt;</span>
                <span class="hl-tag">&lt;aop:pointcut</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;serviceMethodWithReturnValue&quot;</span>
                        <span class="hl-attribute">expression</span>=<span class="hl-value">&quot;execution(!void x.y..</span><span class="strong"><strong>Service.</strong></span>(..))&quot;/&gt;
                <span class="hl-tag">&lt;aop:around</span> <span class="hl-attribute">method</span>=<span class="hl-value">&quot;profile&quot;</span> <span class="hl-attribute">pointcut-ref</span>=<span class="hl-value">&quot;serviceMethodWithReturnValue&quot;</span><span class="hl-tag">/&gt;</span>
            <span class="hl-tag">&lt;/aop:aspect&gt;</span>
    <span class="hl-tag">&lt;/aop:config&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;dataSource&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span> <span class="hl-attribute">destroy-method</span>=<span class="hl-value">&quot;close&quot;</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;driverClassName&quot;</span> <span class="hl-attribute">value</span>=<span class="hl-value">&quot;oracle.jdbc.driver.OracleDriver&quot;</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;url&quot;</span> <span class="hl-attribute">value</span>=<span class="hl-value">&quot;jdbc:oracle:thin:@rj-t42:1521:elvis&quot;</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;username&quot;</span> <span class="hl-attribute">value</span>=<span class="hl-value">&quot;scott&quot;</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;password&quot;</span> <span class="hl-attribute">value</span>=<span class="hl-value">&quot;tiger&quot;</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;txManager&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;dataSource&quot;</span> <span class="hl-attribute">ref</span>=<span class="hl-value">&quot;dataSource&quot;</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre> 
    <p>The result of the above configuration is a <code class="literal">fooService</code> bean that has profiling and transactional aspects applied to it <span class="emphasis"><em>in the desired order</em></span>. You configure any number of additional aspects in similar fashion.</p> 
    <p>The following example effects the same setup as above, but uses the purely XML declarative approach.</p> 
    <pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">&quot;http://www.springframework.org/schema/beans&quot;</span>
    <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>
    <span class="hl-attribute">xmlns:aop</span>=<span class="hl-value">&quot;http://www.springframework.org/schema/aop&quot;</span>
    <span class="hl-attribute">xmlns:tx</span>=<span class="hl-value">&quot;http://www.springframework.org/schema/tx&quot;</span>
    <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">&quot;
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx
        http://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span><span class="hl-tag">&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;fooService&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;x.y.service.DefaultFooService&quot;</span><span class="hl-tag">/&gt;</span>

    <span class="hl-comment">&lt;!-- the profiling advice --&gt;</span>
    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;profiler&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;x.y.SimpleProfiler&quot;</span><span class="hl-tag">&gt;</span>
        <span class="hl-comment">&lt;!-- execute before the transactional advice (hence the lower order number) --&gt;</span>
        <span class="emphasis"><em>&lt;property name=&quot;order&quot; value=&quot;1</em></span>&quot;/&gt;
    <span class="hl-tag">&lt;/bean&gt;</span>

    <span class="hl-tag">&lt;aop:config&gt;</span>
        <span class="hl-tag">&lt;aop:pointcut</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;entryPointMethod&quot;</span> <span class="hl-attribute">expression</span>=<span class="hl-value">&quot;execution(* x.y..</span><span class="strong"><strong>Service.</strong></span>(..))&quot;/&gt;
        <span class="hl-comment">&lt;!-- will execute after the profiling advice (c.f. the order attribute) --&gt;</span>

        <span class="hl-tag">&lt;aop:advisor</span> <span class="hl-attribute">advice-ref</span>=<span class="hl-value">&quot;txAdvice&quot;</span> <span class="hl-attribute">pointcut-ref</span>=<span class="hl-value">&quot;entryPointMethod&quot;</span> <span class="emphasis"><em>order=&quot;2</em></span>&quot;/&gt;
        <span class="hl-comment">&lt;!-- order value is higher than the profiling aspect --&gt;</span>

        <span class="hl-tag">&lt;aop:aspect</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;profilingAspect&quot;</span> <span class="hl-attribute">ref</span>=<span class="hl-value">&quot;profiler&quot;</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;aop:pointcut</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;serviceMethodWithReturnValue&quot;</span>
                    <span class="hl-attribute">expression</span>=<span class="hl-value">&quot;execution(!void x.y..</span><span class="strong"><strong>Service.</strong></span>(..))&quot;/&gt;
            <span class="hl-tag">&lt;aop:around</span> <span class="hl-attribute">method</span>=<span class="hl-value">&quot;profile&quot;</span> <span class="hl-attribute">pointcut-ref</span>=<span class="hl-value">&quot;serviceMethodWithReturnValue&quot;</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;/aop:aspect&gt;</span>

    <span class="hl-tag">&lt;/aop:config&gt;</span>

    <span class="hl-tag">&lt;tx:advice</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;txAdvice&quot;</span> <span class="hl-attribute">transaction-manager</span>=<span class="hl-value">&quot;txManager&quot;</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;tx:attributes&gt;</span>
            <span class="hl-tag">&lt;tx:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;get*&quot;</span> <span class="hl-attribute">read-only</span>=<span class="hl-value">&quot;true&quot;</span><span class="hl-tag">/&gt;</span>
            <span class="hl-tag">&lt;tx:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;*&quot;</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;/tx:attributes&gt;</span>
    <span class="hl-tag">&lt;/tx:advice&gt;</span>

    <span class="hl-comment">&lt;!-- other &lt;bean/&gt; definitions such as a DataSource and a PlatformTransactionManager here --&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre> 
    <p>The result of the above configuration will be a <code class="literal">fooService</code> bean that has profiling and transactional aspects applied to it <span class="emphasis"><em>in that order</em></span>. If you want the profiling advice to execute <span class="emphasis"><em>after</em></span> the transactional advice on the way in, and <span class="emphasis"><em>before</em></span> the transactional advice on the way out, then you simply swap the value of the profiling aspect beans <code class="literal">order</code> property so that it is higher than the transactional advices order value.</p> 
    <p>You configure additional aspects in similar fashion.</p> 
   </div> 
   <div class="section" title="11.5.9&nbsp;Using @Transactional with AspectJ">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="transaction-declarative-aspectj"></a>11.5.9&nbsp;Using @Transactional with AspectJ</h3>
      </div>
     </div>
    </div> 
    <p>It is also possible to use the Spring Frameworks <code class="literal">@Transactional</code> support outside of a Spring container by means of an AspectJ aspect. To do so, you first annotate your classes (and optionally your classes' methods) with the <code class="literal">@Transactional</code> annotation, and then you link (weave) your application with the <code class="literal">org.springframework.transaction.aspectj.AnnotationTransactionAspect</code> defined in the <code class="literal">spring-aspects.jar</code> file. The aspect must also be configured with a transaction manager. You can of course use the Spring Frameworks IoC container to take care of dependency-injecting the aspect. The simplest way to configure the transaction management aspect is to use the <code class="literal">&lt;tx:annotation-driven/&gt;</code> element and specify the <code class="literal">mode</code> attribute to <code class="literal">aspectj</code> as described in <a class="xref" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#transaction-declarative-annotations" title="11.5.6&nbsp;Using @Transactional">Section&nbsp;11.5.6, Using @Transactional</a>. Because were focusing here on applications running outside of a Spring container, well show you how to do it programmatically.</p> 
    <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;">
     <table border="0" summary="Note">
      <tbody>
       <tr>
        <td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Framework Reference Documentation_files/note.png" /></td>
        <th align="left">Note</th>
       </tr>
       <tr>
        <td align="left" valign="top"> <p>Prior to continuing, you may want to read <a class="xref" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#transaction-declarative-annotations" title="11.5.6&nbsp;Using @Transactional">Section&nbsp;11.5.6, Using @Transactional</a> and <a class="xref" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#aop" title="8.&nbsp;Aspect Oriented Programming with Spring">Chapter&nbsp;8, <i>Aspect Oriented Programming with Spring</i></a> respectively.</p> </td>
       </tr>
      </tbody>
     </table>
    </div> 
    <pre class="programlisting"><span class="hl-comment">// construct an appropriate transaction manager</span>
DataSourceTransactionManager txManager = <span class="hl-keyword">new</span> DataSourceTransactionManager(getDataSource());

<span class="hl-comment">// configure the AnnotationTransactionAspect to use it; this must be done before executing any transactional methods</span>
AnnotationTransactionAspect.aspectOf().setTransactionManager(txManager);</pre> 
    <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;">
     <table border="0" summary="Note">
      <tbody>
       <tr>
        <td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Framework Reference Documentation_files/note.png" /></td>
        <th align="left">Note</th>
       </tr>
       <tr>
        <td align="left" valign="top"> <p>When using this aspect, you must annotate the <span class="emphasis"><em>implementation</em></span> class (and/or methods within that class), <span class="emphasis"><em>not</em></span> the interface (if any) that the class implements. AspectJ follows Javas rule that annotations on interfaces are <span class="emphasis"><em>not inherited</em></span>.</p> </td>
       </tr>
      </tbody>
     </table>
    </div> 
    <p>The <code class="literal">@Transactional</code> annotation on a class specifies the default transaction semantics for the execution of any method in the class.</p> 
    <p>The <code class="literal">@Transactional</code> annotation on a method within the class overrides the default transaction semantics given by the class annotation (if present). Any method may be annotated, regardless of visibility.</p> 
    <p>To weave your applications with the <code class="literal">AnnotationTransactionAspect</code> you must either build your application with AspectJ (see the <a class="ulink" href="http://www.eclipse.org/aspectj/doc/released/devguide/index.html" target="_top">AspectJ Development Guide</a>) or use load-time weaving. See <a class="xref" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#aop-aj-ltw" title="8.8.4&nbsp;Load-time weaving with AspectJ in the Spring Framework">Section&nbsp;8.8.4, Load-time weaving with AspectJ in the Spring Framework</a> for a discussion of load-time weaving with AspectJ.</p> 
   </div> 
  </div> 
  <div class="section" title="11.6&nbsp;Programmatic transaction management">
   <div class="titlepage">
    <div>
     <div>
      <h2 class="title" style="clear: both"><a name="transaction-programmatic"></a>11.6&nbsp;Programmatic transaction management</h2>
     </div>
    </div>
   </div> 
   <p>The Spring Framework provides two means of programmatic transaction management:</p> 
   <div class="itemizedlist">
    <ul class="itemizedlist" type="disc">
     <li class="listitem"> Using the <code class="literal">TransactionTemplate</code>. </li>
     <li class="listitem"> Using a <code class="literal">PlatformTransactionManager</code> implementation directly. </li>
    </ul>
   </div> 
   <p>The Spring team generally recommends the <code class="literal">TransactionTemplate</code> for programmatic transaction management. The second approach is similar to using the JTA <code class="literal">UserTransaction</code> API, although exception handling is less cumbersome.</p> 
   <div class="section" title="11.6.1&nbsp;Using the TransactionTemplate">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="tx-prog-template"></a>11.6.1&nbsp;Using the TransactionTemplate</h3>
      </div>
     </div>
    </div> 
    <p>The <code class="literal">TransactionTemplate</code> adopts the same approach as other Spring <span class="emphasis"><em>templates</em></span> such as the <code class="literal">JdbcTemplate</code>. It uses a callback approach, to free application code from having to do the boilerplate acquisition and release of transactional resources, and results in code that is intention driven, in that the code that is written focuses solely on what the developer wants to do.</p> 
    <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;">
     <table border="0" summary="Note">
      <tbody>
       <tr>
        <td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Framework Reference Documentation_files/note.png" /></td>
        <th align="left">Note</th>
       </tr>
       <tr>
        <td align="left" valign="top"> <p>As you will see in the examples that follow, using the <code class="literal">TransactionTemplate</code> absolutely couples you to Springs transaction infrastructure and APIs. Whether or not programmatic transaction management is suitable for your development needs is a decision that you will have to make yourself.</p> </td>
       </tr>
      </tbody>
     </table>
    </div> 
    <p>Application code that must execute in a transactional context, and that will use the <code class="literal">TransactionTemplate</code> explicitly, looks like the following. You, as an application developer, write a <code class="literal">TransactionCallback</code> implementation (typically expressed as an anonymous inner class) that contains the code that you need to execute in the context of a transaction. You then pass an instance of your custom <code class="literal">TransactionCallback</code> to the <code class="literal">execute(..)</code> method exposed on the <code class="literal">TransactionTemplate</code>.</p> 
    <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> SimpleService <span class="hl-keyword">implements</span> Service {

    <span class="hl-comment">// single TransactionTemplate shared amongst all methods in this instance</span>
    <span class="hl-keyword">private</span> <span class="hl-keyword">final</span> TransactionTemplate transactionTemplate;

    <span class="hl-comment">// use constructor-injection to supply the PlatformTransactionManager</span>
    <span class="hl-keyword">public</span> SimpleService(PlatformTransactionManager transactionManager) {
        Assert.notNull(transactionManager, <span class="hl-string">&quot;The </span><span class="emphasis"><em>transactionManager</em></span> argument must not be null.<span class="hl-string">&quot;);
</span>        <span class="hl-keyword">this</span>.transactionTemplate = <span class="hl-keyword">new</span> TransactionTemplate(transactionManager);
    }

    <span class="hl-keyword">public</span> Object someServiceMethod() {
        <span class="hl-keyword">return</span> transactionTemplate.execute(<span class="hl-keyword">new</span> TransactionCallback() {
            <span class="hl-comment">// the code in this method executes in a transactional context</span>
            <span class="hl-keyword">public</span> Object doInTransaction(TransactionStatus status) {
                updateOperation1();
                <span class="hl-keyword">return</span> resultOfUpdateOperation2();
            }
        });
    }
}</pre> 
    <p>If there is no return value, use the convenient <code class="literal">TransactionCallbackWithoutResult</code> class with an anonymous class as follows:</p> 
    <pre class="programlisting">transactionTemplate.execute(<span class="hl-keyword">new</span> <span class="strong"><strong>TransactionCallbackWithoutResult</strong></span>() {
    <span class="hl-keyword">protected</span> <span class="hl-keyword">void</span> doInTransactionWithoutResult(TransactionStatus status) {
        updateOperation1();
        updateOperation2();
    }
});</pre> 
    <p>Code within the callback can roll the transaction back by calling the <code class="literal">setRollbackOnly()</code> method on the supplied <code class="literal">TransactionStatus</code> object:</p> 
    <pre class="programlisting">transactionTemplate.execute(<span class="hl-keyword">new</span> TransactionCallbackWithoutResult() {

    <span class="hl-keyword">protected</span> <span class="hl-keyword">void</span> doInTransactionWithoutResult(TransactionStatus status) {
        <span class="hl-keyword">try</span> {
            updateOperation1();
            updateOperation2();
        } <span class="hl-keyword">catch</span> (SomeBusinessExeption ex) {
            <span class="strong"><strong>status.setRollbackOnly();</strong></span>
        }
    }
});</pre> 
    <div class="section" title="Specifying transaction settings">
     <div class="titlepage">
      <div>
       <div>
        <h4 class="title"><a name="tx-prog-template-settings"></a>Specifying transaction settings</h4>
       </div>
      </div>
     </div> 
     <p>You can specify transaction settings such as the propagation mode, the isolation level, the timeout, and so forth on the <code class="literal">TransactionTemplate</code> either programmatically or in configuration. <code class="literal">TransactionTemplate</code> instances by default have the <a class="link" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#transaction-declarative-txadvice-settings" title="11.5.5&nbsp;&lt;tx:advice/&gt; settings">default transactional settings</a>. The following example shows the programmatic customization of the transactional settings for a specific <code class="literal">TransactionTemplate:</code></p> 
     <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> SimpleService <span class="hl-keyword">implements</span> Service {

    <span class="hl-keyword">private</span> <span class="hl-keyword">final</span> TransactionTemplate transactionTemplate;

    <span class="hl-keyword">public</span> SimpleService(PlatformTransactionManager transactionManager) {
        Assert.notNull(transactionManager, <span class="hl-string">&quot;The </span><span class="emphasis"><em>transactionManager</em></span> argument must not be null.<span class="hl-string">&quot;);
</span>        <span class="hl-keyword">this</span>.transactionTemplate = <span class="hl-keyword">new</span> TransactionTemplate(transactionManager);

        <span class="hl-comment">// the transaction settings can be set here explicitly if so desired</span>
        <span class="hl-keyword">this</span>.transactionTemplate.setIsolationLevel(TransactionDefinition.ISOLATION_READ_UNCOMMITTED);
        <span class="hl-keyword">this</span>.transactionTemplate.setTimeout(<span class="hl-number">30</span>); <span class="hl-comment">// 30 seconds</span>
        <span class="hl-comment">// and so forth...</span>
    }
}</pre> 
     <p>The following example defines a <code class="literal">TransactionTemplate</code> with some custom transactional settings, using Spring XML configuration. The <code class="literal">sharedTransactionTemplate</code> can then be injected into as many services as are required.</p> 
     <pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;sharedTransactionTemplate&quot;</span>
        <span class="hl-attribute">class</span>=<span class="hl-value">&quot;org.springframework.transaction.support.TransactionTemplate&quot;</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;isolationLevelName&quot;</span> <span class="hl-attribute">value</span>=<span class="hl-value">&quot;ISOLATION_READ_UNCOMMITTED&quot;</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;timeout&quot;</span> <span class="hl-attribute">value</span>=<span class="hl-value">&quot;30&quot;</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>&quot;</pre> 
     <p>Finally, instances of the <code class="literal">TransactionTemplate</code> class are threadsafe, in that instances do not maintain any conversational state. <code class="literal">TransactionTemplate</code> instances <span class="emphasis"><em>do</em></span> however maintain configuration state, so while a number of classes may share a single instance of a <code class="literal">TransactionTemplate</code>, if a class needs to use a <code class="literal">TransactionTemplate</code> with different settings (for example, a different isolation level), then you need to create two distinct <code class="literal">TransactionTemplate</code> instances.</p> 
    </div> 
   </div> 
   <div class="section" title="11.6.2&nbsp;Using the PlatformTransactionManager">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="transaction-programmatic-ptm"></a>11.6.2&nbsp;Using the PlatformTransactionManager</h3>
      </div>
     </div>
    </div> 
    <p>You can also use the <code class="literal">org.springframework.transaction.PlatformTransactionManager</code> directly to manage your transaction. Simply pass the implementation of the <code class="literal">PlatformTransactionManager</code> you are using to your bean through a bean reference. Then, using the <code class="literal">TransactionDefinition</code> and <code class="literal">TransactionStatus</code> objects you can initiate transactions, roll back, and commit.</p> 
    <pre class="programlisting">DefaultTransactionDefinition def = <span class="hl-keyword">new</span> DefaultTransactionDefinition();
<span class="hl-comment">// explicitly setting the transaction name is something that can only be done programmatically</span>
def.setName(<span class="hl-string">&quot;SomeTxName&quot;</span>);
def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);

TransactionStatus status = txManager.getTransaction(def);
<span class="hl-keyword">try</span> {
    <span class="hl-comment">// execute your business logic here</span>
}
<span class="hl-keyword">catch</span> (MyException ex) {
    txManager.rollback(status);
    <span class="hl-keyword">throw</span> ex;
}
txManager.commit(status);</pre> 
   </div> 
  </div> 
  <div class="section" title="11.7&nbsp;Choosing between programmatic and declarative transaction management">
   <div class="titlepage">
    <div>
     <div>
      <h2 class="title" style="clear: both"><a name="tx-decl-vs-prog"></a>11.7&nbsp;Choosing between programmatic and declarative transaction management</h2>
     </div>
    </div>
   </div> 
   <p>Programmatic transaction management is usually a good idea only if you have a small number of transactional operations. For example, if you have a web application that require transactions only for certain update operations, you may not want to set up transactional proxies using Spring or any other technology. In this case, using the <code class="literal">TransactionTemplate</code> <span class="emphasis"><em>may</em></span> be a good approach. Being able to set the transaction name explicitly is also something that can only be done using the programmatic approach to transaction management.</p> 
   <p>On the other hand, if your application has numerous transactional operations, declarative transaction management is usually worthwhile. It keeps transaction management out of business logic, and is not difficult to configure. When using the Spring Framework, rather than EJB CMT, the configuration cost of declarative transaction management is greatly reduced.</p> 
  </div> 
  <div class="section" title="11.8&nbsp;Application server-specific integration">
   <div class="titlepage">
    <div>
     <div>
      <h2 class="title" style="clear: both"><a name="transaction-application-server-integration"></a>11.8&nbsp;Application server-specific integration</h2>
     </div>
    </div>
   </div> 
   <p>Springs transaction abstraction generally is application server agnostic. Additionally, Springs <code class="literal">JtaTransactionManager</code> class, which can optionally perform a JNDI lookup for the JTA <code class="literal">UserTransaction</code> and <code class="literal">TransactionManager</code> objects, autodetects the location for the latter object, which varies by application server. Having access to the JTA <code class="literal">TransactionManager</code> allows for enhanced transaction semantics, in particular supporting transaction suspension. See the <code class="literal">JtaTransactionManager</code> Javadocs for details.</p> 
   <p>Springs <code class="literal">JtaTransactionManager</code> is the standard choice to run on Java EE application servers, and is known to work on all common servers. Advanced functionality such as transaction suspension works on many servers as well&#x2009;&#x2009;including GlassFish, JBoss and Geronimo&#x2009;&#x2009;without any special configuration required. However, for fully supported transaction suspension and further advanced integration, Spring ships special adapters for WebLogic Server and WebSphere. These adapters are discussed in the following sections.</p> 
   <p><span class="emphasis"><em>For standard scenarios, including WebLogic Server and WebSphere, consider using the convenient <code class="literal">&lt;tx:jta-transaction-manager/&gt;</code> configuration element.</em></span> When configured, this element automatically detects the underlying server and chooses the best transaction manager available for the platform. This means that you wont have to configure server-specific adapter classes (as discussed in the following sections) explicitly; rather, they are chosen automatically, with the standard <code class="literal">JtaTransactionManager</code> as default fallback.</p> 
   <div class="section" title="11.8.1&nbsp;IBM WebSphere">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="transaction-application-server-integration-websphere"></a>11.8.1&nbsp;IBM WebSphere</h3>
      </div>
     </div>
    </div> 
    <p>On WebSphere 6.1.0.9 and above, the recommended Spring JTA transaction manager to use is <code class="literal">WebSphereUowTransactionManager</code>. This special adapter leverages IBMs <code class="literal">UOWManager</code> API, which is available in WebSphere Application Server 6.0.2.19 and later and 6.1.0.9 and later. With this adapter, Spring-driven transaction suspension (suspend/resume as initiated by <code class="literal">PROPAGATION_REQUIRES_NEW</code>) is officially supported by IBM!</p> 
   </div> 
   <div class="section" title="11.8.2&nbsp;Oracle WebLogic Server">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="transaction-application-server-integration-weblogic"></a>11.8.2&nbsp;Oracle WebLogic Server</h3>
      </div>
     </div>
    </div> 
    <p>On WebLogic Server 9.0 or above, you typically would use the <code class="literal">WebLogicJtaTransactionManager</code> instead of the stock <code class="literal">JtaTransactionManager</code> class. This special WebLogic-specific subclass of the normal <code class="literal">JtaTransactionManager</code> supports the full power of Springs transaction definitions in a WebLogic-managed transaction environment, beyond standard JTA semantics: Features include transaction names, per-transaction isolation levels, and proper resuming of transactions in all cases.</p> 
   </div> 
  </div> 
  <div class="section" title="11.9&nbsp;Solutions to common problems">
   <div class="titlepage">
    <div>
     <div>
      <h2 class="title" style="clear: both"><a name="transaction-solutions-to-common-problems"></a>11.9&nbsp;Solutions to common problems</h2>
     </div>
    </div>
   </div> 
   <div class="section" title="11.9.1&nbsp;Use of the wrong transaction manager for a specific DataSource">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="transaction-solutions-to-common-problems-wrong-ptm"></a>11.9.1&nbsp;Use of the wrong transaction manager for a specific DataSource</h3>
      </div>
     </div>
    </div> 
    <p>Use the <span class="emphasis"><em>correct</em></span> <code class="literal">PlatformTransactionManager</code> implementation based on your choice of transactional technologies and requirements. Used properly, the Spring Framework merely provides a straightforward and portable abstraction. If you are using global transactions, you <span class="emphasis"><em>must</em></span> use the <code class="literal">org.springframework.transaction.jta.JtaTransactionManager</code> class (or an <a class="link" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#transaction-application-server-integration" title="11.8&nbsp;Application server-specific integration">application server-specific subclass</a> of it) for all your transactional operations. Otherwise the transaction infrastructure attempts to perform local transactions on resources such as container <code class="literal">DataSource</code> instances. Such local transactions do not make sense, and a good application server treats them as errors.</p> 
   </div> 
  </div> 
  <div class="section" title="11.10&nbsp;Further Resources">
   <div class="titlepage">
    <div>
     <div>
      <h2 class="title" style="clear: both"><a name="transaction-resources"></a>11.10&nbsp;Further Resources</h2>
     </div>
    </div>
   </div> 
   <p>For more information about the Spring Frameworks transaction support:</p> 
   <div class="itemizedlist">
    <ul class="itemizedlist" type="disc">
     <li class="listitem"> <a class="ulink" href="http://www.javaworld.com/javaworld/jw-01-2009/jw-01-spring-transactions.html" target="_top">Distributed transactions in Spring, with and without XA</a> is a JavaWorld presentation in which SpringSources David Syer guides you through seven patterns for distributed transactions in Spring applications, three of them with XA and four without. </li>
     <li class="listitem"> <a class="ulink" href="http://www.infoq.com/minibooks/JTDS" target="_top">Java Transaction Design Strategies</a> is a book available from <a class="ulink" href="http://www.infoq.com/" target="_top">InfoQ</a> that provides a well-paced introduction to transactions in Java. It also includes side-by-side examples of how to configure and use transactions with both the Spring Framework and EJB3. </li>
    </ul>
   </div> 
  </div> 
 </div> 
 <div class="chapter" title="12.&nbsp;DAO support">
  <div class="titlepage">
   <div>
    <div>
     <h2 class="title"><a name="dao"></a>12.&nbsp;DAO support</h2>
    </div>
   </div>
  </div> 
  <div class="section" title="12.1&nbsp;Introduction">
   <div class="titlepage">
    <div>
     <div>
      <h2 class="title" style="clear: both"><a name="dao-introduction"></a>12.1&nbsp;Introduction</h2>
     </div>
    </div>
   </div> 
   <p>The Data Access Object (DAO) support in Spring is aimed at making it easy to work with data access technologies like JDBC, Hibernate, JPA or JDO in a consistent way. This allows one to switch between the aforementioned persistence technologies fairly easily and it also allows one to code without worrying about catching exceptions that are specific to each technology.</p> 
  </div> 
  <div class="section" title="12.2&nbsp;Consistent exception hierarchy">
   <div class="titlepage">
    <div>
     <div>
      <h2 class="title" style="clear: both"><a name="dao-exceptions"></a>12.2&nbsp;Consistent exception hierarchy</h2>
     </div>
    </div>
   </div> 
   <p>Spring provides a convenient translation from technology-specific exceptions like <code class="literal">SQLException</code> to its own exception class hierarchy with the <code class="literal">DataAccessException</code> as the root exception. These exceptions wrap the original exception so there is never any risk that one might lose any information as to what might have gone wrong.</p> 
   <p>In addition to JDBC exceptions, Spring can also wrap Hibernate-specific exceptions, converting them from proprietary, checked exceptions (in the case of versions of Hibernate prior to Hibernate 3.0), to a set of focused runtime exceptions (the same is true for JDO and JPA exceptions). This allows one to handle most persistence exceptions, which are non-recoverable, only in the appropriate layers, without having annoying boilerplate catch-and-throw blocks and exception declarations in ones DAOs. (One can still trap and handle exceptions anywhere one needs to though.) As mentioned above, JDBC exceptions (including database-specific dialects) are also converted to the same hierarchy, meaning that one can perform some operations with JDBC within a consistent programming model.</p> 
   <p>The above holds true for the various template classes in Springs support for various ORM frameworks. If one uses the interceptor-based classes then the application must care about handling <code class="literal">HibernateExceptions</code> and <code class="literal">JDOExceptions</code> itself, preferably via delegating to <code class="literal">SessionFactoryUtils</code>' <code class="literal">convertHibernateAccessException(..)</code> or <code class="literal">convertJdoAccessException()</code> methods respectively. These methods convert the exceptions to ones that are compatible with the exceptions in the <code class="literal">org.springframework.dao</code> exception hierarchy. As <code class="literal">JDOExceptions</code> are unchecked, they can simply get thrown too, sacrificing generic DAO abstraction in terms of exceptions though.</p> 
   <p>The exception hierarchy that Spring provides can be seen below. (Please note that the class hierarchy detailed in the image shows only a subset of the entire <code class="literal">DataAccessException</code> hierarchy.)</p> 
   <div class="figure">
    <a name="d4e10572"></a>
    <p class="title"><b>Figure&nbsp;12.1.&nbsp;</b></p>
    <div class="figure-contents"> 
     <div class="mediaobject">
      <img src="./Spring Framework Reference Documentation_files/DataAccessException.gif" alt="DataAccessException" />
     </div> 
    </div>
   </div>
   <br class="figure-break" /> 
  </div> 
  <div class="section" title="12.3&nbsp;Annotations used for configuring DAO or Repository classes">
   <div class="titlepage">
    <div>
     <div>
      <h2 class="title" style="clear: both"><a name="dao-annotations"></a>12.3&nbsp;Annotations used for configuring DAO or Repository classes</h2>
     </div>
    </div>
   </div> 
   <p>The best way to guarantee that your Data Access Objects (DAOs) or repositories provide exception translation is to use the <code class="literal">@Repository</code> annotation. This annotation also allows the component scanning support to find and configure your DAOs and repositories without having to provide XML configuration entries for them.</p> 
   <pre class="programlisting"><span class="strong"><strong>@Repository</strong></span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> SomeMovieFinder <span class="hl-keyword">implements</span> MovieFinder {
    <span class="hl-comment">// ...</span>
}</pre> 
   <p>Any DAO or repository implementation will need to access to a persistence resource, depending on the persistence technology used; for example, a JDBC-based repository will need access to a JDBC <code class="literal">DataSource</code>; a JPA-based repository will need access to an <code class="literal">EntityManager</code>. The easiest way to accomplish this is to have this resource dependency injected using one of the <code class="literal">@Autowired,</code>, <code class="literal">@Inject</code>, <code class="literal">@Resource</code> or <code class="literal">@PersistenceContext</code> annotations. Here is an example for a JPA repository:</p> 
   <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@Repository</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> JpaMovieFinder <span class="hl-keyword">implements</span> MovieFinder {

    <i><span class="hl-annotation" style="color: gray">@PersistenceContext</span></i>
    <span class="hl-keyword">private</span> EntityManager entityManager;

    <span class="hl-comment">// ...</span>

}</pre> 
   <p>If you are using the classic Hibernate APIs than you can inject the SessionFactory:</p> 
   <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@Repository</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> HibernateMovieFinder <span class="hl-keyword">implements</span> MovieFinder {

    <span class="hl-keyword">private</span> SessionFactory sessionFactory;

    <i><span class="hl-annotation" style="color: gray">@Autowired</span></i>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setSessionFactory(SessionFactory sessionFactory) {
        <span class="hl-keyword">this</span>.sessionFactory = sessionFactory;
    }

    <span class="hl-comment">// ...</span>

}</pre> 
   <p>Last example we will show here is for typical JDBC support. You would have the <code class="literal">DataSource</code> injected into an initialization method where you would create a <code class="literal">JdbcTemplate</code> and other data access support classes like <code class="literal">SimpleJdbcCall</code> etc using this <code class="literal">DataSource</code>.</p> 
   <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@Repository</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> JdbcMovieFinder <span class="hl-keyword">implements</span> MovieFinder {

    <span class="hl-keyword">private</span> JdbcTemplate jdbcTemplate;

    <i><span class="hl-annotation" style="color: gray">@Autowired</span></i>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> init(DataSource dataSource) {
        <span class="hl-keyword">this</span>.jdbcTemplate = <span class="hl-keyword">new</span> JdbcTemplate(dataSource);
    }

    <span class="hl-comment">// ...</span>

}</pre> 
   <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;">
    <table border="0" summary="Note">
     <tbody>
      <tr>
       <td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Framework Reference Documentation_files/note.png" /></td>
       <th align="left">Note</th>
      </tr>
      <tr>
       <td align="left" valign="top"> <p>Please see the specific coverage of each persistence technology for details on how to configure the application context to take advantage of these annotations.</p> </td>
      </tr>
     </tbody>
    </table>
   </div> 
  </div> 
 </div> 
 <div class="chapter" title="13.&nbsp;Data access with JDBC">
  <div class="titlepage">
   <div>
    <div>
     <h2 class="title"><a name="jdbc"></a>13.&nbsp;Data access with JDBC</h2>
    </div>
   </div>
  </div> 
  <div class="section" title="13.1&nbsp;Introduction to Spring Framework JDBC">
   <div class="titlepage">
    <div>
     <div>
      <h2 class="title" style="clear: both"><a name="jdbc-introduction"></a>13.1&nbsp;Introduction to Spring Framework JDBC</h2>
     </div>
    </div>
   </div> 
   <p>The value-add provided by the Spring Framework JDBC abstraction is perhaps best shown by the sequence of actions outlined in the table below. The table shows what actions Spring will take care of and which actions are the responsibility of you, the application developer.</p> 
   <div class="table">
    <a name="jdbc-who-does-what"></a>
    <p class="title"><b>Table&nbsp;13.1.&nbsp;Spring JDBC - who does what?</b></p>
    <div class="table-contents"> 
     <table summary="Spring JDBC - who does what?" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; ">
      <colgroup>
       <col />
       <col />
       <col />
      </colgroup>
      <thead>
       <tr>
        <th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">Action</th>
        <th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">Spring</th>
        <th style="border-bottom: 0.5pt solid ; " align="left" valign="top">You</th>
       </tr>
      </thead>
      <tbody>
       <tr>
        <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Define connection parameters.</p></td>
        <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">&nbsp;</td>
        <td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>X</p></td>
       </tr>
       <tr>
        <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Open the connection.</p></td>
        <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>X</p></td>
        <td style="border-bottom: 0.5pt solid ; " align="left" valign="top">&nbsp;</td>
       </tr>
       <tr>
        <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Specify the SQL statement.</p></td>
        <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">&nbsp;</td>
        <td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>X</p></td>
       </tr>
       <tr>
        <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Declare parameters and provide parameter values</p></td>
        <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">&nbsp;</td>
        <td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>X</p></td>
       </tr>
       <tr>
        <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Prepare and execute the statement.</p></td>
        <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>X</p></td>
        <td style="border-bottom: 0.5pt solid ; " align="left" valign="top">&nbsp;</td>
       </tr>
       <tr>
        <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Set up the loop to iterate through the results (if any).</p></td>
        <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>X</p></td>
        <td style="border-bottom: 0.5pt solid ; " align="left" valign="top">&nbsp;</td>
       </tr>
       <tr>
        <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Do the work for each iteration.</p></td>
        <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">&nbsp;</td>
        <td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>X</p></td>
       </tr>
       <tr>
        <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Process any exception.</p></td>
        <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>X</p></td>
        <td style="border-bottom: 0.5pt solid ; " align="left" valign="top">&nbsp;</td>
       </tr>
       <tr>
        <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>Handle transactions.</p></td>
        <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>X</p></td>
        <td style="border-bottom: 0.5pt solid ; " align="left" valign="top">&nbsp;</td>
       </tr>
       <tr>
        <td style="border-right: 0.5pt solid ; " align="left" valign="top"><p>Close the connection, statement and resultset.</p></td>
        <td style="border-right: 0.5pt solid ; " align="left" valign="top"><p>X</p></td>
        <td style="" align="left" valign="top">&nbsp;</td>
       </tr>
      </tbody>
     </table> 
    </div>
   </div>
   <br class="table-break" /> 
   <p>The Spring Framework takes care of all the low-level details that can make JDBC such a tedious API to develop with.</p> 
   <div class="section" title="13.1.1&nbsp;Choosing an approach for JDBC database access">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="jdbc-choose-style"></a>13.1.1&nbsp;Choosing an approach for JDBC database access</h3>
      </div>
     </div>
    </div> 
    <p>You can choose among several approaches to form the basis for your JDBC database access. In addition to three flavors of the JdbcTemplate, a new SimpleJdbcInsert and SimplejdbcCall approach optimizes database metadata, and the RDBMS Object style takes a more object-oriented approach similar to that of JDO Query design. Once you start using one of these approaches, you can still mix and match to include a feature from a different approach. All approaches require a JDBC 2.0-compliant driver, and some advanced features require a JDBC 3.0 driver.</p> 
    <div class="itemizedlist">
     <ul class="itemizedlist" type="disc">
      <li class="listitem"> <span class="emphasis"><em>JdbcTemplate</em></span> is the classic Spring JDBC approach and the most popular. This &quot;lowest level&quot; approach and all others use a JdbcTemplate under the covers. </li>
      <li class="listitem"> <span class="emphasis"><em>NamedParameterJdbcTemplate</em></span> wraps a <code class="literal">JdbcTemplate</code> to provide named parameters instead of the traditional JDBC &quot;?&quot; placeholders. This approach provides better documentation and ease of use when you have multiple parameters for an SQL statement. </li>
      <li class="listitem"> <span class="emphasis"><em>SimpleJdbcInsert and SimpleJdbcCall</em></span> optimize database metadata to limit the amount of necessary configuration. This approach simplifies coding so that you only need to provide the name of the table or procedure and provide a map of parameters matching the column names. This only works if the database provides adequate metadata. If the database doesnt provide this metadata, you will have to provide explicit configuration of the parameters. </li>
      <li class="listitem"> <span class="emphasis"><em>RDBMS Objects including MappingSqlQuery, SqlUpdate and StoredProcedure</em></span> requires you to create reusable and thread-safe objects during initialization of your data access layer. This approach is modeled after JDO Query wherein you define your query string, declare parameters, and compile the query. Once you do that, execute methods can be called multiple times with various parameter values passed in. </li>
     </ul>
    </div> 
   </div> 
   <div class="section" title="13.1.2&nbsp;Package hierarchy">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="jdbc-packages"></a>13.1.2&nbsp;Package hierarchy</h3>
      </div>
     </div>
    </div> 
    <p>The Spring Frameworks JDBC abstraction framework consists of four different packages, namely <code class="literal">core</code>, <code class="literal">datasource</code>, <code class="literal">object</code>, and <code class="literal">support</code>.</p> 
    <p>The <code class="literal">org.springframework.jdbc.core</code> package contains the <code class="literal">JdbcTemplate</code> class and its various callback interfaces, plus a variety of related classes. A subpackage named <code class="literal">org.springframework.jdbc.core.simple</code> contains the <code class="literal">SimpleJdbcInsert</code> and <code class="literal">SimpleJdbcCall</code> classes. Another subpackage named <code class="literal">org.springframework.jdbc.core.namedparam</code> contains the <code class="literal">NamedParameterJdbcTemplate</code> class and the related support classes. See <a class="xref" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#jdbc-core" title="13.2&nbsp;Using the JDBC core classes to control basic JDBC processing and error handling">Section&nbsp;13.2, Using the JDBC core classes to control basic JDBC processing and error handling</a>, <a class="xref" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#jdbc-advanced-jdbc" title="13.4&nbsp;JDBC batch operations">Section&nbsp;13.4, JDBC batch operations</a>, and <a class="xref" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#jdbc-simple-jdbc" title="13.5&nbsp;Simplifying JDBC operations with the SimpleJdbc classes">Section&nbsp;13.5, Simplifying JDBC operations with the SimpleJdbc classes</a></p> 
    <p>The <code class="literal">org.springframework.jdbc.datasource</code> package contains a utility class for easy <code class="literal">DataSource</code> access, and various simple <code class="literal">DataSource</code> implementations that can be used for testing and running unmodified JDBC code outside of a Java EE container. A subpackage named <code class="literal">org.springfamework.jdbc.datasource.embedded</code> provides support for creating in-memory database instances using Java database engines such as HSQL and H2. See <a class="xref" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#jdbc-connections" title="13.3&nbsp;Controlling database connections">Section&nbsp;13.3, Controlling database connections</a> and <a class="xref" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#jdbc-embedded-database-support" title="13.8&nbsp;Embedded database support">Section&nbsp;13.8, Embedded database support</a></p> 
    <p>The <code class="literal">org.springframework.jdbc.object</code> package contains classes that represent RDBMS queries, updates, and stored procedures as thread safe, reusable objects. See <a class="xref" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#jdbc-object" title="13.6&nbsp;Modeling JDBC operations as Java objects">Section&nbsp;13.6, Modeling JDBC operations as Java objects</a>.This approach is modeled by JDO, although of course objects returned by queries are &quot;disconnected&quot; from the database. This higher level of JDBC abstraction depends on the lower-level abstraction in the <code class="literal">org.springframework.jdbc.core</code> package.</p> 
    <p>The <code class="literal">org.springframework.jdbc.support</code> package provides <code class="literal">SQLException</code> translation functionality and some utility classes. Exceptions thrown during JDBC processing are translated to exceptions defined in the <code class="literal">org.springframework.dao</code> package. This means that code using the Spring JDBC abstraction layer does not need to implement JDBC or RDBMS-specific error handling. All translated exceptions are unchecked, which gives you the option of catching the exceptions from which you can recover while allowing other exceptions to be propagated to the caller. See <a class="xref" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#jdbc-SQLExceptionTranslator" title="13.2.3&nbsp;SQLExceptionTranslator">Section&nbsp;13.2.3, SQLExceptionTranslator</a>.</p> 
   </div> 
  </div> 
  <div class="section" title="13.2&nbsp;Using the JDBC core classes to control basic JDBC processing and error handling">
   <div class="titlepage">
    <div>
     <div>
      <h2 class="title" style="clear: both"><a name="jdbc-core"></a>13.2&nbsp;Using the JDBC core classes to control basic JDBC processing and error handling</h2>
     </div>
    </div>
   </div> 
   <div class="section" title="13.2.1&nbsp;JdbcTemplate">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="jdbc-JdbcTemplate"></a>13.2.1&nbsp;JdbcTemplate</h3>
      </div>
     </div>
    </div> 
    <p>The <code class="literal">JdbcTemplate</code> class is the central class in the JDBC core package. It handles the creation and release of resources, which helps you avoid common errors such as forgetting to close the connection. It performs the basic tasks of the core JDBC workflow such as statement creation and execution, leaving application code to provide SQL and extract results. The <code class="literal">JdbcTemplate</code> class executes SQL queries, update statements and stored procedure calls, performs iteration over <code class="literal">ResultSet</code> s and extraction of returned parameter values. It also catches JDBC exceptions and translates them to the generic, more informative, exception hierarchy defined in the <code class="literal">org.springframework.dao</code> package.</p> 
    <p>When you use the <code class="literal">JdbcTemplate</code> for your code, you only need to implement callback interfaces, giving them a clearly defined contract. The <code class="literal">PreparedStatementCreator</code> callback interface creates a prepared statement given a <code class="literal">Connection</code> provided by this class, providing SQL and any necessary parameters. The same is true for the <code class="literal">CallableStatementCreator</code> interface, which creates callable statements. The <code class="literal">RowCallbackHandler</code> interface extracts values from each row of a <code class="literal">ResultSet</code>.</p> 
    <p>The <code class="literal">JdbcTemplate</code> can be used within a DAO implementation through direct instantiation with a <code class="literal">DataSource</code> reference, or be configured in a Spring IoC container and given to DAOs as a bean reference.</p> 
    <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;">
     <table border="0" summary="Note">
      <tbody>
       <tr>
        <td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Framework Reference Documentation_files/note.png" /></td>
        <th align="left">Note</th>
       </tr>
       <tr>
        <td align="left" valign="top"> <p>The <code class="literal">DataSource</code> should always be configured as a bean in the Spring IoC container. In the first case the bean is given to the service directly; in the second case it is given to the prepared template.</p> </td>
       </tr>
      </tbody>
     </table>
    </div> 
    <p>All SQL issued by this class is logged at the <code class="literal">DEBUG</code> level under the category corresponding to the fully qualified class name of the template instance (typically <code class="literal">JdbcTemplate</code>, but it may be different if you are using a custom subclass of the <code class="literal">JdbcTemplate</code> class).</p> 
    <div class="section" title="Examples of JdbcTemplate class usage">
     <div class="titlepage">
      <div>
       <div>
        <h4 class="title"><a name="jdbc-JdbcTemplate-examples"></a>Examples of JdbcTemplate class usage</h4>
       </div>
      </div>
     </div> 
     <p>This section provides some examples of <code class="literal">JdbcTemplate</code> class usage. These examples are not an exhaustive list of all of the functionality exposed by the <code class="literal">JdbcTemplate</code>; see the attendant Javadocs for that.</p> 
     <div class="section" title="Querying (SELECT)">
      <div class="titlepage">
       <div>
        <div>
         <h5 class="title"><a name="jdbc-JdbcTemplate-examples-query"></a>Querying (SELECT)</h5>
        </div>
       </div>
      </div> 
      <p>Here is a simple query for getting the number of rows in a relation:</p> 
      <pre class="programlisting"><span class="hl-keyword">int</span> rowCount = <span class="hl-keyword">this</span>.jdbcTemplate.queryForObject(<span class="hl-string">&quot;select count(*) from t_actor&quot;</span>, Integer.<span class="hl-keyword">class</span>);</pre> 
      <p>A simple query using a bind variable:</p> 
      <pre class="programlisting"><span class="hl-keyword">int</span> countOfActorsNamedJoe = <span class="hl-keyword">this</span>.jdbcTemplate.queryForObject(
        <span class="hl-string">&quot;select count(*) from t_actor where first_name = ?&quot;</span>, Integer.<span class="hl-keyword">class</span>, <span class="hl-string">&quot;Joe&quot;</span>);</pre> 
      <p>Querying for a <code class="literal">String</code>:</p> 
      <pre class="programlisting">String lastName = <span class="hl-keyword">this</span>.jdbcTemplate.queryForObject(
        <span class="hl-string">&quot;select last_name from t_actor where id = ?&quot;</span>,
        <span class="hl-keyword">new</span> Object[]{<span class="hl-number">1212L</span>}, String.<span class="hl-keyword">class</span>);</pre> 
      <p>Querying and populating a <span class="emphasis"><em>single</em></span> domain object:</p> 
      <pre class="programlisting">Actor actor = <span class="hl-keyword">this</span>.jdbcTemplate.queryForObject(
        <span class="hl-string">&quot;select first_name, last_name from t_actor where id = ?&quot;</span>,
        <span class="hl-keyword">new</span> Object[]{<span class="hl-number">1212L</span>},
        <span class="hl-keyword">new</span> RowMapper&lt;Actor&gt;() {
            <span class="hl-keyword">public</span> Actor mapRow(ResultSet rs, <span class="hl-keyword">int</span> rowNum) <span class="hl-keyword">throws</span> SQLException {
                Actor actor = <span class="hl-keyword">new</span> Actor();
                actor.setFirstName(rs.getString(<span class="hl-string">&quot;first_name&quot;</span>));
                actor.setLastName(rs.getString(<span class="hl-string">&quot;last_name&quot;</span>));
                <span class="hl-keyword">return</span> actor;
            }
        });</pre> 
      <p>Querying and populating a number of domain objects:</p> 
      <pre class="programlisting">List&lt;Actor&gt; actors = <span class="hl-keyword">this</span>.jdbcTemplate.query(
        <span class="hl-string">&quot;select first_name, last_name from t_actor&quot;</span>,
        <span class="hl-keyword">new</span> RowMapper&lt;Actor&gt;() {
            <span class="hl-keyword">public</span> Actor mapRow(ResultSet rs, <span class="hl-keyword">int</span> rowNum) <span class="hl-keyword">throws</span> SQLException {
                Actor actor = <span class="hl-keyword">new</span> Actor();
                actor.setFirstName(rs.getString(<span class="hl-string">&quot;first_name&quot;</span>));
                actor.setLastName(rs.getString(<span class="hl-string">&quot;last_name&quot;</span>));
                <span class="hl-keyword">return</span> actor;
            }
        });</pre> 
      <p>If the last two snippets of code actually existed in the same application, it would make sense to remove the duplication present in the two <code class="literal">RowMapper</code> anonymous inner classes, and extract them out into a single class (typically a <code class="literal">static</code> inner class) that can then be referenced by DAO methods as needed. For example, it may be better to write the last code snippet as follows:</p> 
      <pre class="programlisting"><span class="hl-keyword">public</span> List&lt;Actor&gt; findAllActors() {
    <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>.jdbcTemplate.query( <span class="hl-string">&quot;select first_name, last_name from t_actor&quot;</span>, <span class="hl-keyword">new</span> ActorMapper());
}

<span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> <span class="hl-keyword">class</span> ActorMapper <span class="hl-keyword">implements</span> RowMapper&lt;Actor&gt; {

    <span class="hl-keyword">public</span> Actor mapRow(ResultSet rs, <span class="hl-keyword">int</span> rowNum) <span class="hl-keyword">throws</span> SQLException {
        Actor actor = <span class="hl-keyword">new</span> Actor();
        actor.setFirstName(rs.getString(<span class="hl-string">&quot;first_name&quot;</span>));
        actor.setLastName(rs.getString(<span class="hl-string">&quot;last_name&quot;</span>));
        <span class="hl-keyword">return</span> actor;
    }
}</pre> 
     </div> 
     <div class="section" title="Updating (INSERT/UPDATE/DELETE) with jdbcTemplate">
      <div class="titlepage">
       <div>
        <div>
         <h5 class="title"><a name="jdbc-JdbcTemplate-examples-update"></a>Updating (INSERT/UPDATE/DELETE) with jdbcTemplate</h5>
        </div>
       </div>
      </div> 
      <p>You use the <code class="literal">update(..)</code> method to perform insert, update and delete operations. Parameter values are usually provided as var args or alternatively as an object array.</p> 
      <pre class="programlisting"><span class="hl-keyword">this</span>.jdbcTemplate.update(
        <span class="hl-string">&quot;insert into t_actor (first_name, last_name) values (?, ?)&quot;</span>,
        <span class="hl-string">&quot;Leonor&quot;</span>, <span class="hl-string">&quot;Watling&quot;</span>);</pre> 
      <pre class="programlisting"><span class="hl-keyword">this</span>.jdbcTemplate.update(
        <span class="hl-string">&quot;update t_actor set last_name = ? where id = ?&quot;</span>,
        <span class="hl-string">&quot;Banjo&quot;</span>, <span class="hl-number">5276L</span>);</pre> 
      <pre class="programlisting"><span class="hl-keyword">this</span>.jdbcTemplate.update(
        <span class="hl-string">&quot;delete from actor where id = ?&quot;</span>,
        Long.valueOf(actorId));</pre> 
     </div> 
     <div class="section" title="Other jdbcTemplate operations">
      <div class="titlepage">
       <div>
        <div>
         <h5 class="title"><a name="jdbc-JdbcTemplate-examples-other"></a>Other jdbcTemplate operations</h5>
        </div>
       </div>
      </div> 
      <p>You can use the <code class="literal">execute(..)</code> method to execute any arbitrary SQL, and as such the method is often used for DDL statements. It is heavily overloaded with variants taking callback interfaces, binding variable arrays, and so on.</p> 
      <pre class="programlisting"><span class="hl-keyword">this</span>.jdbcTemplate.execute(<span class="hl-string">&quot;create table mytable (id integer, name varchar(100))&quot;</span>);</pre> 
      <p>The following example invokes a simple stored procedure. More sophisticated stored procedure support is <a class="link" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#jdbc-StoredProcedure" title="13.6.4&nbsp;StoredProcedure">covered later</a>.</p> 
      <pre class="programlisting"><span class="hl-keyword">this</span>.jdbcTemplate.update(
        <span class="hl-string">&quot;call SUPPORT.REFRESH_ACTORS_SUMMARY(?)&quot;</span>,
        Long.valueOf(unionId));</pre> 
     </div> 
    </div> 
    <div class="section" title="JdbcTemplate best practices">
     <div class="titlepage">
      <div>
       <div>
        <h4 class="title"><a name="jdbc-JdbcTemplate-idioms"></a>JdbcTemplate best practices</h4>
       </div>
      </div>
     </div> 
     <p>Instances of the <code class="literal">JdbcTemplate</code> class are <span class="emphasis"><em>threadsafe once configured</em></span>. This is important because it means that you can configure a single instance of a <code class="literal">JdbcTemplate</code> and then safely inject this <span class="emphasis"><em>shared</em></span> reference into multiple DAOs (or repositories). The <code class="literal">JdbcTemplate</code> is stateful, in that it maintains a reference to a <code class="literal">DataSource</code>, but this state is <span class="emphasis"><em>not</em></span> conversational state.</p> 
     <p>A common practice when using the <code class="literal">JdbcTemplate</code> class (and the associated <a class="link" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#jdbc-NamedParameterJdbcTemplate" title="13.2.2&nbsp;NamedParameterJdbcTemplate"><code class="literal">NamedParameterJdbcTemplate</code></a> classes) is to configure a <code class="literal">DataSource</code> in your Spring configuration file, and then dependency-inject that shared <code class="literal">DataSource</code> bean into your DAO classes; the <code class="literal">JdbcTemplate</code> is created in the setter for the <code class="literal">DataSource</code>. This leads to DAOs that look in part like the following:</p> 
     <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> JdbcCorporateEventDao <span class="hl-keyword">implements</span> CorporateEventDao {

    <span class="hl-keyword">private</span> JdbcTemplate jdbcTemplate;

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setDataSource(DataSource dataSource) {
        <span class="strong"><strong>this.jdbcTemplate = new JdbcTemplate(dataSource);</strong></span>
    }

    <span class="hl-comment">// JDBC-backed implementations of the methods on the CorporateEventDao follow...</span>
}</pre> 
     <p>The corresponding configuration might look like this.</p> 
     <pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">&quot;http://www.springframework.org/schema/beans&quot;</span>
    <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>
    <span class="hl-attribute">xmlns:context</span>=<span class="hl-value">&quot;http://www.springframework.org/schema/context&quot;</span>
    <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">&quot;
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span><span class="hl-tag">&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;corporateEventDao&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;com.example.JdbcCorporateEventDao&quot;</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;dataSource&quot;</span> <span class="hl-attribute">ref</span>=<span class="hl-value">&quot;dataSource&quot;</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;dataSource&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span> <span class="hl-attribute">destroy-method</span>=<span class="hl-value">&quot;close&quot;</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;driverClassName&quot;</span> <span class="hl-attribute">value</span>=<span class="hl-value">&quot;${jdbc.driverClassName}&quot;</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;url&quot;</span> <span class="hl-attribute">value</span>=<span class="hl-value">&quot;${jdbc.url}&quot;</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;username&quot;</span> <span class="hl-attribute">value</span>=<span class="hl-value">&quot;${jdbc.username}&quot;</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;password&quot;</span> <span class="hl-attribute">value</span>=<span class="hl-value">&quot;${jdbc.password}&quot;</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

    <span class="hl-tag">&lt;context:property-placeholder</span> <span class="hl-attribute">location</span>=<span class="hl-value">&quot;jdbc.properties&quot;</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre> 
     <p>An alternative to explicit configuration is to use component-scanning and annotation support for dependency injection. In this case you annotate the class with <code class="literal">@Repository</code> (which makes it a candidate for component-scanning) and annotate the <code class="literal">DataSource</code> setter method with <code class="literal">@Autowired</code>.</p> 
     <pre class="programlisting"><span class="strong"><strong>@Repository</strong></span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> JdbcCorporateEventDao <span class="hl-keyword">implements</span> CorporateEventDao {

    <span class="hl-keyword">private</span> JdbcTemplate jdbcTemplate;

    <span class="strong"><strong>@Autowired</strong></span>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setDataSource(DataSource dataSource) {
        <span class="strong"><strong>this.jdbcTemplate = new JdbcTemplate(dataSource);</strong></span>
    }

    <span class="hl-comment">// JDBC-backed implementations of the methods on the CorporateEventDao follow...</span>
}</pre> 
     <p>The corresponding XML configuration file would look like the following:</p> 
     <pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">&quot;http://www.springframework.org/schema/beans&quot;</span>
    <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>
    <span class="hl-attribute">xmlns:context</span>=<span class="hl-value">&quot;http://www.springframework.org/schema/context&quot;</span>
    <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">&quot;
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span><span class="hl-tag">&gt;</span>

    <span class="hl-comment">&lt;!-- Scans within the base package of the application for @Components to configure as beans --&gt;</span>
    <span class="hl-tag">&lt;context:component-scan</span> <span class="hl-attribute">base-package</span>=<span class="hl-value">&quot;org.springframework.docs.test&quot;</span><span class="hl-tag"> /&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;dataSource&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span> <span class="hl-attribute">destroy-method</span>=<span class="hl-value">&quot;close&quot;</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;driverClassName&quot;</span> <span class="hl-attribute">value</span>=<span class="hl-value">&quot;${jdbc.driverClassName}&quot;</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;url&quot;</span> <span class="hl-attribute">value</span>=<span class="hl-value">&quot;${jdbc.url}&quot;</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;username&quot;</span> <span class="hl-attribute">value</span>=<span class="hl-value">&quot;${jdbc.username}&quot;</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;password&quot;</span> <span class="hl-attribute">value</span>=<span class="hl-value">&quot;${jdbc.password}&quot;</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

    <span class="hl-tag">&lt;context:property-placeholder</span> <span class="hl-attribute">location</span>=<span class="hl-value">&quot;jdbc.properties&quot;</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre> 
     <p>If you are using Springs <code class="literal">JdbcDaoSupport</code> class, and your various JDBC-backed DAO classes extend from it, then your sub-class inherits a <code class="literal">setDataSource(..)</code> method from the <code class="literal">JdbcDaoSupport</code> class. You can choose whether to inherit from this class. The <code class="literal">JdbcDaoSupport</code> class is provided as a convenience only.</p> 
     <p>Regardless of which of the above template initialization styles you choose to use (or not), it is seldom necessary to create a new instance of a <code class="literal">JdbcTemplate</code> class each time you want to execute SQL. Once configured, a <code class="literal">JdbcTemplate</code> instance is threadsafe. You may want multiple <code class="literal">JdbcTemplate</code> instances if your application accesses multiple databases, which requires multiple <code class="literal">DataSources</code>, and subsequently multiple differently configured <code class="literal">JdbcTemplates</code>.</p> 
    </div> 
   </div> 
   <div class="section" title="13.2.2&nbsp;NamedParameterJdbcTemplate">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="jdbc-NamedParameterJdbcTemplate"></a>13.2.2&nbsp;NamedParameterJdbcTemplate</h3>
      </div>
     </div>
    </div> 
    <p>The <code class="literal">NamedParameterJdbcTemplate</code> class adds support for programming JDBC statements using named parameters, as opposed to programming JDBC statements using only classic placeholder ( <code class="literal">'?'</code>) arguments. The <code class="literal">NamedParameterJdbcTemplate</code> class wraps a <code class="literal">JdbcTemplate</code>, and delegates to the wrapped <code class="literal">JdbcTemplate</code> to do much of its work. This section describes only those areas of the <code class="literal">NamedParameterJdbcTemplate</code> class that differ from the <code class="literal">JdbcTemplate</code> itself; namely, programming JDBC statements using named parameters.</p> 
    <pre class="programlisting"><span class="hl-comment">// some JDBC-backed DAO class...</span>
<span class="hl-keyword">private</span> NamedParameterJdbcTemplate namedParameterJdbcTemplate;

<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setDataSource(DataSource dataSource) {
    <span class="hl-keyword">this</span>.namedParameterJdbcTemplate = <span class="hl-keyword">new</span> NamedParameterJdbcTemplate(dataSource);
}

<span class="hl-keyword">public</span> <span class="hl-keyword">int</span> countOfActorsByFirstName(String firstName) {

    String sql = <span class="hl-string">&quot;select count(*) from T_ACTOR where first_name = :first_name&quot;</span>;

    SqlParameterSource namedParameters = <span class="hl-keyword">new</span> MapSqlParameterSource(<span class="hl-string">&quot;first_name&quot;</span>, firstName);

    <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>.namedParameterJdbcTemplate.queryForObject(sql, Integer.<span class="hl-keyword">class</span>, namedParameters);
}</pre> 
    <p>Notice the use of the named parameter notation in the value assigned to the <code class="literal">sql</code> variable, and the corresponding value that is plugged into the <code class="literal">namedParameters</code> variable (of type <code class="literal">MapSqlParameterSource</code>).</p> 
    <p>Alternatively, you can pass along named parameters and their corresponding values to a <code class="literal">NamedParameterJdbcTemplate</code> instance by using the <code class="literal">Map</code>-based style.The remaining methods exposed by the <code class="literal">NamedParameterJdbcOperations</code> and implemented by the <code class="literal">NamedParameterJdbcTemplate</code> class follow a similar pattern and are not covered here.</p> 
    <p>The following example shows the use of the <code class="literal">Map</code>-based style.</p> 
    <pre class="programlisting"><span class="hl-comment">// some JDBC-backed DAO class...</span>
<span class="hl-keyword">private</span> NamedParameterJdbcTemplate namedParameterJdbcTemplate;

<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setDataSource(DataSource dataSource) {
    <span class="hl-keyword">this</span>.namedParameterJdbcTemplate = <span class="hl-keyword">new</span> NamedParameterJdbcTemplate(dataSource);
}

<span class="hl-keyword">public</span> <span class="hl-keyword">int</span> countOfActorsByFirstName(String firstName) {

    String sql = <span class="hl-string">&quot;select count(*) from T_ACTOR where first_name = :first_name&quot;</span>;

    Map&lt;String, String&gt; namedParameters = Collections.singletonMap(<span class="hl-string">&quot;first_name&quot;</span>, firstName);

    <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>.namedParameterJdbcTemplate.queryForObject(sql, Integer.<span class="hl-keyword">class</span>, namedParameters);
}</pre> 
    <p>One nice feature related to the <code class="literal">NamedParameterJdbcTemplate</code> (and existing in the same Java package) is the <code class="literal">SqlParameterSource</code> interface. You have already seen an example of an implementation of this interface in one of the previous code snippet (the <code class="literal">MapSqlParameterSource</code> class). An <code class="literal">SqlParameterSource</code> is a source of named parameter values to a <code class="literal">NamedParameterJdbcTemplate</code>. The <code class="literal">MapSqlParameterSource</code> class is a very simple implementation that is simply an adapter around a <code class="literal">java.util.Map</code>, where the keys are the parameter names and the values are the parameter values.</p> 
    <p>Another <code class="literal">SqlParameterSource</code> implementation is the <code class="literal">BeanPropertySqlParameterSource</code> class. This class wraps an arbitrary JavaBean (that is, an instance of a class that adheres to <a class="ulink" href="http://www.oracle.com/technetwork/java/javase/documentation/spec-136004.html" target="_top">the JavaBean conventions</a>), and uses the properties of the wrapped JavaBean as the source of named parameter values.</p> 
    <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Actor {

    <span class="hl-keyword">private</span> Long id;
    <span class="hl-keyword">private</span> String firstName;
    <span class="hl-keyword">private</span> String lastName;

    <span class="hl-keyword">public</span> String getFirstName() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>.firstName;
    }

    <span class="hl-keyword">public</span> String getLastName() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>.lastName;
    }

    <span class="hl-keyword">public</span> Long getId() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>.id;
    }

    <span class="hl-comment">// setters omitted...</span>

}</pre> 
    <pre class="programlisting"><span class="hl-comment">// some JDBC-backed DAO class...</span>
<span class="hl-keyword">private</span> NamedParameterJdbcTemplate namedParameterJdbcTemplate;

<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setDataSource(DataSource dataSource) {
    <span class="hl-keyword">this</span>.namedParameterJdbcTemplate = <span class="hl-keyword">new</span> NamedParameterJdbcTemplate(dataSource);
}

<span class="hl-keyword">public</span> <span class="hl-keyword">int</span> countOfActors(Actor exampleActor) {

    <span class="hl-comment">// notice how the named parameters match the properties of the above </span><span class="emphasis"><em>Actor</em></span> <span class="hl-keyword">class</span>
    String sql = <span class="hl-string">&quot;select count(*) from T_ACTOR where first_name = :firstName and last_name = :lastName&quot;</span>;

    SqlParameterSource namedParameters = <span class="hl-keyword">new</span> BeanPropertySqlParameterSource(exampleActor);

    <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>.namedParameterJdbcTemplate.queryForObject(sql, Integer.<span class="hl-keyword">class</span>, namedParameters);
}</pre> 
    <p>Remember that the <code class="literal">NamedParameterJdbcTemplate</code> class <span class="emphasis"><em>wraps</em></span> a classic <code class="literal">JdbcTemplate</code> template; if you need access to the wrapped <code class="literal">JdbcTemplate</code> instance to access functionality only present in the <code class="literal">JdbcTemplate</code> class, you can use the <code class="literal">getJdbcOperations()</code> method to access the wrapped <code class="literal">JdbcTemplate</code> through the <code class="literal">JdbcOperations</code> interface.</p> 
    <p>See also <a class="xref" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#jdbc-JdbcTemplate-idioms" title="JdbcTemplate best practices">the section called JdbcTemplate best practices</a> for guidelines on using the <code class="literal">NamedParameterJdbcTemplate</code> class in the context of an application.</p> 
   </div> 
   <div class="section" title="13.2.3&nbsp;SQLExceptionTranslator">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="jdbc-SQLExceptionTranslator"></a>13.2.3&nbsp;SQLExceptionTranslator</h3>
      </div>
     </div>
    </div> 
    <p><code class="literal">SQLExceptionTranslator</code> is an interface to be implemented by classes that can translate between <code class="literal">SQLExceptions</code> and Springs own <code class="literal">org.springframework.dao.DataAccessException</code>, which is agnostic in regard to data access strategy. Implementations can be generic (for example, using SQLState codes for JDBC) or proprietary (for example, using Oracle error codes) for greater precision.</p> 
    <p><code class="literal">SQLErrorCodeSQLExceptionTranslator</code> is the implementation of <code class="literal">SQLExceptionTranslator</code> that is used by default. This implementation uses specific vendor codes. It is more precise than the <code class="literal">SQLState</code> implementation. The error code translations are based on codes held in a JavaBean type class called <code class="literal">SQLErrorCodes</code>. This class is created and populated by an <code class="literal">SQLErrorCodesFactory</code> which as the name suggests is a factory for creating <code class="literal">SQLErrorCodes</code> based on the contents of a configuration file named <code class="literal">sql-error-codes.xml</code>. This file is populated with vendor codes and based on the <code class="literal">DatabaseProductName</code> taken from the <code class="literal">DatabaseMetaData</code>. The codes for the actual database you are using are used.</p> 
    <p>The <code class="literal">SQLErrorCodeSQLExceptionTranslator</code> applies matching rules in the following sequence:</p> 
    <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;">
     <table border="0" summary="Note">
      <tbody>
       <tr>
        <td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Framework Reference Documentation_files/note.png" /></td>
        <th align="left">Note</th>
       </tr>
       <tr>
        <td align="left" valign="top"> <p>The <code class="literal">SQLErrorCodesFactory</code> is used by default to define Error codes and custom exception translations. They are looked up in a file named <code class="literal">sql-error-codes.xml</code> from the classpath and the matching <code class="literal">SQLErrorCodes</code> instance is located based on the database name from the database metadata of the database in use.</p> </td>
       </tr>
      </tbody>
     </table>
    </div> 
    <div class="itemizedlist">
     <ul class="itemizedlist" type="disc">
      <li class="listitem"> Any custom translation implemented by a subclass. Normally the provided concrete <code class="literal">SQLErrorCodeSQLExceptionTranslator</code> is used so this rule does not apply. It only applies if you have actually provided a subclass implementation. </li>
      <li class="listitem"> Any custom implementation of the <code class="literal">SQLExceptionTranslator</code> interface that is provided as the <code class="literal">customSqlExceptionTranslator</code> property of the <code class="literal">SQLErrorCodes</code> class. </li>
      <li class="listitem"> The list of instances of the <code class="literal">CustomSQLErrorCodesTranslation</code> class, provided for the <code class="literal">customTranslations</code> property of the <code class="literal">SQLErrorCodes</code> class, are searched for a match. </li>
      <li class="listitem"> Error code matching is applied. </li>
      <li class="listitem"> Use the fallback translator. <code class="literal">SQLExceptionSubclassTranslator</code> is the default fallback translator. If this translation is not available then the next fallback translator is the <code class="literal">SQLStateSQLExceptionTranslator</code>. </li>
     </ul>
    </div> 
    <p>You can extend <code class="literal">SQLErrorCodeSQLExceptionTranslator:</code></p> 
    <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> CustomSQLErrorCodesTranslator <span class="hl-keyword">extends</span> SQLErrorCodeSQLExceptionTranslator {

    <span class="hl-keyword">protected</span> DataAccessException customTranslate(String task, String sql, SQLException sqlex) {
        <span class="hl-keyword">if</span> (sqlex.getErrorCode() == -<span class="hl-number">12345</span>) {
            <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> DeadlockLoserDataAccessException(task, sqlex);
        }
        <span class="hl-keyword">return</span> null;
    }
}</pre> 
    <p>In this example, the specific error code <code class="literal">-12345</code> is translated and other errors are left to be translated by the default translator implementation. To use this custom translator, it is necessary to pass it to the <code class="literal">JdbcTemplate</code> through the method <code class="literal">setExceptionTranslator</code> and to use this <code class="literal">JdbcTemplate</code> for all of the data access processing where this translator is needed. Here is an example of how this custom translator can be used:</p> 
    <pre class="programlisting"><span class="hl-keyword">private</span> JdbcTemplate jdbcTemplate;

<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setDataSource(DataSource dataSource) {

    <span class="hl-comment">// create a JdbcTemplate and set data source</span>
    <span class="hl-keyword">this</span>.jdbcTemplate = <span class="hl-keyword">new</span> JdbcTemplate();
    <span class="hl-keyword">this</span>.jdbcTemplate.setDataSource(dataSource);

    <span class="hl-comment">// create a custom translator and set the DataSource for the default translation lookup</span>
    CustomSQLErrorCodesTranslator tr = <span class="hl-keyword">new</span> CustomSQLErrorCodesTranslator();
    tr.setDataSource(dataSource);
    <span class="hl-keyword">this</span>.jdbcTemplate.setExceptionTranslator(tr);

}

<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> updateShippingCharge(<span class="hl-keyword">long</span> orderId, <span class="hl-keyword">long</span> pct) {
    <span class="hl-comment">// use the prepared JdbcTemplate for this update</span>
    <span class="hl-keyword">this</span>.jdbcTemplate.update(<span class="hl-string">&quot;update orders&quot;</span> +
        <span class="hl-string">&quot; set shipping_charge = shipping_charge * ? / 100&quot;</span> +
        <span class="hl-string">&quot; where id = ?&quot;</span>, pct, orderId);
}</pre> 
    <p>The custom translator is passed a data source in order to look up the error codes in <code class="literal">sql-error-codes.xml</code>.</p> 
   </div> 
   <div class="section" title="13.2.4&nbsp;Executing statements">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="jdbc-statements-executing"></a>13.2.4&nbsp;Executing statements</h3>
      </div>
     </div>
    </div> 
    <p>Executing an SQL statement requires very little code. You need a <code class="literal">DataSource</code> and a <code class="literal">JdbcTemplate</code>, including the convenience methods that are provided with the <code class="literal">JdbcTemplate</code>. The following example shows what you need to include for a minimal but fully functional class that creates a new table:</p> 
    <pre class="programlisting"><span class="hl-keyword">import</span> javax.sql.DataSource;
<span class="hl-keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ExecuteAStatement {

    <span class="hl-keyword">private</span> JdbcTemplate jdbcTemplate;

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setDataSource(DataSource dataSource) {
        <span class="hl-keyword">this</span>.jdbcTemplate = <span class="hl-keyword">new</span> JdbcTemplate(dataSource);
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> doExecute() {
        <span class="hl-keyword">this</span>.jdbcTemplate.execute(<span class="hl-string">&quot;create table mytable (id integer, name varchar(100))&quot;</span>);
    }
}</pre> 
   </div> 
   <div class="section" title="13.2.5&nbsp;Running queries">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="jdbc-statements-querying"></a>13.2.5&nbsp;Running queries</h3>
      </div>
     </div>
    </div> 
    <p>Some query methods return a single value. To retrieve a count or a specific value from one row, use <code class="literal">queryForObject(..)</code>. The latter converts the returned JDBC <code class="literal">Type</code> to the Java class that is passed in as an argument. If the type conversion is invalid, then an <code class="literal">InvalidDataAccessApiUsageException</code> is thrown. Here is an example that contains two query methods, one for an <code class="literal">int</code> and one that queries for a <code class="literal">String</code>.</p> 
    <pre class="programlisting"><span class="hl-keyword">import</span> javax.sql.DataSource;
<span class="hl-keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> RunAQuery {

    <span class="hl-keyword">private</span> JdbcTemplate jdbcTemplate;

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setDataSource(DataSource dataSource) {
        <span class="hl-keyword">this</span>.jdbcTemplate = <span class="hl-keyword">new</span> JdbcTemplate(dataSource);
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">int</span> getCount() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>.jdbcTemplate.queryForObject(<span class="hl-string">&quot;select count(*) from mytable&quot;</span>, Integer.<span class="hl-keyword">class</span>);
    }

    <span class="hl-keyword">public</span> String getName() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>.jdbcTemplate.queryForObject(<span class="hl-string">&quot;select name from mytable&quot;</span>, String.<span class="hl-keyword">class</span>);
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setDataSource(DataSource dataSource) {
        <span class="hl-keyword">this</span>.dataSource = dataSource;
    }
}</pre> 
    <p>In addition to the single result query methods, several methods return a list with an entry for each row that the query returned. The most generic method is <code class="literal">queryForList(..)</code> which returns a <code class="literal">List</code> where each entry is a <code class="literal">Map</code> with each entry in the map representing the column value for that row. If you add a method to the above example to retrieve a list of all the rows, it would look like this:</p> 
    <pre class="programlisting"><span class="hl-keyword">private</span> JdbcTemplate jdbcTemplate;

<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setDataSource(DataSource dataSource) {
    <span class="hl-keyword">this</span>.jdbcTemplate = <span class="hl-keyword">new</span> JdbcTemplate(dataSource);
}

<span class="hl-keyword">public</span> List&lt;Map&lt;String, Object&gt;&gt; getList() {
    <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>.jdbcTemplate.queryForList(<span class="hl-string">&quot;select * from mytable&quot;</span>);
}</pre> 
    <p>The list returned would look something like this:</p> 
    <pre class="literallayout">[{name=Bob, id=1}, {name=Mary, id=2}]</pre> 
   </div> 
   <div class="section" title="13.2.6&nbsp;Updating the database">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="jdbc-updates"></a>13.2.6&nbsp;Updating the database</h3>
      </div>
     </div>
    </div> 
    <p>The following example shows a column updated for a certain primary key. In this example, an SQL statement has placeholders for row parameters. The parameter values can be passed in as varargs or alternatively as an array of objects. Thus primitives should be wrapped in the primitive wrapper classes explicitly or using auto-boxing.</p> 
    <pre class="programlisting"><span class="hl-keyword">import</span> javax.sql.DataSource;

<span class="hl-keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ExecuteAnUpdate {

    <span class="hl-keyword">private</span> JdbcTemplate jdbcTemplate;

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setDataSource(DataSource dataSource) {
        <span class="hl-keyword">this</span>.jdbcTemplate = <span class="hl-keyword">new</span> JdbcTemplate(dataSource);
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setName(<span class="hl-keyword">int</span> id, String name) {
        <span class="hl-keyword">this</span>.jdbcTemplate.update(<span class="hl-string">&quot;update mytable set name = ? where id = ?&quot;</span>, name, id);
    }
}</pre> 
   </div> 
   <div class="section" title="13.2.7&nbsp;Retrieving auto-generated keys">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="jdbc-auto-genereted-keys"></a>13.2.7&nbsp;Retrieving auto-generated keys</h3>
      </div>
     </div>
    </div> 
    <p>An <code class="literal">update()</code> convenience method supports the retrieval of primary keys generated by the database. This support is part of the JDBC 3.0 standard; see Chapter 13.6 of the specification for details. The method takes a <code class="literal">PreparedStatementCreator</code> as its first argument, and this is the way the required insert statement is specified. The other argument is a <code class="literal">KeyHolder</code>, which contains the generated key on successful return from the update. There is not a standard single way to create an appropriate <code class="literal">PreparedStatement</code> (which explains why the method signature is the way it is). The following example works on Oracle but may not work on other platforms:</p> 
    <pre class="programlisting"><span class="hl-keyword">final</span> String INSERT_SQL = <span class="hl-string">&quot;insert into my_test (name) values(?)&quot;</span>;
<span class="hl-keyword">final</span> String name = <span class="hl-string">&quot;Rob&quot;</span>;

KeyHolder keyHolder = <span class="hl-keyword">new</span> GeneratedKeyHolder();
jdbcTemplate.update(
    <span class="hl-keyword">new</span> PreparedStatementCreator() {
        <span class="hl-keyword">public</span> PreparedStatement createPreparedStatement(Connection connection) <span class="hl-keyword">throws</span> SQLException {
            PreparedStatement ps = connection.prepareStatement(INSERT_SQL, <span class="hl-keyword">new</span> String[] {<span class="hl-string">&quot;id&quot;</span>});
            ps.setString(<span class="hl-number">1</span>, name);
            <span class="hl-keyword">return</span> ps;
        }
    },
    keyHolder);

<span class="hl-comment">// keyHolder.getKey() now contains the generated key</span></pre> 
   </div> 
  </div> 
  <div class="section" title="13.3&nbsp;Controlling database connections">
   <div class="titlepage">
    <div>
     <div>
      <h2 class="title" style="clear: both"><a name="jdbc-connections"></a>13.3&nbsp;Controlling database connections</h2>
     </div>
    </div>
   </div> 
   <div class="section" title="13.3.1&nbsp;DataSource">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="jdbc-datasource"></a>13.3.1&nbsp;DataSource</h3>
      </div>
     </div>
    </div> 
    <p>Spring obtains a connection to the database through a <code class="literal">DataSource</code>. A <code class="literal">DataSource</code> is part of the JDBC specification and is a generalized connection factory. It allows a container or a framework to hide connection pooling and transaction management issues from the application code. As a developer, you need not know details about how to connect to the database; that is the responsibility of the administrator that sets up the datasource. You most likely fill both roles as you develop and test code, but you do not necessarily have to know how the production data source is configured.</p> 
    <p>When using Springs JDBC layer, you obtain a data source from JNDI or you configure your own with a connection pool implementation provided by a third party. Popular implementations are Apache Jakarta Commons DBCP and C3P0. Implementations in the Spring distribution are meant only for testing purposes and do not provide pooling.</p> 
    <p>This section uses Springs <code class="literal">DriverManagerDataSource</code> implementation, and several additional implementations are covered later.</p> 
    <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;">
     <table border="0" summary="Note">
      <tbody>
       <tr>
        <td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Framework Reference Documentation_files/note.png" /></td>
        <th align="left">Note</th>
       </tr>
       <tr>
        <td align="left" valign="top"> <p>Only use the <code class="literal">DriverManagerDataSource</code> class should only be used for testing purposes since it does not provide pooling and will perform poorly when multiple requests for a connection are made.</p> </td>
       </tr>
      </tbody>
     </table>
    </div> 
    <p>You obtain a connection with <code class="literal">DriverManagerDataSource</code> as you typically obtain a JDBC connection. Specify the fully qualified classname of the JDBC driver so that the <code class="literal">DriverManager</code> can load the driver class. Next, provide a URL that varies between JDBC drivers. (Consult the documentation for your driver for the correct value.) Then provide a username and a password to connect to the database. Here is an example of how to configure a <code class="literal">DriverManagerDataSource</code> in Java code:</p> 
    <pre class="programlisting">DriverManagerDataSource dataSource = <span class="hl-keyword">new</span> DriverManagerDataSource();
dataSource.setDriverClassName(<span class="hl-string">&quot;org.hsqldb.jdbcDriver&quot;</span>);
dataSource.setUrl(<span class="hl-string">&quot;jdbc:hsqldb:hsql://localhost:&quot;</span>);
dataSource.setUsername(<span class="hl-string">&quot;sa&quot;</span>);
dataSource.setPassword(<span class="hl-string">&quot;&quot;</span>);</pre> 
    <p>Here is the corresponding XML configuration:</p> 
    <pre class="programlisting">&lt;bean id=<span class="hl-string">&quot;dataSource&quot;</span> <span class="hl-keyword">class</span>=<span class="hl-string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;
    &lt;property name=<span class="hl-string">&quot;driverClassName&quot;</span> value=<span class="hl-string">&quot;${jdbc.driverClassName}&quot;</span>/&gt;
    &lt;property name=<span class="hl-string">&quot;url&quot;</span> value=<span class="hl-string">&quot;${jdbc.url}&quot;</span>/&gt;
    &lt;property name=<span class="hl-string">&quot;username&quot;</span> value=<span class="hl-string">&quot;${jdbc.username}&quot;</span>/&gt;
    &lt;property name=<span class="hl-string">&quot;password&quot;</span> value=<span class="hl-string">&quot;${jdbc.password}&quot;</span>/&gt;
&lt;/bean&gt;

&lt;context:property-placeholder location=<span class="hl-string">&quot;jdbc.properties&quot;</span>/&gt;</pre> 
    <p>The following examples show the basic connectivity and configuration for DBCP and C3P0. To learn about more options that help control the pooling features, see the product documentation for the respective connection pooling implementations.</p> 
    <p>DBCP configuration:</p> 
    <pre class="programlisting">&lt;bean id=<span class="hl-string">&quot;dataSource&quot;</span> <span class="hl-keyword">class</span>=<span class="hl-string">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span> destroy-method=<span class="hl-string">&quot;close&quot;</span>&gt;
    &lt;property name=<span class="hl-string">&quot;driverClassName&quot;</span> value=<span class="hl-string">&quot;${jdbc.driverClassName}&quot;</span>/&gt;
    &lt;property name=<span class="hl-string">&quot;url&quot;</span> value=<span class="hl-string">&quot;${jdbc.url}&quot;</span>/&gt;
    &lt;property name=<span class="hl-string">&quot;username&quot;</span> value=<span class="hl-string">&quot;${jdbc.username}&quot;</span>/&gt;
    &lt;property name=<span class="hl-string">&quot;password&quot;</span> value=<span class="hl-string">&quot;${jdbc.password}&quot;</span>/&gt;
&lt;/bean&gt;

&lt;context:property-placeholder location=<span class="hl-string">&quot;jdbc.properties&quot;</span>/&gt;</pre> 
    <p>C3P0 configuration:</p> 
    <pre class="programlisting">&lt;bean id=<span class="hl-string">&quot;dataSource&quot;</span> <span class="hl-keyword">class</span>=<span class="hl-string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span> destroy-method=<span class="hl-string">&quot;close&quot;</span>&gt;
    &lt;property name=<span class="hl-string">&quot;driverClass&quot;</span> value=<span class="hl-string">&quot;${jdbc.driverClassName}&quot;</span>/&gt;
    &lt;property name=<span class="hl-string">&quot;jdbcUrl&quot;</span> value=<span class="hl-string">&quot;${jdbc.url}&quot;</span>/&gt;
    &lt;property name=<span class="hl-string">&quot;user&quot;</span> value=<span class="hl-string">&quot;${jdbc.username}&quot;</span>/&gt;
    &lt;property name=<span class="hl-string">&quot;password&quot;</span> value=<span class="hl-string">&quot;${jdbc.password}&quot;</span>/&gt;
&lt;/bean&gt;

&lt;context:property-placeholder location=<span class="hl-string">&quot;jdbc.properties&quot;</span>/&gt;</pre> 
   </div> 
   <div class="section" title="13.3.2&nbsp;DataSourceUtils">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="jdbc-DataSourceUtils"></a>13.3.2&nbsp;DataSourceUtils</h3>
      </div>
     </div>
    </div> 
    <p>The <code class="literal">DataSourceUtils</code> class is a convenient and powerful helper class that provides <code class="literal">static</code> methods to obtain connections from JNDI and close connections if necessary. It supports thread-bound connections with, for example, <code class="literal">DataSourceTransactionManager</code>.</p> 
   </div> 
   <div class="section" title="13.3.3&nbsp;SmartDataSource">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="jdbc-SmartDataSource"></a>13.3.3&nbsp;SmartDataSource</h3>
      </div>
     </div>
    </div> 
    <p>The <code class="literal">SmartDataSource</code> interface should be implemented by classes that can provide a connection to a relational database. It extends the <code class="literal">DataSource</code> interface to allow classes using it to query whether the connection should be closed after a given operation. This usage is efficient when you know that you will reuse a connection.</p> 
   </div> 
   <div class="section" title="13.3.4&nbsp;AbstractDataSource">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="jdbc-AbstractDataSource"></a>13.3.4&nbsp;AbstractDataSource</h3>
      </div>
     </div>
    </div> 
    <p><code class="literal">AbstractDataSource</code> is an <code class="literal">abstract</code> base class for Springs <code class="literal">DataSource</code> implementations that implements code that is common to all <code class="literal">DataSource</code> implementations. You extend the <code class="literal">AbstractDataSource</code> class if you are writing your own <code class="literal">DataSource</code> implementation.</p> 
   </div> 
   <div class="section" title="13.3.5&nbsp;SingleConnectionDataSource">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="jdbc-SingleConnectionDataSource"></a>13.3.5&nbsp;SingleConnectionDataSource</h3>
      </div>
     </div>
    </div> 
    <p>The <code class="literal">SingleConnectionDataSource</code> class is an implementation of the <code class="literal">SmartDataSource</code> interface that wraps a <span class="emphasis"><em>single</em></span> <code class="literal">Connection</code> that is <span class="emphasis"><em>not</em></span> closed after each use. Obviously, this is not multi-threading capable.</p> 
    <p>If any client code calls <code class="literal">close</code> in the assumption of a pooled connection, as when using persistence tools, set the <code class="literal">suppressClose</code> property to <code class="literal">true</code>. This setting returns a close-suppressing proxy wrapping the physical connection. Be aware that you will not be able to cast this to a native Oracle <code class="literal">Connection</code> or the like anymore.</p> 
    <p>This is primarily a test class. For example, it enables easy testing of code outside an application server, in conjunction with a simple JNDI environment. In contrast to <code class="literal">DriverManagerDataSource</code>, it reuses the same connection all the time, avoiding excessive creation of physical connections.</p> 
   </div> 
   <div class="section" title="13.3.6&nbsp;DriverManagerDataSource">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="jdbc-DriverManagerDataSource"></a>13.3.6&nbsp;DriverManagerDataSource</h3>
      </div>
     </div>
    </div> 
    <p>The <code class="literal">DriverManagerDataSource</code> class is an implementation of the standard <code class="literal">DataSource</code> interface that configures a plain JDBC driver through bean properties, and returns a new <code class="literal">Connection</code> every time.</p> 
    <p>This implementation is useful for test and stand-alone environments outside of a Java EE container, either as a <code class="literal">DataSource</code> bean in a Spring IoC container, or in conjunction with a simple JNDI environment. Pool-assuming <code class="literal">Connection.close()</code> calls will simply close the connection, so any <code class="literal">DataSource</code>-aware persistence code should work. However, using JavaBean-style connection pools such as <code class="literal">commons-dbcp</code> is so easy, even in a test environment, that it is almost always preferable to use such a connection pool over <code class="literal">DriverManagerDataSource</code>.</p> 
   </div> 
   <div class="section" title="13.3.7&nbsp;TransactionAwareDataSourceProxy">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="jdbc-TransactionAwareDataSourceProxy"></a>13.3.7&nbsp;TransactionAwareDataSourceProxy</h3>
      </div>
     </div>
    </div> 
    <p><code class="literal">TransactionAwareDataSourceProxy</code> is a proxy for a target <code class="literal">DataSource</code>, which wraps that target <code class="literal">DataSource</code> to add awareness of Spring-managed transactions. In this respect, it is similar to a transactional JNDI <code class="literal">DataSource</code> as provided by a Java EE server.</p> 
    <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;">
     <table border="0" summary="Note">
      <tbody>
       <tr>
        <td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Framework Reference Documentation_files/note.png" /></td>
        <th align="left">Note</th>
       </tr>
       <tr>
        <td align="left" valign="top"> <p>It is rarely desirable to use this class, except when already existing code that must be called and passed a standard JDBC <code class="literal">DataSource</code> interface implementation. In this case, its possible to still have this code be usable, and at the same time have this code participating in Spring managed transactions. It is generally preferable to write your own new code using the higher level abstractions for resource management, such as <code class="literal">JdbcTemplate</code> or <code class="literal">DataSourceUtils</code>.</p> </td>
       </tr>
      </tbody>
     </table>
    </div> 
    <p><span class="emphasis"><em>(See the <code class="literal">TransactionAwareDataSourceProxy</code> Javadocs for more details.)</em></span></p> 
   </div> 
   <div class="section" title="13.3.8&nbsp;DataSourceTransactionManager">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="jdbc-DataSourceTransactionManager"></a>13.3.8&nbsp;DataSourceTransactionManager</h3>
      </div>
     </div>
    </div> 
    <p>The <code class="literal">DataSourceTransactionManager</code> class is a <code class="literal">PlatformTransactionManager</code> implementation for single JDBC datasources. It binds a JDBC connection from the specified data source to the currently executing thread, potentially allowing for one thread connection per data source.</p> 
    <p>Application code is required to retrieve the JDBC connection through <code class="literal">DataSourceUtils.getConnection(DataSource)</code> instead of Java EEs standard <code class="literal">DataSource.getConnection</code>. It throws unchecked <code class="literal">org.springframework.dao</code> exceptions instead of checked <code class="literal">SQLExceptions</code>. All framework classes like <code class="literal">JdbcTemplate</code> use this strategy implicitly. If not used with this transaction manager, the lookup strategy behaves exactly like the common one - it can thus be used in any case.</p> 
    <p>The <code class="literal">DataSourceTransactionManager</code> class supports custom isolation levels, and timeouts that get applied as appropriate JDBC statement query timeouts. To support the latter, application code must either use <code class="literal">JdbcTemplate</code> or call the <code class="literal">DataSourceUtils.applyTransactionTimeout(..)</code> method for each created statement.</p> 
    <p>This implementation can be used instead of <code class="literal">JtaTransactionManager</code> in the single resource case, as it does not require the container to support JTA. Switching between both is just a matter of configuration, if you stick to the required connection lookup pattern. JTA does not support custom isolation levels!</p> 
   </div> 
   <div class="section" title="13.3.9&nbsp;NativeJdbcExtractor">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="jdbc-NativeJdbcExtractor"></a>13.3.9&nbsp;NativeJdbcExtractor</h3>
      </div>
     </div>
    </div> 
    <p>Sometimes you need to access vendor specific JDBC methods that differ from the standard JDBC API. This can be problematic if you are running in an application server or with a <code class="literal">DataSource</code> that wraps the <code class="literal">Connection</code>, <code class="literal">Statement</code> and <code class="literal">ResultSet</code> objects with its own wrapper objects. To gain access to the native objects you can configure your <code class="literal">JdbcTemplate</code> or <code class="literal">OracleLobHandler</code> with a <code class="literal">NativeJdbcExtractor</code>.</p> 
    <p>The <code class="literal">NativeJdbcExtractor</code> comes in a variety of flavors to match your execution environment:</p> 
    <div class="itemizedlist">
     <ul class="itemizedlist" type="disc">
      <li class="listitem"> SimpleNativeJdbcExtractor </li>
      <li class="listitem"> C3P0NativeJdbcExtractor </li>
      <li class="listitem"> CommonsDbcpNativeJdbcExtractor </li>
      <li class="listitem"> JBossNativeJdbcExtractor </li>
      <li class="listitem"> WebLogicNativeJdbcExtractor </li>
      <li class="listitem"> WebSphereNativeJdbcExtractor </li>
      <li class="listitem"> XAPoolNativeJdbcExtractor </li>
     </ul>
    </div> 
    <p>Usually the <code class="literal">SimpleNativeJdbcExtractor</code> is sufficient for unwrapping a <code class="literal">Connection</code> object in most environments. See the Javadocs for more details.</p> 
   </div> 
  </div> 
  <div class="section" title="13.4&nbsp;JDBC batch operations">
   <div class="titlepage">
    <div>
     <div>
      <h2 class="title" style="clear: both"><a name="jdbc-advanced-jdbc"></a>13.4&nbsp;JDBC batch operations</h2>
     </div>
    </div>
   </div> 
   <p>Most JDBC drivers provide improved performance if you batch multiple calls to the same prepared statement. By grouping updates into batches you limit the number of round trips to the database.</p> 
   <div class="section" title="13.4.1&nbsp;Basic batch operations with the JdbcTemplate">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="jdbc-batch-classic"></a>13.4.1&nbsp;Basic batch operations with the JdbcTemplate</h3>
      </div>
     </div>
    </div> 
    <p>You accomplish <code class="literal">JdbcTemplate</code> batch processing by implementing two methods of a special interface, <code class="literal">BatchPreparedStatementSetter</code>, and passing that in as the second parameter in your <code class="literal">batchUpdate</code> method call. Use the <code class="literal">getBatchSize</code> method to provide the size of the current batch. Use the <code class="literal">setValues</code> method to set the values for the parameters of the prepared statement. This method will be called the number of times that you specified in the <code class="literal">getBatchSize</code> call. The following example updates the actor table based on entries in a list. The entire list is used as the batch in this example:</p> 
    <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> JdbcActorDao <span class="hl-keyword">implements</span> ActorDao {
    <span class="hl-keyword">private</span> JdbcTemplate jdbcTemplate;

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setDataSource(DataSource dataSource) {
        <span class="hl-keyword">this</span>.jdbcTemplate = <span class="hl-keyword">new</span> JdbcTemplate(dataSource);
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">int</span>[] batchUpdate(<span class="hl-keyword">final</span> List&lt;Actor&gt; actors) {
        <span class="hl-keyword">int</span>[] updateCounts = jdbcTemplate.batchUpdate(<span class="hl-string">&quot;update t_actor set first_name = ?, &quot;</span> +
                <span class="hl-string">&quot;last_name = ? where id = ?&quot;</span>,
            <span class="hl-keyword">new</span> BatchPreparedStatementSetter() {
                <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setValues(PreparedStatement ps, <span class="hl-keyword">int</span> i) <span class="hl-keyword">throws</span> SQLException {
                        ps.setString(<span class="hl-number">1</span>, actors.get(i).getFirstName());
                        ps.setString(<span class="hl-number">2</span>, actors.get(i).getLastName());
                        ps.setLong(<span class="hl-number">3</span>, actors.get(i).getId().longValue());
                    }

                    <span class="hl-keyword">public</span> <span class="hl-keyword">int</span> getBatchSize() {
                        <span class="hl-keyword">return</span> actors.size();
                    }
                });
        <span class="hl-keyword">return</span> updateCounts;
    }

    <span class="hl-comment">// ... additional methods</span>
}</pre> 
    <p>If you are processing a stream of updates or reading from a file, then you might have a preferred batch size, but the last batch might not have that number of entries. In this case you can use the <code class="literal">InterruptibleBatchPreparedStatementSetter</code> interface, which allows you to interrupt a batch once the input source is exhausted. The <code class="literal">isBatchExhausted</code> method allows you to signal the end of the batch.</p> 
   </div> 
   <div class="section" title="13.4.2&nbsp;Batch operations with a List of objects">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="jdbc-batch-list"></a>13.4.2&nbsp;Batch operations with a List of objects</h3>
      </div>
     </div>
    </div> 
    <p>Both the <code class="literal">JdbcTemplate</code> and the <code class="literal">NamedParameterJdbcTemplate</code> provides an alternate way of providing the batch update. Instead of implementing a special batch interface, you provide all parameter values in the call as a list. The framework loops over these values and uses an internal prepared statement setter. The API varies depending on whether you use named parameters. For the named parameters you provide an array of <code class="literal">SqlParameterSource</code>, one entry for each member of the batch. You can use the <code class="literal">SqlParameterSource.createBatch</code> method to create this array, passing in either an array of JavaBeans or an array of Maps containing the parameter values.</p> 
    <p>This example shows a batch update using named parameters:</p> 
    <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> JdbcActorDao <span class="hl-keyword">implements</span> ActorDao {
    <span class="hl-keyword">private</span> NamedParameterTemplate namedParameterJdbcTemplate;

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setDataSource(DataSource dataSource) {
        <span class="hl-keyword">this</span>.namedParameterJdbcTemplate = <span class="hl-keyword">new</span> NamedParameterJdbcTemplate(dataSource);
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">int</span>[] batchUpdate(<span class="hl-keyword">final</span> List&lt;Actor&gt; actors) {
        SqlParameterSource[] batch = SqlParameterSourceUtils.createBatch(actors.toArray());
        <span class="hl-keyword">int</span>[] updateCounts = namedParameterJdbcTemplate.batchUpdate(
                <span class="hl-string">&quot;update t_actor set first_name = :firstName, last_name = :lastName where id = :id&quot;</span>,
                batch);
        <span class="hl-keyword">return</span> updateCounts;
    }

    <span class="hl-comment">// ... additional methods</span>
}</pre> 
    <p>For an SQL statement using the classic &quot;?&quot; placeholders, you pass in a list containing an object array with the update values. This object array must have one entry for each placeholder in the SQL statement, and they must be in the same order as they are defined in the SQL statement.</p> 
    <p>The same example using classic JDBC &quot;?&quot; placeholders:</p> 
    <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> JdbcActorDao <span class="hl-keyword">implements</span> ActorDao {

    <span class="hl-keyword">private</span> JdbcTemplate jdbcTemplate;

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setDataSource(DataSource dataSource) {
        <span class="hl-keyword">this</span>.jdbcTemplate = <span class="hl-keyword">new</span> JdbcTemplate(dataSource);
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">int</span>[] batchUpdate(<span class="hl-keyword">final</span> List&lt;Actor&gt; actors) {
        List&lt;Object[]&gt; batch = <span class="hl-keyword">new</span> ArrayList&lt;Object[]&gt;();
        <span class="hl-keyword">for</span> (Actor actor : actors) {
            Object[] values = <span class="hl-keyword">new</span> Object[] {
                    actor.getFirstName(),
                    actor.getLastName(),
                    actor.getId()};
            batch.add(values);
        }
        <span class="hl-keyword">int</span>[] updateCounts = jdbcTemplate.batchUpdate(
                <span class="hl-string">&quot;update t_actor set first_name = ?, last_name = ? where id = ?&quot;</span>,
                batch);
        <span class="hl-keyword">return</span> updateCounts;
    }

    <span class="hl-comment">// ... additional methods</span>

}</pre> 
    <p>All of the above batch update methods return an int array containing the number of affected rows for each batch entry. This count is reported by the JDBC driver. If the count is not available, the JDBC driver returns a -2 value.</p> 
   </div> 
   <div class="section" title="13.4.3&nbsp;Batch operations with multiple batches">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="jdbc-batch-multi"></a>13.4.3&nbsp;Batch operations with multiple batches</h3>
      </div>
     </div>
    </div> 
    <p>The last example of a batch update deals with batches that are so large that you want to break them up into several smaller batches. You can of course do this with the methods mentioned above by making multiple calls to the <code class="literal">batchUpdate</code> method, but there is now a more convenient method. This method takes, in addition to the SQL statement, a Collection of objects containing the parameters, the number of updates to make for each batch and a <code class="literal">ParameterizedPreparedStatementSetter</code> to set the values for the parameters of the prepared statement. The framework loops over the provided values and breaks the update calls into batches of the size specified.</p> 
    <p>This example shows a batch update using a batch size of 100:</p> 
    <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> JdbcActorDao <span class="hl-keyword">implements</span> ActorDao {

    <span class="hl-keyword">private</span> JdbcTemplate jdbcTemplate;

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setDataSource(DataSource dataSource) {
        <span class="hl-keyword">this</span>.jdbcTemplate = <span class="hl-keyword">new</span> JdbcTemplate(dataSource);
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">int</span>[][] batchUpdate(<span class="hl-keyword">final</span> Collection&lt;Actor&gt; actors) {
        <span class="hl-keyword">int</span>[][] updateCounts = jdbcTemplate.batchUpdate(
                <span class="hl-string">&quot;update t_actor set first_name = ?, last_name = ? where id = ?&quot;</span>,
                actors,
                <span class="hl-number">100</span>,
                <span class="hl-keyword">new</span> ParameterizedPreparedStatementSetter&lt;Actor&gt;() {
                    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setValues(PreparedStatement ps, Actor argument) <span class="hl-keyword">throws</span> SQLException {
                        ps.setString(<span class="hl-number">1</span>, argument.getFirstName());
                        ps.setString(<span class="hl-number">2</span>, argument.getLastName());
                        ps.setLong(<span class="hl-number">3</span>, argument.getId().longValue());
                    }
                });
        <span class="hl-keyword">return</span> updateCounts;
    }

    <span class="hl-comment">// ... additional methods</span>

}</pre> 
    <p>The batch update methods for this call returns an array of int arrays containing an array entry for each batch with an array of the number of affected rows for each update. The top level arrays length indicates the number of batches executed and the second level arrays length indicates the number of updates in that batch. The number of updates in each batch should be the the batch size provided for all batches except for the last one that might be less, depending on the total number of update objects provided. The update count for each update statement is the one reported by the JDBC driver. If the count is not available, the JDBC driver returns a -2 value.</p> 
   </div> 
  </div> 
  <div class="section" title="13.5&nbsp;Simplifying JDBC operations with the SimpleJdbc classes">
   <div class="titlepage">
    <div>
     <div>
      <h2 class="title" style="clear: both"><a name="jdbc-simple-jdbc"></a>13.5&nbsp;Simplifying JDBC operations with the SimpleJdbc classes</h2>
     </div>
    </div>
   </div> 
   <p>The <code class="literal">SimpleJdbcInsert</code> and <code class="literal">SimpleJdbcCall</code> classes provide a simplified configuration by taking advantage of database metadata that can be retrieved through the JDBC driver. This means there is less to configure up front, although you can override or turn off the metadata processing if you prefer to provide all the details in your code.</p> 
   <div class="section" title="13.5.1&nbsp;Inserting data using SimpleJdbcInsert">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="jdbc-simple-jdbc-insert-1"></a>13.5.1&nbsp;Inserting data using SimpleJdbcInsert</h3>
      </div>
     </div>
    </div> 
    <p>Lets start by looking at the <code class="literal">SimpleJdbcInsert</code> class with the minimal amount of configuration options. You should instantiate the <code class="literal">SimpleJdbcInsert</code> in the data access layers initialization method. For this example, the initializing method is the <code class="literal">setDataSource</code> method. You do not need to subclass the <code class="literal">SimpleJdbcInsert</code> class; simply create a new instance and set the table name using the <code class="literal">withTableName</code> method. Configuration methods for this class follow the &quot;fluid&quot; style that returns the instance of the <code class="literal">SimpleJdbcInsert</code>, which allows you to chain all configuration methods. This example uses only one configuration method; you will see examples of multiple ones later.</p> 
    <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> JdbcActorDao <span class="hl-keyword">implements</span> ActorDao {

    <span class="hl-keyword">private</span> JdbcTemplate jdbcTemplate;
    <span class="hl-keyword">private</span> SimpleJdbcInsert insertActor;

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setDataSource(DataSource dataSource) {
        <span class="hl-keyword">this</span>.jdbcTemplate = <span class="hl-keyword">new</span> JdbcTemplate(dataSource);
        <span class="hl-keyword">this</span>.insertActor = <span class="hl-keyword">new</span> SimpleJdbcInsert(dataSource).withTableName(<span class="hl-string">&quot;t_actor&quot;</span>);
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> add(Actor actor) {
        Map&lt;String, Object&gt; parameters = <span class="hl-keyword">new</span> HashMap&lt;String, Object&gt;(<span class="hl-number">3</span>);
        parameters.put(<span class="hl-string">&quot;id&quot;</span>, actor.getId());
        parameters.put(<span class="hl-string">&quot;first_name&quot;</span>, actor.getFirstName());
        parameters.put(<span class="hl-string">&quot;last_name&quot;</span>, actor.getLastName());
        insertActor.execute(parameters);
    }

    <span class="hl-comment">// ... additional methods</span>
}</pre> 
    <p>The execute method used here takes a plain <code class="literal">java.utils.Map</code> as its only parameter. The important thing to note here is that the keys used for the Map must match the column names of the table as defined in the database. This is because we read the metadata in order to construct the actual insert statement.</p> 
   </div> 
   <div class="section" title="13.5.2&nbsp;Retrieving auto-generated keys using SimpleJdbcInsert">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="jdbc-simple-jdbc-insert-2"></a>13.5.2&nbsp;Retrieving auto-generated keys using SimpleJdbcInsert</h3>
      </div>
     </div>
    </div> 
    <p>This example uses the same insert as the preceding, but instead of passing in the id it retrieves the auto-generated key and sets it on the new Actor object. When you create the <code class="literal">SimpleJdbcInsert</code>, in addition to specifying the table name, you specify the name of the generated key column with the <code class="literal">usingGeneratedKeyColumns</code> method.</p> 
    <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> JdbcActorDao <span class="hl-keyword">implements</span> ActorDao {

    <span class="hl-keyword">private</span> JdbcTemplate jdbcTemplate;
    <span class="hl-keyword">private</span> SimpleJdbcInsert insertActor;

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setDataSource(DataSource dataSource) {
        <span class="hl-keyword">this</span>.jdbcTemplate = <span class="hl-keyword">new</span> JdbcTemplate(dataSource);
        <span class="hl-keyword">this</span>.insertActor = <span class="hl-keyword">new</span> SimpleJdbcInsert(dataSource)
                .withTableName(<span class="hl-string">&quot;t_actor&quot;</span>)
                .usingGeneratedKeyColumns(<span class="hl-string">&quot;id&quot;</span>);
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> add(Actor actor) {
        Map&lt;String, Object&gt; parameters = <span class="hl-keyword">new</span> HashMap&lt;String, Object&gt;(<span class="hl-number">2</span>);
        parameters.put(<span class="hl-string">&quot;first_name&quot;</span>, actor.getFirstName());
        parameters.put(<span class="hl-string">&quot;last_name&quot;</span>, actor.getLastName());
        Number newId = insertActor.executeAndReturnKey(parameters);
        actor.setId(newId.longValue());
    }

    <span class="hl-comment">// ... additional methods</span>
}</pre> 
    <p>The main difference when executing the insert by this second approach is that you do not add the id to the Map and you call the <code class="literal">executeReturningKey</code> method. This returns a <code class="literal">java.lang.Number</code> object with which you can create an instance of the numerical type that is used in our domain class. You cannot rely on all databases to return a specific Java class here; <code class="literal">java.lang.Number</code> is the base class that you can rely on. If you have multiple auto-generated columns, or the generated values are non-numeric, then you can use a <code class="literal">KeyHolder</code> that is returned from the <code class="literal">executeReturningKeyHolder</code> method.</p> 
   </div> 
   <div class="section" title="13.5.3&nbsp;Specifying columns for a SimpleJdbcInsert">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="jdbc-simple-jdbc-insert-3"></a>13.5.3&nbsp;Specifying columns for a SimpleJdbcInsert</h3>
      </div>
     </div>
    </div> 
    <p>You can limit the columns for an insert by specifying a list of column names with the <code class="literal">usingColumns</code> method:</p> 
    <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> JdbcActorDao <span class="hl-keyword">implements</span> ActorDao {

    <span class="hl-keyword">private</span> JdbcTemplate jdbcTemplate;
    <span class="hl-keyword">private</span> SimpleJdbcInsert insertActor;

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setDataSource(DataSource dataSource) {
        <span class="hl-keyword">this</span>.jdbcTemplate = <span class="hl-keyword">new</span> JdbcTemplate(dataSource);
        <span class="hl-keyword">this</span>.insertActor = <span class="hl-keyword">new</span> SimpleJdbcInsert(dataSource)
                .withTableName(<span class="hl-string">&quot;t_actor&quot;</span>)
                .usingColumns(<span class="hl-string">&quot;first_name&quot;</span>, <span class="hl-string">&quot;last_name&quot;</span>)
                .usingGeneratedKeyColumns(<span class="hl-string">&quot;id&quot;</span>);
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> add(Actor actor) {
        Map&lt;String, Object&gt; parameters = <span class="hl-keyword">new</span> HashMap&lt;String, Object&gt;(<span class="hl-number">2</span>);
        parameters.put(<span class="hl-string">&quot;first_name&quot;</span>, actor.getFirstName());
        parameters.put(<span class="hl-string">&quot;last_name&quot;</span>, actor.getLastName());
        Number newId = insertActor.executeAndReturnKey(parameters);
        actor.setId(newId.longValue());
    }

    <span class="hl-comment">// ... additional methods</span>

}</pre> 
    <p>The execution of the insert is the same as if you had relied on the metadata to determine which columns to use.</p> 
   </div> 
   <div class="section" title="13.5.4&nbsp;Using SqlParameterSource to provide parameter values">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="jdbc-simple-jdbc-parameters"></a>13.5.4&nbsp;Using SqlParameterSource to provide parameter values</h3>
      </div>
     </div>
    </div> 
    <p>Using a <code class="literal">Map</code> to provide parameter values works fine, but its not the most convenient class to use. Spring provides a couple of implementations of the <code class="literal">SqlParameterSource</code> interface that can be used instead.The first one is <code class="literal">BeanPropertySqlParameterSource</code>, which is a very convenient class if you have a JavaBean-compliant class that contains your values. It will use the corresponding getter method to extract the parameter values. Here is an example:</p> 
    <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> JdbcActorDao <span class="hl-keyword">implements</span> ActorDao {

    <span class="hl-keyword">private</span> JdbcTemplate jdbcTemplate;
    <span class="hl-keyword">private</span> SimpleJdbcInsert insertActor;

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setDataSource(DataSource dataSource) {
        <span class="hl-keyword">this</span>.jdbcTemplate = <span class="hl-keyword">new</span> JdbcTemplate(dataSource);
        <span class="hl-keyword">this</span>.insertActor = <span class="hl-keyword">new</span> SimpleJdbcInsert(dataSource)
                .withTableName(<span class="hl-string">&quot;t_actor&quot;</span>)
                .usingGeneratedKeyColumns(<span class="hl-string">&quot;id&quot;</span>);
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> add(Actor actor) {
        SqlParameterSource parameters = <span class="hl-keyword">new</span> BeanPropertySqlParameterSource(actor);
        Number newId = insertActor.executeAndReturnKey(parameters);
        actor.setId(newId.longValue());
    }

    <span class="hl-comment">// ... additional methods</span>

}</pre> 
    <p>Another option is the <code class="literal">MapSqlParameterSource</code> that resembles a Map but provides a more convenient <code class="literal">addValue</code> method that can be chained.</p> 
    <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> JdbcActorDao <span class="hl-keyword">implements</span> ActorDao {

    <span class="hl-keyword">private</span> JdbcTemplate jdbcTemplate;
    <span class="hl-keyword">private</span> SimpleJdbcInsert insertActor;

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setDataSource(DataSource dataSource) {
        <span class="hl-keyword">this</span>.jdbcTemplate = <span class="hl-keyword">new</span> JdbcTemplate(dataSource);
        <span class="hl-keyword">this</span>.insertActor = <span class="hl-keyword">new</span> SimpleJdbcInsert(dataSource)
                .withTableName(<span class="hl-string">&quot;t_actor&quot;</span>)
                .usingGeneratedKeyColumns(<span class="hl-string">&quot;id&quot;</span>);
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> add(Actor actor) {
        SqlParameterSource parameters = <span class="hl-keyword">new</span> MapSqlParameterSource()
                .addValue(<span class="hl-string">&quot;first_name&quot;</span>, actor.getFirstName())
                .addValue(<span class="hl-string">&quot;last_name&quot;</span>, actor.getLastName());
        Number newId = insertActor.executeAndReturnKey(parameters);
        actor.setId(newId.longValue());
    }

    <span class="hl-comment">// ... additional methods</span>

}</pre> 
    <p>As you can see, the configuration is the same; only the executing code has to change to use these alternative input classes.</p> 
   </div> 
   <div class="section" title="13.5.5&nbsp;Calling a stored procedure with SimpleJdbcCall">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="jdbc-simple-jdbc-call-1"></a>13.5.5&nbsp;Calling a stored procedure with SimpleJdbcCall</h3>
      </div>
     </div>
    </div> 
    <p>The <code class="literal">SimpleJdbcCall</code> class leverages metadata in the database to look up names of <code class="literal">in</code> and <code class="literal">out</code> parameters, so that you do not have to declare them explicitly. You can declare parameters if you prefer to do that, or if you have parameters such as <code class="literal">ARRAY</code> or <code class="literal">STRUCT</code> that do not have an automatic mapping to a Java class. The first example shows a simple procedure that returns only scalar values in <code class="literal">VARCHAR</code> and <code class="literal">DATE</code> format from a MySQL database. The example procedure reads a specified actor entry and returns <code class="literal">first_name</code>, <code class="literal">last_name</code>, and <code class="literal">birth_date</code> columns in the form of <code class="literal">out</code> parameters.</p> 
    <pre class="programlisting">CREATE PROCEDURE read_actor (
    IN in_id INTEGER,
    OUT out_first_name VARCHAR(100),
    OUT out_last_name VARCHAR(100),
    OUT out_birth_date DATE)
BEGIN
    SELECT first_name, last_name, birth_date
    INTO out_first_name, out_last_name, out_birth_date
    FROM t_actor where id = in_id;
END;</pre> 
    <p>The <code class="literal">in_id</code> parameter contains the <code class="literal">id</code> of the actor you are looking up. The <code class="literal">out</code> parameters return the data read from the table.</p> 
    <p>The <code class="literal">SimpleJdbcCall</code> is declared in a similar manner to the <code class="literal">SimpleJdbcInsert</code>. You should instantiate and configure the class in the initialization method of your data access layer. Compared to the StoredProcedure class, you dont have to create a subclass and you dont have to declare parameters that can be looked up in the database metadata. Following is an example of a SimpleJdbcCall configuration using the above stored procedure. The only configuration option, in addition to the <code class="literal">DataSource</code>, is the name of the stored procedure.</p> 
    <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> JdbcActorDao <span class="hl-keyword">implements</span> ActorDao {

    <span class="hl-keyword">private</span> JdbcTemplate jdbcTemplate;
    <span class="hl-keyword">private</span> SimpleJdbcCall procReadActor;

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setDataSource(DataSource dataSource) {
        <span class="hl-keyword">this</span>.jdbcTemplate = <span class="hl-keyword">new</span> JdbcTemplate(dataSource);
        <span class="hl-keyword">this</span>.procReadActor = <span class="hl-keyword">new</span> SimpleJdbcCall(dataSource)
                .withProcedureName(<span class="hl-string">&quot;read_actor&quot;</span>);
    }

    <span class="hl-keyword">public</span> Actor readActor(Long id) {
        SqlParameterSource in = <span class="hl-keyword">new</span> MapSqlParameterSource()
                .addValue(<span class="hl-string">&quot;in_id&quot;</span>, id);
        Map out = procReadActor.execute(in);
        Actor actor = <span class="hl-keyword">new</span> Actor();
        actor.setId(id);
        actor.setFirstName((String) out.get(<span class="hl-string">&quot;out_first_name&quot;</span>));
        actor.setLastName((String) out.get(<span class="hl-string">&quot;out_last_name&quot;</span>));
        actor.setBirthDate((Date) out.get(<span class="hl-string">&quot;out_birth_date&quot;</span>));
        <span class="hl-keyword">return</span> actor;
    }

    <span class="hl-comment">// ... additional methods</span>

}</pre> 
    <p>The code you write for the execution of the call involves creating an <code class="literal">SqlParameterSource</code> containing the IN parameter. Its important to match the name provided for the input value with that of the parameter name declared in the stored procedure. The case does not have to match because you use metadata to determine how database objects should be referred to in a stored procedure. What is specified in the source for the stored procedure is not necessarily the way it is stored in the database. Some databases transform names to all upper case while others use lower case or use the case as specified.</p> 
    <p>The <code class="literal">execute</code> method takes the IN parameters and returns a Map containing any <code class="literal">out</code> parameters keyed by the name as specified in the stored procedure. In this case they are <code class="literal">out_first_name, out_last_name</code> and <code class="literal">out_birth_date</code>.</p> 
    <p>The last part of the <code class="literal">execute</code> method creates an Actor instance to use to return the data retrieved. Again, it is important to use the names of the <code class="literal">out</code> parameters as they are declared in the stored procedure. Also, the case in the names of the <code class="literal">out</code> parameters stored in the results map matches that of the <code class="literal">out</code> parameter names in the database, which could vary between databases. To make your code more portable you should do a case-insensitive lookup or instruct Spring to use a <code class="literal">CaseInsensitiveMap</code> from the Jakarta Commons project. To do the latter, you create your own <code class="literal">JdbcTemplate</code> and set the <code class="literal">setResultsMapCaseInsensitive</code> property to <code class="literal">true</code>. Then you pass this customized <code class="literal">JdbcTemplate</code> instance into the constructor of your <code class="literal">SimpleJdbcCall</code>. You must include the <code class="literal">commons-collections.jar</code> in your classpath for this to work. Here is an example of this configuration:</p> 
    <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> JdbcActorDao <span class="hl-keyword">implements</span> ActorDao {

    <span class="hl-keyword">private</span> SimpleJdbcCall procReadActor;

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setDataSource(DataSource dataSource) {
        JdbcTemplate jdbcTemplate = <span class="hl-keyword">new</span> JdbcTemplate(dataSource);
        jdbcTemplate.setResultsMapCaseInsensitive(true);
        <span class="hl-keyword">this</span>.procReadActor = <span class="hl-keyword">new</span> SimpleJdbcCall(jdbcTemplate)
                .withProcedureName(<span class="hl-string">&quot;read_actor&quot;</span>);
    }

    <span class="hl-comment">// ... additional methods</span>

}</pre> 
    <p>By taking this action, you avoid conflicts in the case used for the names of your returned <code class="literal">out</code> parameters.</p> 
   </div> 
   <div class="section" title="13.5.6&nbsp;Explicitly declaring parameters to use for a SimpleJdbcCall">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="jdbc-simple-jdbc-call-2"></a>13.5.6&nbsp;Explicitly declaring parameters to use for a SimpleJdbcCall</h3>
      </div>
     </div>
    </div> 
    <p>You have seen how the parameters are deduced based on metadata, but you can declare then explicitly if you wish. You do this by creating and configuring <code class="literal">SimpleJdbcCall</code> with the <code class="literal">declareParameters</code> method, which takes a variable number of <code class="literal">SqlParameter</code> objects as input. See the next section for details on how to define an <code class="literal">SqlParameter</code>.</p> 
    <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;">
     <table border="0" summary="Note">
      <tbody>
       <tr>
        <td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Framework Reference Documentation_files/note.png" /></td>
        <th align="left">Note</th>
       </tr>
       <tr>
        <td align="left" valign="top"> <p>Explicit declarations are necessary if the database you use is not a Spring-supported database. Currently Spring supports metadata lookup of stored procedure calls for the following databases: Apache Derby, DB2, MySQL, Microsoft SQL Server, Oracle, and Sybase. We also support metadata lookup of stored functions for: MySQL, Microsoft SQL Server, and Oracle.</p> </td>
       </tr>
      </tbody>
     </table>
    </div> 
    <p>You can opt to declare one, some, or all the parameters explicitly. The parameter metadata is still used where you do not declare parameters explicitly. To bypass all processing of metadata lookups for potential parameters and only use the declared parameters, you call the method <code class="literal">withoutProcedureColumnMetaDataAccess</code> as part of the declaration. Suppose that you have two or more different call signatures declared for a database function. In this case you call the <code class="literal">useInParameterNames</code> to specify the list of IN parameter names to include for a given signature.</p> 
    <p>The following example shows a fully declared procedure call, using the information from the preceding example.</p> 
    <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> JdbcActorDao <span class="hl-keyword">implements</span> ActorDao {

    <span class="hl-keyword">private</span> SimpleJdbcCall procReadActor;

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setDataSource(DataSource dataSource) {
        JdbcTemplate jdbcTemplate = <span class="hl-keyword">new</span> JdbcTemplate(dataSource);
        jdbcTemplate.setResultsMapCaseInsensitive(true);
        <span class="hl-keyword">this</span>.procReadActor = <span class="hl-keyword">new</span> SimpleJdbcCall(jdbcTemplate)
                .withProcedureName(<span class="hl-string">&quot;read_actor&quot;</span>)
                .withoutProcedureColumnMetaDataAccess()
                .useInParameterNames(<span class="hl-string">&quot;in_id&quot;</span>)
                .declareParameters(
                        <span class="hl-keyword">new</span> SqlParameter(<span class="hl-string">&quot;in_id&quot;</span>, Types.NUMERIC),
                        <span class="hl-keyword">new</span> SqlOutParameter(<span class="hl-string">&quot;out_first_name&quot;</span>, Types.VARCHAR),
                        <span class="hl-keyword">new</span> SqlOutParameter(<span class="hl-string">&quot;out_last_name&quot;</span>, Types.VARCHAR),
                        <span class="hl-keyword">new</span> SqlOutParameter(<span class="hl-string">&quot;out_birth_date&quot;</span>, Types.DATE)
                );
    }

    <span class="hl-comment">// ... additional methods</span>
}</pre> 
    <p>The execution and end results of the two examples are the same; this one specifies all details explicitly rather than relying on metadata.</p> 
   </div> 
   <div class="section" title="13.5.7&nbsp;How to define SqlParameters">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="jdbc-params"></a>13.5.7&nbsp;How to define SqlParameters</h3>
      </div>
     </div>
    </div> 
    <p>To define a parameter for the SimpleJdbc classes and also for the RDBMS operations classes, covered in <a class="xref" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#jdbc-object" title="13.6&nbsp;Modeling JDBC operations as Java objects">Section&nbsp;13.6, Modeling JDBC operations as Java objects</a>, you use an <code class="literal">SqlParameter</code> or one of its subclasses. You typically specify the parameter name and SQL type in the constructor. The SQL type is specified using the <code class="literal">java.sql.Types</code> constants. We have already seen declarations like:</p> 
    <pre class="programlisting"><span class="hl-keyword">new</span> SqlParameter(<span class="hl-string">&quot;in_id&quot;</span>, Types.NUMERIC),
    <span class="hl-keyword">new</span> SqlOutParameter(<span class="hl-string">&quot;out_first_name&quot;</span>, Types.VARCHAR),</pre> 
    <p>The first line with the <code class="literal">SqlParameter</code> declares an IN parameter. IN parameters can be used for both stored procedure calls and for queries using the <code class="literal">SqlQuery</code> and its subclasses covered in the following section.</p> 
    <p>The second line with the <code class="literal">SqlOutParameter</code> declares an <code class="literal">out</code> parameter to be used in a stored procedure call. There is also an <code class="literal">SqlInOutParameter</code> for <code class="literal">InOut</code> parameters, parameters that provide an <code class="literal">IN</code> value to the procedure and that also return a value.</p> 
    <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;">
     <table border="0" summary="Note">
      <tbody>
       <tr>
        <td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Framework Reference Documentation_files/note.png" /></td>
        <th align="left">Note</th>
       </tr>
       <tr>
        <td align="left" valign="top"> <p>Only parameters declared as <code class="literal">SqlParameter</code> and <code class="literal">SqlInOutParameter</code> will be used to provide input values. This is different from the <code class="literal">StoredProcedure</code> class, which for backwards compatibility reasons allows input values to be provided for parameters declared as <code class="literal">SqlOutParameter</code>.</p> </td>
       </tr>
      </tbody>
     </table>
    </div> 
    <p>For IN parameters, in addition to the name and the SQL type, you can specify a scale for numeric data or a type name for custom database types. For <code class="literal">out</code> parameters, you can provide a <code class="literal">RowMapper</code> to handle mapping of rows returned from a <code class="literal">REF</code> cursor. Another option is to specify an <code class="literal">SqlReturnType</code> that provides an opportunity to define customized handling of the return values.</p> 
   </div> 
   <div class="section" title="13.5.8&nbsp;Calling a stored function using SimpleJdbcCall">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="jdbc-simple-jdbc-call-3"></a>13.5.8&nbsp;Calling a stored function using SimpleJdbcCall</h3>
      </div>
     </div>
    </div> 
    <p>You call a stored function in almost the same way as you call a stored procedure, except that you provide a function name rather than a procedure name. You use the <code class="literal">withFunctionName</code> method as part of the configuration to indicate that we want to make a call to a function, and the corresponding string for a function call is generated. A specialized execute call, <code class="literal">executeFunction,</code> is used to execute the function and it returns the function return value as an object of a specified type, which means you do not have to retrieve the return value from the results map. A similar convenience method named <code class="literal">executeObject</code> is also available for stored procedures that only have one <code class="literal">out</code> parameter. The following example is based on a stored function named <code class="literal">get_actor_name</code> that returns an actors full name. Here is the MySQL source for this function:</p> 
    <pre class="programlisting">CREATE FUNCTION get_actor_name (in_id INTEGER)
RETURNS VARCHAR(200) READS SQL DATA
BEGIN
    DECLARE out_name VARCHAR(200);
    SELECT concat(first_name, ' ', last_name)
        INTO out_name
        FROM t_actor where id = in_id;
    RETURN out_name;
END;</pre> 
    <p>To call this function we again create a <code class="literal">SimpleJdbcCall</code> in the initialization method.</p> 
    <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> JdbcActorDao <span class="hl-keyword">implements</span> ActorDao {

    <span class="hl-keyword">private</span> JdbcTemplate jdbcTemplate;
    <span class="hl-keyword">private</span> SimpleJdbcCall funcGetActorName;

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setDataSource(DataSource dataSource) {
        <span class="hl-keyword">this</span>.jdbcTemplate = <span class="hl-keyword">new</span> JdbcTemplate(dataSource);
        JdbcTemplate jdbcTemplate = <span class="hl-keyword">new</span> JdbcTemplate(dataSource);
        jdbcTemplate.setResultsMapCaseInsensitive(true);
        <span class="hl-keyword">this</span>.funcGetActorName = <span class="hl-keyword">new</span> SimpleJdbcCall(jdbcTemplate)
                .withFunctionName(<span class="hl-string">&quot;get_actor_name&quot;</span>);
    }

    <span class="hl-keyword">public</span> String getActorName(Long id) {
        SqlParameterSource in = <span class="hl-keyword">new</span> MapSqlParameterSource()
                .addValue(<span class="hl-string">&quot;in_id&quot;</span>, id);
        String name = funcGetActorName.executeFunction(String.<span class="hl-keyword">class</span>, in);
        <span class="hl-keyword">return</span> name;
    }

    <span class="hl-comment">// ... additional methods</span>

}</pre> 
    <p>The execute method used returns a <code class="literal">String</code> containing the return value from the function call.</p> 
   </div> 
   <div class="section" title="13.5.9&nbsp;Returning ResultSet/REF Cursor from a SimpleJdbcCall">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="jdbc-simple-jdbc-call-4"></a>13.5.9&nbsp;Returning ResultSet/REF Cursor from a SimpleJdbcCall</h3>
      </div>
     </div>
    </div> 
    <p>Calling a stored procedure or function that returns a result set is a bit tricky. Some databases return result sets during the JDBC results processing while others require an explicitly registered <code class="literal">out</code> parameter of a specific type. Both approaches need additional processing to loop over the result set and process the returned rows. With the <code class="literal">SimpleJdbcCall</code> you use the <code class="literal">returningResultSet</code> method and declare a <code class="literal">RowMapper</code> implementation to be used for a specific parameter. In the case where the result set is returned during the results processing, there are no names defined, so the returned results will have to match the order in which you declare the <code class="literal">RowMapper</code> implementations. The name specified is still used to store the processed list of results in the results map that is returned from the execute statement.</p> 
    <p>The next example uses a stored procedure that takes no IN parameters and returns all rows from the t_actor table. Here is the MySQL source for this procedure:</p> 
    <pre class="programlisting">CREATE PROCEDURE read_all_actors()
BEGIN
 SELECT a.id, a.first_name, a.last_name, a.birth_date FROM t_actor a;
END;</pre> 
    <p>To call this procedure you declare the <code class="literal">RowMapper</code>. Because the class you want to map to follows the JavaBean rules, you can use a <code class="literal">ParameterizedBeanPropertyRowMapper</code> that is created by passing in the required class to map to in the <code class="literal">newInstance</code> method.</p> 
    <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> JdbcActorDao <span class="hl-keyword">implements</span> ActorDao {

    <span class="hl-keyword">private</span> SimpleJdbcCall procReadAllActors;

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setDataSource(DataSource dataSource) {
        JdbcTemplate jdbcTemplate = <span class="hl-keyword">new</span> JdbcTemplate(dataSource);
        jdbcTemplate.setResultsMapCaseInsensitive(true);
        <span class="hl-keyword">this</span>.procReadAllActors = <span class="hl-keyword">new</span> SimpleJdbcCall(jdbcTemplate)
                .withProcedureName(<span class="hl-string">&quot;read_all_actors&quot;</span>)
                .returningResultSet(<span class="hl-string">&quot;actors&quot;</span>,
                ParameterizedBeanPropertyRowMapper.newInstance(Actor.<span class="hl-keyword">class</span>));
    }

    <span class="hl-keyword">public</span> List getActorsList() {
        Map m = procReadAllActors.execute(<span class="hl-keyword">new</span> HashMap&lt;String, Object&gt;(<span class="hl-number">0</span>));
        <span class="hl-keyword">return</span> (List) m.get(<span class="hl-string">&quot;actors&quot;</span>);
    }

    <span class="hl-comment">// ... additional methods</span>

}</pre> 
    <p>The execute call passes in an empty Map because this call does not take any parameters. The list of Actors is then retrieved from the results map and returned to the caller.</p> 
   </div> 
  </div> 
  <div class="section" title="13.6&nbsp;Modeling JDBC operations as Java objects">
   <div class="titlepage">
    <div>
     <div>
      <h2 class="title" style="clear: both"><a name="jdbc-object"></a>13.6&nbsp;Modeling JDBC operations as Java objects</h2>
     </div>
    </div>
   </div> 
   <p>The <code class="literal">org.springframework.jdbc.object</code> package contains classes that allow you to access the database in a more object-oriented manner. As an example, you can execute queries and get the results back as a list containing business objects with the relational column data mapped to the properties of the business object. You can also execute stored procedures and run update, delete, and insert statements.</p> 
   <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;">
    <table border="0" summary="Note">
     <tbody>
      <tr>
       <td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Framework Reference Documentation_files/note.png" /></td>
       <th align="left">Note</th>
      </tr>
      <tr>
       <td align="left" valign="top"> <p>Many Spring developers believe that the various RDBMS operation classes described below (with the exception of the <a class="link" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#jdbc-StoredProcedure" title="13.6.4&nbsp;StoredProcedure"><code class="literal">StoredProcedure</code></a> class) can often be replaced with straight <code class="literal">JdbcTemplate</code> calls. Often it is simpler to write a DAO method that simply calls a method on a <code class="literal">JdbcTemplate</code> directly (as opposed to encapsulating a query as a full-blown class).</p> <p>However, if you are getting measurable value from using the RDBMS operation classes, continue using these classes.</p> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <div class="section" title="13.6.1&nbsp;SqlQuery">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="jdbc-SqlQuery"></a>13.6.1&nbsp;SqlQuery</h3>
      </div>
     </div>
    </div> 
    <p><code class="literal">SqlQuery</code> is a reusable, threadsafe class that encapsulates an SQL query. Subclasses must implement the <code class="literal">newRowMapper(..)</code> method to provide a <code class="literal">RowMapper</code> instance that can create one object per row obtained from iterating over the <code class="literal">ResultSet</code> that is created during the execution of the query. The <code class="literal">SqlQuery</code> class is rarely used directly because the <code class="literal">MappingSqlQuery</code> subclass provides a much more convenient implementation for mapping rows to Java classes. Other implementations that extend <code class="literal">SqlQuery</code> are <code class="literal">MappingSqlQueryWithParameters</code> and <code class="literal">UpdatableSqlQuery</code>.</p> 
   </div> 
   <div class="section" title="13.6.2&nbsp;MappingSqlQuery">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="jdbc-MappingSqlQuery"></a>13.6.2&nbsp;MappingSqlQuery</h3>
      </div>
     </div>
    </div> 
    <p><code class="literal">MappingSqlQuery</code> is a reusable query in which concrete subclasses must implement the abstract <code class="literal">mapRow(..)</code> method to convert each row of the supplied <code class="literal">ResultSet</code> into an object of the type specified. The following example shows a custom query that maps the data from the <code class="literal">t_actor</code> relation to an instance of the <code class="literal">Actor</code> class.</p> 
    <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ActorMappingQuery <span class="hl-keyword">extends</span> MappingSqlQuery&lt;Actor&gt; {

    <span class="hl-keyword">public</span> ActorMappingQuery(DataSource ds) {
        <span class="hl-keyword">super</span>(ds, <span class="hl-string">&quot;select id, first_name, last_name from t_actor where id = ?&quot;</span>);
        <span class="hl-keyword">super</span>.declareParameter(<span class="hl-keyword">new</span> SqlParameter(<span class="hl-string">&quot;id&quot;</span>, Types.INTEGER));
        compile();
    }

    <i><span class="hl-annotation" style="color: gray">@Override</span></i>
    <span class="hl-keyword">protected</span> Actor mapRow(ResultSet rs, <span class="hl-keyword">int</span> rowNumber) <span class="hl-keyword">throws</span> SQLException {
        Actor actor = <span class="hl-keyword">new</span> Actor();
        actor.setId(rs.getLong(<span class="hl-string">&quot;id&quot;</span>));
        actor.setFirstName(rs.getString(<span class="hl-string">&quot;first_name&quot;</span>));
        actor.setLastName(rs.getString(<span class="hl-string">&quot;last_name&quot;</span>));
        <span class="hl-keyword">return</span> actor;
    }

}</pre> 
    <p>The class extends <code class="literal">MappingSqlQuery</code> parameterized with the <code class="literal">Actor</code> type. The constructor for this customer query takes the <code class="literal">DataSource</code> as the only parameter. In this constructor you call the constructor on the superclass with the <code class="literal">DataSource</code> and the SQL that should be executed to retrieve the rows for this query. This SQL will be used to create a <code class="literal">PreparedStatement</code> so it may contain place holders for any parameters to be passed in during execution.You must declare each parameter using the <code class="literal">declareParameter</code> method passing in an <code class="literal">SqlParameter</code>. The <code class="literal">SqlParameter</code> takes a name and the JDBC type as defined in <code class="literal">java.sql.Types</code>. After you define all parameters, you call the <code class="literal">compile()</code> method so the statement can be prepared and later executed. This class is thread-safe after it is compiled, so as long as these instances are created when the DAO is initialized they can be kept as instance variables and be reused.</p> 
    <pre class="programlisting"><span class="hl-keyword">private</span> ActorMappingQuery actorMappingQuery;

<i><span class="hl-annotation" style="color: gray">@Autowired</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setDataSource(DataSource dataSource) {
    <span class="hl-keyword">this</span>.actorMappingQuery = <span class="hl-keyword">new</span> ActorMappingQuery(dataSource);
}

<span class="hl-keyword">public</span> Customer getCustomer(Long id) {
    <span class="hl-keyword">return</span> actorMappingQuery.findObject(id);
}</pre> 
    <p>The method in this example retrieves the customer with the id that is passed in as the only parameter. Since we only want one object returned we simply call the convenience method <code class="literal">findObject</code> with the id as parameter. If we had instead a query that returned a list of objects and took additional parameters then we would use one of the execute methods that takes an array of parameter values passed in as varargs.</p> 
    <pre class="programlisting"><span class="hl-keyword">public</span> List&lt;Actor&gt; searchForActors(<span class="hl-keyword">int</span> age, String namePattern) {
    List&lt;Actor&gt; actors = actorSearchMappingQuery.execute(age, namePattern);
    <span class="hl-keyword">return</span> actors;
}</pre> 
   </div> 
   <div class="section" title="13.6.3&nbsp;SqlUpdate">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="jdbc-SqlUpdate"></a>13.6.3&nbsp;SqlUpdate</h3>
      </div>
     </div>
    </div> 
    <p>The <code class="literal">SqlUpdate</code> class encapsulates an SQL update. Like a query, an update object is reusable, and like all <code class="literal">RdbmsOperation</code> classes, an update can have parameters and is defined in SQL. This class provides a number of <code class="literal">update(..)</code> methods analogous to the <code class="literal">execute(..)</code> methods of query objects. The <code class="literal">SQLUpdate</code> class is concrete. It can be subclassed, for example, to add a custom update method, as in the following snippet where its simply called <code class="literal">execute</code>. However, you dont have to subclass the <code class="literal">SqlUpdate</code> class since it can easily be parameterized by setting SQL and declaring parameters.</p> 
    <pre class="programlisting"><span class="hl-keyword">import</span> java.sql.Types;

<span class="hl-keyword">import</span> javax.sql.DataSource;

<span class="hl-keyword">import</span> org.springframework.jdbc.core.SqlParameter;
<span class="hl-keyword">import</span> org.springframework.jdbc.object.SqlUpdate;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> UpdateCreditRating <span class="hl-keyword">extends</span> SqlUpdate {

    <span class="hl-keyword">public</span> UpdateCreditRating(DataSource ds) {
        setDataSource(ds);
        setSql(<span class="hl-string">&quot;update customer set credit_rating = ? where id = ?&quot;</span>);
        declareParameter(<span class="hl-keyword">new</span> SqlParameter(<span class="hl-string">&quot;creditRating&quot;</span>, Types.NUMERIC));
        declareParameter(<span class="hl-keyword">new</span> SqlParameter(<span class="hl-string">&quot;id&quot;</span>, Types.NUMERIC));
        compile();
    }

    <b class="hl-tag" style="color: blue">/**
     * @param id for the Customer to be updated
     * @param rating the new value for credit rating
     * @return number of rows updated
     */</b>
    <span class="hl-keyword">public</span> <span class="hl-keyword">int</span> execute(<span class="hl-keyword">int</span> id, <span class="hl-keyword">int</span> rating) {
        <span class="hl-keyword">return</span> update(rating, id);
    }
}</pre> 
   </div> 
   <div class="section" title="13.6.4&nbsp;StoredProcedure">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="jdbc-StoredProcedure"></a>13.6.4&nbsp;StoredProcedure</h3>
      </div>
     </div>
    </div> 
    <p>The <code class="literal">StoredProcedure</code> class is a superclass for object abstractions of RDBMS stored procedures. This class is <code class="literal">abstract</code>, and its various <code class="literal">execute(..)</code> methods have <code class="literal">protected</code> access, preventing use other than through a subclass that offers tighter typing.</p> 
    <p>The inherited <code class="literal">sql</code> property will be the name of the stored procedure in the RDBMS.</p> 
    <p>To define a parameter for the <code class="literal">StoredProcedure</code> class, you use an <code class="literal">SqlParameter</code> or one of its subclasses. You must specify the parameter name and SQL type in the constructor like in the following code snippet. The SQL type is specified using the <code class="literal">java.sql.Types</code> constants.</p> 
    <pre class="programlisting"><span class="hl-keyword">new</span> SqlParameter(<span class="hl-string">&quot;in_id&quot;</span>, Types.NUMERIC),
    <span class="hl-keyword">new</span> SqlOutParameter(<span class="hl-string">&quot;out_first_name&quot;</span>, Types.VARCHAR),</pre> 
    <p>The first line with the <code class="literal">SqlParameter</code> declares an IN parameter. IN parameters can be used for both stored procedure calls and for queries using the <code class="literal">SqlQuery</code> and its subclasses covered in the following section.</p> 
    <p>The second line with the <code class="literal">SqlOutParameter</code> declares an <code class="literal">out</code> parameter to be used in the stored procedure call. There is also an <code class="literal">SqlInOutParameter</code> for <code class="literal">I</code> <code class="literal">nOut</code> parameters, parameters that provide an <code class="literal">in</code> value to the procedure and that also return a value.</p> 
    <p>For <code class="literal">i</code> <code class="literal">n</code> parameters, in addition to the name and the SQL type, you can specify a scale for numeric data or a type name for custom database types. For <code class="literal">out</code> parameters you can provide a <code class="literal">RowMapper</code> to handle mapping of rows returned from a REF cursor. Another option is to specify an <code class="literal">SqlReturnType</code> that enables you to define customized handling of the return values.</p> 
    <p>Here is an example of a simple DAO that uses a <code class="literal">StoredProcedure</code> to call a function, <code class="literal">sysdate()</code>,which comes with any Oracle database. To use the stored procedure functionality you have to create a class that extends <code class="literal">StoredProcedure</code>. In this example, the <code class="literal">StoredProcedure</code> class is an inner class, but if you need to reuse the <code class="literal">StoredProcedure</code> you declare it as a top-level class. This example has no input parameters, but an output parameter is declared as a date type using the class <code class="literal">SqlOutParameter</code>. The <code class="literal">execute()</code> method executes the procedure and extracts the returned date from the results <code class="literal">Map</code>. The results <code class="literal">Map</code> has an entry for each declared output parameter, in this case only one, using the parameter name as the key.</p> 
    <pre class="programlisting"><span class="hl-keyword">import</span> java.sql.Types;
<span class="hl-keyword">import</span> java.util.Date;
<span class="hl-keyword">import</span> java.util.HashMap;
<span class="hl-keyword">import</span> java.util.Map;

<span class="hl-keyword">import</span> javax.sql.DataSource;

<span class="hl-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;
<span class="hl-keyword">import</span> org.springframework.jdbc.core.SqlOutParameter;
<span class="hl-keyword">import</span> org.springframework.jdbc.object.StoredProcedure;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> StoredProcedureDao {

    <span class="hl-keyword">private</span> GetSysdateProcedure getSysdate;

    <i><span class="hl-annotation" style="color: gray">@Autowired</span></i>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> init(DataSource dataSource) {
        <span class="hl-keyword">this</span>.getSysdate = <span class="hl-keyword">new</span> GetSysdateProcedure(dataSource);
    }

    <span class="hl-keyword">public</span> Date getSysdate() {
        <span class="hl-keyword">return</span> getSysdate.execute();
    }

    <span class="hl-keyword">private</span> <span class="hl-keyword">class</span> GetSysdateProcedure <span class="hl-keyword">extends</span> StoredProcedure {

        <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> String SQL = <span class="hl-string">&quot;sysdate&quot;</span>;

        <span class="hl-keyword">public</span> GetSysdateProcedure(DataSource dataSource) {
            setDataSource(dataSource);
            setFunction(true);
            setSql(SQL);
            declareParameter(<span class="hl-keyword">new</span> SqlOutParameter(<span class="hl-string">&quot;date&quot;</span>, Types.DATE));
            compile();
        }

        <span class="hl-keyword">public</span> Date execute() {
            <span class="hl-comment">// the </span><span class="emphasis"><em>sysdate</em></span> sproc has no input parameters, so an empty Map is supplied...
            Map&lt;String, Object&gt; results = execute(<span class="hl-keyword">new</span> HashMap&lt;String, Object&gt;());
            Date sysdate = (Date) results.get(<span class="hl-string">&quot;date&quot;</span>);
            <span class="hl-keyword">return</span> sysdate;
        }
    }

}</pre> 
    <p>The following example of a <code class="literal">StoredProcedure</code> has two output parameters (in this case, Oracle REF cursors).</p> 
    <pre class="programlisting"><span class="hl-keyword">import</span> oracle.jdbc.OracleTypes;
<span class="hl-keyword">import</span> org.springframework.jdbc.core.SqlOutParameter;
<span class="hl-keyword">import</span> org.springframework.jdbc.object.StoredProcedure;

<span class="hl-keyword">import</span> javax.sql.DataSource;
<span class="hl-keyword">import</span> java.util.HashMap;
<span class="hl-keyword">import</span> java.util.Map;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> TitlesAndGenresStoredProcedure <span class="hl-keyword">extends</span> StoredProcedure {

    <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> String SPROC_NAME = <span class="hl-string">&quot;AllTitlesAndGenres&quot;</span>;

    <span class="hl-keyword">public</span> TitlesAndGenresStoredProcedure(DataSource dataSource) {
        <span class="hl-keyword">super</span>(dataSource, SPROC_NAME);
        declareParameter(<span class="hl-keyword">new</span> SqlOutParameter(<span class="hl-string">&quot;titles&quot;</span>, OracleTypes.CURSOR, <span class="hl-keyword">new</span> TitleMapper()));
        declareParameter(<span class="hl-keyword">new</span> SqlOutParameter(<span class="hl-string">&quot;genres&quot;</span>, OracleTypes.CURSOR, <span class="hl-keyword">new</span> GenreMapper()));
        compile();
    }

    <span class="hl-keyword">public</span> Map&lt;String, Object&gt; execute() {
        <span class="hl-comment">// again, this sproc has no input parameters, so an empty Map is supplied</span>
        <span class="hl-keyword">return</span> <span class="hl-keyword">super</span>.execute(<span class="hl-keyword">new</span> HashMap&lt;String, Object&gt;());
    }
}</pre> 
    <p>Notice how the overloaded variants of the <code class="literal">declareParameter(..)</code> method that have been used in the <code class="literal">TitlesAndGenresStoredProcedure</code> constructor are passed <code class="literal">RowMapper</code> implementation instances; this is a very convenient and powerful way to reuse existing functionality. The code for the two <code class="literal">RowMapper</code> implementations is provided below.</p> 
    <p>The <code class="literal">TitleMapper</code> class maps a <code class="literal">ResultSet</code> to a <code class="literal">Title</code> domain object for each row in the supplied <code class="literal">ResultSet</code>:</p> 
    <pre class="programlisting"><span class="hl-keyword">import</span> org.springframework.jdbc.core.RowMapper;

<span class="hl-keyword">import</span> java.sql.ResultSet;
<span class="hl-keyword">import</span> java.sql.SQLException;

<span class="hl-keyword">import</span> com.foo.domain.Title;

<span class="hl-keyword">public</span> <span class="hl-keyword">final</span> <span class="hl-keyword">class</span> TitleMapper <span class="hl-keyword">implements</span> RowMapper&lt;Title&gt; {

    <span class="hl-keyword">public</span> Title mapRow(ResultSet rs, <span class="hl-keyword">int</span> rowNum) <span class="hl-keyword">throws</span> SQLException {
        Title title = <span class="hl-keyword">new</span> Title();
        title.setId(rs.getLong(<span class="hl-string">&quot;id&quot;</span>));
        title.setName(rs.getString(<span class="hl-string">&quot;name&quot;</span>));
        <span class="hl-keyword">return</span> title;
    }
}</pre> 
    <p>The <code class="literal">GenreMapper</code> class maps a <code class="literal">ResultSet</code> to a <code class="literal">Genre</code> domain object for each row in the supplied <code class="literal">ResultSet</code>.</p> 
    <pre class="programlisting"><span class="hl-keyword">import</span> org.springframework.jdbc.core.RowMapper;

<span class="hl-keyword">import</span> java.sql.ResultSet;
<span class="hl-keyword">import</span> java.sql.SQLException;

<span class="hl-keyword">import</span> com.foo.domain.Genre;

<span class="hl-keyword">public</span> <span class="hl-keyword">final</span> <span class="hl-keyword">class</span> GenreMapper <span class="hl-keyword">implements</span> RowMapper&lt;Genre&gt; {

    <span class="hl-keyword">public</span> Genre mapRow(ResultSet rs, <span class="hl-keyword">int</span> rowNum) <span class="hl-keyword">throws</span> SQLException {
        <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> Genre(rs.getString(<span class="hl-string">&quot;name&quot;</span>));
    }
}</pre> 
    <p>To pass parameters to a stored procedure that has one or more input parameters in its definition in the RDBMS, you can code a strongly typed <code class="literal">execute(..)</code> method that would delegate to the superclass' untyped <code class="literal">execute(Map parameters)</code> method (which has <code class="literal">protected</code> access); for example:</p> 
    <pre class="programlisting"><span class="hl-keyword">import</span> oracle.jdbc.OracleTypes;
<span class="hl-keyword">import</span> org.springframework.jdbc.core.SqlOutParameter;
<span class="hl-keyword">import</span> org.springframework.jdbc.core.SqlParameter;
<span class="hl-keyword">import</span> org.springframework.jdbc.object.StoredProcedure;

<span class="hl-keyword">import</span> javax.sql.DataSource;

<span class="hl-keyword">import</span> java.sql.Types;
<span class="hl-keyword">import</span> java.util.Date;
<span class="hl-keyword">import</span> java.util.HashMap;
<span class="hl-keyword">import</span> java.util.Map;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> TitlesAfterDateStoredProcedure <span class="hl-keyword">extends</span> StoredProcedure {

    <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> String SPROC_NAME = <span class="hl-string">&quot;TitlesAfterDate&quot;</span>;
    <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> String CUTOFF_DATE_PARAM = <span class="hl-string">&quot;cutoffDate&quot;</span>;

    <span class="hl-keyword">public</span> TitlesAfterDateStoredProcedure(DataSource dataSource) {
        <span class="hl-keyword">super</span>(dataSource, SPROC_NAME);
        declareParameter(<span class="hl-keyword">new</span> SqlParameter(CUTOFF_DATE_PARAM, Types.DATE);
        declareParameter(<span class="hl-keyword">new</span> SqlOutParameter(<span class="hl-string">&quot;titles&quot;</span>, OracleTypes.CURSOR, <span class="hl-keyword">new</span> TitleMapper()));
        compile();
    }

    <span class="hl-keyword">public</span> Map&lt;String, Object&gt; execute(Date cutoffDate) {
        Map&lt;String, Object&gt; inputs = <span class="hl-keyword">new</span> HashMap&lt;String, Object&gt;();
        inputs.put(CUTOFF_DATE_PARAM, cutoffDate);
        <span class="hl-keyword">return</span> <span class="hl-keyword">super</span>.execute(inputs);
    }
}</pre> 
   </div> 
  </div> 
  <div class="section" title="13.7&nbsp;Common problems with parameter and data value handling">
   <div class="titlepage">
    <div>
     <div>
      <h2 class="title" style="clear: both"><a name="jdbc-parameter-handling"></a>13.7&nbsp;Common problems with parameter and data value handling</h2>
     </div>
    </div>
   </div> 
   <p>Common problems with parameters and data values exist in the different approaches provided by the Spring Framework JDBC.</p> 
   <div class="section" title="13.7.1&nbsp;Providing SQL type information for parameters">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="jdbc-type-information"></a>13.7.1&nbsp;Providing SQL type information for parameters</h3>
      </div>
     </div>
    </div> 
    <p>Usually Spring determines the SQL type of the parameters based on the type of parameter passed in. It is possible to explicitly provide the SQL type to be used when setting parameter values. This is sometimes necessary to correctly set NULL values.</p> 
    <p>You can provide SQL type information in several ways:</p> 
    <div class="itemizedlist">
     <ul class="itemizedlist" type="disc">
      <li class="listitem"> Many update and query methods of the <code class="literal">JdbcTemplate</code> take an additional parameter in the form of an <code class="literal">int</code> array. This array is used to indicate the SQL type of the corresponding parameter using constant values from the <code class="literal">java.sql.Types</code> class. Provide one entry for each parameter. </li>
      <li class="listitem"> You can use the <code class="literal">SqlParameterValue</code> class to wrap the parameter value that needs this additional information.Create a new instance for each value and pass in the SQL type and parameter value in the constructor. You can also provide an optional scale parameter for numeric values. </li>
      <li class="listitem"> For methods working with named parameters, use the <code class="literal">SqlParameterSource</code> classes <code class="literal">BeanPropertySqlParameterSource</code> or <code class="literal">MapSqlParameterSource</code>. They both have methods for registering the SQL type for any of the named parameter values. </li>
     </ul>
    </div> 
   </div> 
   <div class="section" title="13.7.2&nbsp;Handling BLOB and CLOB objects">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="jdbc-lob"></a>13.7.2&nbsp;Handling BLOB and CLOB objects</h3>
      </div>
     </div>
    </div> 
    <p>You can store images, other binary objects, and large chunks of text. These large object are called BLOB for binary data and CLOB for character data. In Spring you can handle these large objects by using the JdbcTemplate directly and also when using the higher abstractions provided by RDBMS Objects and the <code class="literal">SimpleJdbc</code> classes. All of these approaches use an implementation of the <code class="literal">LobHandler</code> interface for the actual management of the LOB data. The <code class="literal">LobHandler</code> provides access to a <code class="literal">LobCreator</code> class, through the <code class="literal">getLobCreator</code> method, used for creating new LOB objects to be inserted.</p> 
    <p>The <code class="literal">LobCreator/LobHandler</code> provides the following support for LOB input and output:</p> 
    <div class="itemizedlist">
     <ul class="itemizedlist" type="disc">
      <li class="listitem"> BLOB </li>
      <li class="listitem"> byte[]&#x2009;&#x2009;getBlobAsBytes and setBlobAsBytes </li>
      <li class="listitem"> InputStream&#x2009;&#x2009;getBlobAsBinaryStream and setBlobAsBinaryStream </li>
      <li class="listitem"> CLOB </li>
      <li class="listitem"> String&#x2009;&#x2009;getClobAsString and setClobAsString </li>
      <li class="listitem"> InputStream&#x2009;&#x2009;getClobAsAsciiStream and setClobAsAsciiStream </li>
      <li class="listitem"> Reader&#x2009;&#x2009;getClobAsCharacterStream and setClobAsCharacterStream </li>
     </ul>
    </div> 
    <p>The next example shows how to create and insert a BLOB. Later you will see how to read it back from the database.</p> 
    <p>This example uses a <code class="literal">JdbcTemplate</code> and an implementation of the <code class="literal">AbstractLobCreatingPreparedStatementCallbac</code> <code class="literal">k</code>. It implements one method, <code class="literal">setValues</code>. This method provides a <code class="literal">LobCreator</code> that you use to set the values for the LOB columns in your SQL insert statement.</p> 
    <p>For this example we assume that there is a variable, <code class="literal">lobHandle</code> <code class="literal">r</code>, that already is set to an instance of a <code class="literal">DefaultLobHandler</code>. You typically set this value through dependency injection.</p> 
    <pre class="programlisting"><span class="hl-keyword">final</span> File blobIn = <span class="hl-keyword">new</span> File(<span class="hl-string">&quot;spring2004.jpg&quot;</span>);
<span class="hl-keyword">final</span> InputStream blobIs = <span class="hl-keyword">new</span> FileInputStream(blobIn);
<span class="hl-keyword">final</span> File clobIn = <span class="hl-keyword">new</span> File(<span class="hl-string">&quot;large.txt&quot;</span>);
<span class="hl-keyword">final</span> InputStream clobIs = <span class="hl-keyword">new</span> FileInputStream(clobIn);
<span class="hl-keyword">final</span> InputStreamReader clobReader = <span class="hl-keyword">new</span> InputStreamReader(clobIs);
jdbcTemplate.execute(
    <span class="hl-string">&quot;INSERT INTO lob_table (id, a_clob, a_blob) VALUES (?, ?, ?)&quot;</span>,
    <span class="hl-keyword">new</span> AbstractLobCreatingPreparedStatementCallback(lobHandler) { &lt;&lt;<span class="hl-number">1</span>&gt;&gt;
<span class="hl-keyword">protected</span> <span class="hl-keyword">void</span> setValues(PreparedStatement ps, LobCreator lobCreator) <span class="hl-keyword">throws</span> SQLException { ps.setLong(<span class="hl-number">1</span>, <span class="hl-number">1L</span>); lobCreator.setClobAsCharacterStream(ps, <span class="hl-number">2</span>, clobReader, (<span class="hl-keyword">int</span>)clobIn.length()); &lt;&lt;<span class="hl-number">2</span>&gt;&gt;
lobCreator.setBlobAsBinaryStream(ps, <span class="hl-number">3</span>, blobIs, (<span class="hl-keyword">int</span>)blobIn.length()); &lt;&lt;<span class="hl-number">3</span>&gt;&gt;
} }
);
blobIs.close();
clobReader.close();</pre> 
    <p><a class="xref" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#">???</a> Pass in the lobHandler that in this example is a plain <code class="literal">DefaultLobHandler</code></p> 
    <p><a class="xref" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#">???</a> Using the method <code class="literal">setClobAsCharacterStream</code>, pass in the contents of the CLOB.</p> 
    <p><a class="xref" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#">???</a> Using the method <code class="literal">setBlobAsBinaryStream</code>, pass in the contents of the BLOB.</p> 
    <p>Now its time to read the LOB data from the database. Again, you use a <code class="literal">JdbcTemplate</code> with the same instance variable <code class="literal">l</code> <code class="literal">obHandler</code> and a reference to a <code class="literal">DefaultLobHandler</code>.</p> 
    <pre class="programlisting">List&lt;Map&lt;String, Object&gt;&gt; l = jdbcTemplate.query(<span class="hl-string">&quot;select id, a_clob, a_blob from lob_table&quot;</span>,
    <span class="hl-keyword">new</span> RowMapper&lt;Map&lt;String, Object&gt;&gt;() {
        <span class="hl-keyword">public</span> Map&lt;String, Object&gt; mapRow(ResultSet rs, <span class="hl-keyword">int</span> i) <span class="hl-keyword">throws</span> SQLException {
            Map&lt;String, Object&gt; results = <span class="hl-keyword">new</span> HashMap&lt;String, Object&gt;();
            String clobText = lobHandler.getClobAsString(rs, <span class="hl-string">&quot;a_clob&quot;</span>); &lt;&lt;<span class="hl-number">1</span>&gt;&gt;
results.put(<span class="hl-string">&quot;CLOB&quot;</span>, clobText); <span class="hl-keyword">byte</span>[] blobBytes = lobHandler.getBlobAsBytes(rs, <span class="hl-string">&quot;a_blob&quot;</span>); &lt;&lt;<span class="hl-number">2</span>&gt;&gt;
results.put(<span class="hl-string">&quot;BLOB&quot;</span>, blobBytes); <span class="hl-keyword">return</span> results; } });</pre> 
    <p><a class="xref" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#">???</a> Using the method <code class="literal">getClobAsString</code>, retrieve the contents of the CLOB.</p> 
    <p><a class="xref" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#">???</a> Using the method <code class="literal">getBlobAsBytes</code>, retrieve the contents of the BLOB.</p> 
   </div> 
   <div class="section" title="13.7.3&nbsp;Passing in lists of values for IN clause">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="jdbc-in-clause"></a>13.7.3&nbsp;Passing in lists of values for IN clause</h3>
      </div>
     </div>
    </div> 
    <p>The SQL standard allows for selecting rows based on an expression that includes a variable list of values. A typical example would be <code class="literal">select * from T_ACTOR where id in (1, 2, 3)</code>. This variable list is not directly supported for prepared statements by the JDBC standard; you cannot declare a variable number of placeholders. You need a number of variations with the desired number of placeholders prepared, or you need to generate the SQL string dynamically once you know how many placeholders are required. The named parameter support provided in the <code class="literal">NamedParameterJdbcTemplate</code> and <code class="literal">JdbcTemplate</code> takes the latter approach. Pass in the values as a <code class="literal">java.util.List</code> of primitive objects. This list will be used to insert the required placeholders and pass in the values during the statement execution.</p> 
    <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;">
     <table border="0" summary="Note">
      <tbody>
       <tr>
        <td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Framework Reference Documentation_files/note.png" /></td>
        <th align="left">Note</th>
       </tr>
       <tr>
        <td align="left" valign="top"> <p>Be careful when passing in many values. The JDBC standard does not guarantee that you can use more than 100 values for an <code class="literal">in</code> expression list. Various databases exceed this number, but they usually have a hard limit for how many values are allowed. Oracles limit is 1000.</p> </td>
       </tr>
      </tbody>
     </table>
    </div> 
    <p>In addition to the primitive values in the value list, you can create a <code class="literal">java.util.List</code> of object arrays. This list would support multiple expressions defined for the <code class="literal">in</code> clause such as <code class="literal">select * from T_ACTOR where (id, last_name) in ((1, 'Johnson'), (2, 'Harrop'))</code>. This of course requires that your database supports this syntax.</p> 
   </div> 
   <div class="section" title="13.7.4&nbsp;Handling complex types for stored procedure calls">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="jdbc-complex-types"></a>13.7.4&nbsp;Handling complex types for stored procedure calls</h3>
      </div>
     </div>
    </div> 
    <p>When you call stored procedures you can sometimes use complex types specific to the database. To accommodate these types, Spring provides a <code class="literal">SqlReturnType</code> for handling them when they are returned from the stored procedure call and <code class="literal">SqlTypeValue</code> when they are passed in as a parameter to the stored procedure.</p> 
    <p>Here is an example of returning the value of an Oracle <code class="literal">STRUCT</code> object of the user declared type <code class="literal">ITEM_TYPE</code>. The <code class="literal">SqlReturnType</code> interface has a single method named <code class="literal">getTypeValue</code> that must be implemented. This interface is used as part of the declaration of an <code class="literal">SqlOutParameter</code>.</p> 
    <pre class="programlisting"><span class="hl-keyword">final</span> TestItem = <span class="hl-keyword">new</span> TestItem(<span class="hl-number">123L</span>, <span class="hl-string">&quot;A test item&quot;</span>,
        <span class="hl-keyword">new</span> SimpleDateFormat(<span class="hl-string">&quot;yyyy-M-d&quot;</span>).parse(<span class="hl-string">&quot;2010-12-31&quot;</span>));

declareParameter(<span class="hl-keyword">new</span> SqlOutParameter(<span class="hl-string">&quot;item&quot;</span>, OracleTypes.STRUCT, <span class="hl-string">&quot;ITEM_TYPE&quot;</span>,
    <span class="hl-keyword">new</span> SqlReturnType() {
        <span class="hl-keyword">public</span> Object getTypeValue(CallableStatement cs, <span class="hl-keyword">int</span> colIndx, <span class="hl-keyword">int</span> sqlType, String typeName) <span class="hl-keyword">throws</span> SQLException {
            STRUCT struct = (STRUCT) cs.getObject(colIndx);
            Object[] attr = struct.getAttributes();
            TestItem item = <span class="hl-keyword">new</span> TestItem();
            item.setId(((Number) attr[<span class="hl-number">0</span>]).longValue());
            item.setDescription((String) attr[<span class="hl-number">1</span>]);
            item.setExpirationDate((java.util.Date) attr[<span class="hl-number">2</span>]);
            <span class="hl-keyword">return</span> item;
        }
    }));</pre> 
    <p>You use the <code class="literal">SqlTypeValue</code> to pass in the value of a Java object like <code class="literal">TestItem</code> into a stored procedure. The <code class="literal">SqlTypeValue</code> interface has a single method named <code class="literal">createTypeValue</code> that you must implement. The active connection is passed in, and you can use it to create database-specific objects such as <code class="literal">StructDescriptor</code> s, as shown in the following example, or <code class="literal">ArrayDescriptor</code> s.</p> 
    <pre class="programlisting"><span class="hl-keyword">final</span> TestItem = <span class="hl-keyword">new</span> TestItem(<span class="hl-number">123L</span>, <span class="hl-string">&quot;A test item&quot;</span>,
        <span class="hl-keyword">new</span> SimpleDateFormat(<span class="hl-string">&quot;yyyy-M-d&quot;</span>).parse(<span class="hl-string">&quot;2010-12-31&quot;</span>));

SqlTypeValue value = <span class="hl-keyword">new</span> AbstractSqlTypeValue() {
    <span class="hl-keyword">protected</span> Object createTypeValue(Connection conn, <span class="hl-keyword">int</span> sqlType, String typeName) <span class="hl-keyword">throws</span> SQLException {
        StructDescriptor itemDescriptor = <span class="hl-keyword">new</span> StructDescriptor(typeName, conn);
        Struct item = <span class="hl-keyword">new</span> STRUCT(itemDescriptor, conn,
        <span class="hl-keyword">new</span> Object[] {
            testItem.getId(),
            testItem.getDescription(),
            <span class="hl-keyword">new</span> java.sql.Date(testItem.getExpirationDate().getTime())
        });
        <span class="hl-keyword">return</span> item;
    }
};</pre> 
    <p>This <code class="literal">SqlTypeValue</code> can now be added to the Map containing the input parameters for the execute call of the stored procedure.</p> 
    <p>Another use for the <code class="literal">SqlTypeValue</code> is passing in an array of values to an Oracle stored procedure. Oracle has its own internal <code class="literal">ARRAY</code> class that must be used in this case, and you can use the <code class="literal">SqlTypeValue</code> to create an instance of the Oracle <code class="literal">ARRAY</code> and populate it with values from the Java <code class="literal">ARRAY</code>.</p> 
    <pre class="programlisting"><span class="hl-keyword">final</span> Long[] ids = <span class="hl-keyword">new</span> Long[] {<span class="hl-number">1L</span>, <span class="hl-number">2L</span>};

SqlTypeValue value = <span class="hl-keyword">new</span> AbstractSqlTypeValue() {
    <span class="hl-keyword">protected</span> Object createTypeValue(Connection conn, <span class="hl-keyword">int</span> sqlType, String typeName) <span class="hl-keyword">throws</span> SQLException {
        ArrayDescriptor arrayDescriptor = <span class="hl-keyword">new</span> ArrayDescriptor(typeName, conn);
        ARRAY idArray = <span class="hl-keyword">new</span> ARRAY(arrayDescriptor, conn, ids);
        <span class="hl-keyword">return</span> idArray;
    }
};</pre> 
   </div> 
  </div> 
  <div class="section" title="13.8&nbsp;Embedded database support">
   <div class="titlepage">
    <div>
     <div>
      <h2 class="title" style="clear: both"><a name="jdbc-embedded-database-support"></a>13.8&nbsp;Embedded database support</h2>
     </div>
    </div>
   </div> 
   <p>The <code class="literal">org.springframework.jdbc.datasource.embedded</code> package provides support for embedded Java database engines. Support for <a class="ulink" href="http://www.hsqldb.org/" target="_top">HSQL</a>, <a class="ulink" href="http://www.h2database.com/" target="_top">H2</a>, and <a class="ulink" href="http://db.apache.org/derby" target="_top">Derby</a> is provided natively. You can also use an extensible API to plug in new embedded database types and <code class="literal">DataSource</code> implementations.</p> 
   <div class="section" title="13.8.1&nbsp;Why use an embedded database?">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="jdbc-why-embedded-database"></a>13.8.1&nbsp;Why use an embedded database?</h3>
      </div>
     </div>
    </div> 
    <p>An embedded database is useful during the development phase of a project because of its lightweight nature. Benefits include ease of configuration, quick startup time, testability, and the ability to rapidly evolve SQL during development.</p> 
   </div> 
   <div class="section" title="13.8.2&nbsp;Creating an embedded database instance using Spring XML">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="jdbc-embedded-database-xml"></a>13.8.2&nbsp;Creating an embedded database instance using Spring XML</h3>
      </div>
     </div>
    </div> 
    <p>If you want to expose an embedded database instance as a bean in a Spring ApplicationContext, use the embedded-database tag in the spring-jdbc namespace:</p> 
    <pre class="programlisting"><span class="hl-tag">&lt;jdbc:embedded-database</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;dataSource&quot;</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;jdbc:script</span> <span class="hl-attribute">location</span>=<span class="hl-value">&quot;classpath:schema.sql&quot;</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;jdbc:script</span> <span class="hl-attribute">location</span>=<span class="hl-value">&quot;classpath:test-data.sql&quot;</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/jdbc:embedded-database&gt;</span></pre> 
    <p>The preceding configuration creates an embedded HSQL database populated with SQL from schema.sql and testdata.sql resources in the classpath. The database instance is made available to the Spring container as a bean of type <code class="literal">javax.sql.DataSource</code>. This bean can then be injected into data access objects as needed.</p> 
   </div> 
   <div class="section" title="13.8.3&nbsp;Creating an embedded database instance programmatically">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="jdbc-embedded-database-java"></a>13.8.3&nbsp;Creating an embedded database instance programmatically</h3>
      </div>
     </div>
    </div> 
    <p>The <code class="literal">EmbeddedDatabaseBuilder</code> class provides a fluent API for constructing an embedded database programmatically. Use this when you need to create an embedded database instance in a standalone environment, such as a data access object unit test:</p> 
    <pre class="programlisting">EmbeddedDatabaseBuilder builder = <span class="hl-keyword">new</span> EmbeddedDatabaseBuilder();
EmbeddedDatabase db = builder.setType(H2).addScript(<span class="hl-string">&quot;my-schema.sql&quot;</span>).addScript(<span class="hl-string">&quot;my-test-data.sql&quot;</span>).build();
<span class="hl-comment">// do stuff against the db (EmbeddedDatabase extends javax.sql.DataSource)</span>
db.shutdown()</pre> 
   </div> 
   <div class="section" title="13.8.4&nbsp;Extending the embedded database support">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="jdbc-embedded-database-extension"></a>13.8.4&nbsp;Extending the embedded database support</h3>
      </div>
     </div>
    </div> 
    <p>Spring JDBC embedded database support can be extended in two ways:</p> 
    <div class="itemizedlist">
     <ul class="itemizedlist" type="disc">
      <li class="listitem"> Implement <code class="literal">EmbeddedDatabaseConfigurer</code> to support a new embedded database type, such as Apache Derby. </li>
      <li class="listitem"> Implement <code class="literal">DataSourceFactory</code> to support a new DataSource implementation, such as a connection pool, to manage embedded database connections. </li>
     </ul>
    </div> 
    <p>You are encouraged to contribute back extensions to the Spring community at jira.springframework.org[jira.springframework.org].</p> 
   </div> 
   <div class="section" title="13.8.5&nbsp;Using HSQL">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="jdbc-embedded-database-using-HSQL"></a>13.8.5&nbsp;Using HSQL</h3>
      </div>
     </div>
    </div> 
    <p>Spring supports HSQL 1.8.0 and above. HSQL is the default embedded database if no type is specified explicitly. To specify HSQL explicitly, set the <code class="literal">type</code> attribute of the <code class="literal">embedded-database</code> tag to <code class="literal">HSQL</code>. If you are using the builder API, call the <code class="literal">setType(EmbeddedDatabaseType)</code> method with <code class="literal">EmbeddedDatabaseType.HSQL</code>.</p> 
   </div> 
   <div class="section" title="13.8.6&nbsp;Using H2">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="jdbc-embedded-database-using-H2"></a>13.8.6&nbsp;Using H2</h3>
      </div>
     </div>
    </div> 
    <p>Spring supports the H2 database as well. To enable H2, set the <code class="literal">type</code> attribute of the <code class="literal">embedded-database</code> tag to <code class="literal">H2</code>. If you are using the builder API, call the <code class="literal">setType(EmbeddedDatabaseType)</code> method with <code class="literal">EmbeddedDatabaseType.H2</code>.</p> 
   </div> 
   <div class="section" title="13.8.7&nbsp;Using Derby">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="jdbc-embedded-database-using-Derby"></a>13.8.7&nbsp;Using Derby</h3>
      </div>
     </div>
    </div> 
    <p>Spring also supports Apache Derby 10.5 and above. To enable Derby, set the <code class="literal">type</code> attribute of the <code class="literal">embedded-database</code> tag to <code class="literal">Derby</code>. If using the builder API, call the <code class="literal">setType(EmbeddedDatabaseType)</code> method with <code class="literal">EmbeddedDatabaseType.Derby</code>.</p> 
   </div> 
   <div class="section" title="13.8.8&nbsp;Testing data access logic with an embedded database">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="jdbc-embedded-database-dao-testing"></a>13.8.8&nbsp;Testing data access logic with an embedded database</h3>
      </div>
     </div>
    </div> 
    <p>Embedded databases provide a lightweight way to test data access code. The following is a data access unit test template that uses an embedded database:</p> 
    <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> DataAccessUnitTestTemplate {

    <span class="hl-keyword">private</span> EmbeddedDatabase db;

    <i><span class="hl-annotation" style="color: gray">@Before</span></i>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setUp() {
        <span class="hl-comment">// creates an HSQL in-memory database populated from default scripts</span>
        <span class="hl-comment">// classpath:schema.sql and classpath:data.sql</span>
        db = <span class="hl-keyword">new</span> EmbeddedDatabaseBuilder().addDefaultScripts().build();
    }

    <i><span class="hl-annotation" style="color: gray">@Test</span></i>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> testDataAccess() {
        JdbcTemplate template = <span class="hl-keyword">new</span> JdbcTemplate(db);
        template.query(...);
    }

    <i><span class="hl-annotation" style="color: gray">@After</span></i>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> tearDown() {
        db.shutdown();
    }

}</pre> 
   </div> 
  </div> 
  <div class="section" title="13.9&nbsp;Initializing a DataSource">
   <div class="titlepage">
    <div>
     <div>
      <h2 class="title" style="clear: both"><a name="jdbc-intializing-datasource"></a>13.9&nbsp;Initializing a DataSource</h2>
     </div>
    </div>
   </div> 
   <p>The <code class="literal">org.springframework.jdbc.datasource.init</code> package provides support for initializing an existing <code class="literal">DataSource</code>. The embedded database support provides one option for creating and initializing a <code class="literal">DataSource</code> for an application, but sometimes you need to initialize an instance running on a server somewhere.</p> 
   <div class="section" title="13.9.1&nbsp;Initializing a database instance using Spring XML">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="jdbc-initializing-datasource-xml"></a>13.9.1&nbsp;Initializing a database instance using Spring XML</h3>
      </div>
     </div>
    </div> 
    <p>If you want to initialize a database and you can provide a reference to a DataSource bean, use the <code class="literal">initialize-database</code> tag in the <code class="literal">spring-jdbc</code> namespace:</p> 
    <pre class="programlisting"><span class="hl-tag">&lt;jdbc:initialize-database</span> <span class="hl-attribute">data-source</span>=<span class="hl-value">&quot;dataSource&quot;</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;jdbc:script</span> <span class="hl-attribute">location</span>=<span class="hl-value">&quot;classpath:com/foo/sql/db-schema.sql&quot;</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;jdbc:script</span> <span class="hl-attribute">location</span>=<span class="hl-value">&quot;classpath:com/foo/sql/db-test-data.sql&quot;</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/jdbc:initialize-database&gt;</span></pre> 
    <p>The example above runs the two scripts specified against the database: the first script is a schema creation, and the second is a test data set insert. The script locations can also be patterns with wildcards in the usual ant style used for resources in Spring (e.g. <code class="literal">classpath*:/com/foo/**/sql/*-data.sql</code>). If a pattern is used the scripts are executed in lexical order of their URL or filename.</p> 
    <p>The default behavior of the database initializer is to unconditionally execute the scripts provided. This will not always be what you want, for instance if running against an existing database that already has test data in it. The likelihood of accidentally deleting data is reduced by the commonest pattern (as shown above) that creates the tables first and then inserts the data - the first step will fail if the tables already exist.</p> 
    <p>However, to get more control over the creation and deletion of existing data, the XML namespace provides a couple more options. The first is flag to switch the initialization on and off. This can be set according to the environment (e.g. to pull a boolean value from system properties or an environment bean), e.g.</p> 
    <pre class="programlisting"><span class="hl-tag">&lt;jdbc:initialize-database</span> <span class="hl-attribute">data-source</span>=<span class="hl-value">&quot;dataSource&quot;</span>
    <span class="strong"><strong>enabled=&quot;#{systemProperties.INITIALIZE_DATABASE}&quot;</strong></span>&gt;
    <span class="hl-tag">&lt;jdbc:script</span> <span class="hl-attribute">location</span>=<span class="hl-value">&quot;...&quot;</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/jdbc:initialize-database&gt;</span></pre> 
    <p>The second option to control what happens with existing data is to be more tolerant of failures. To this end you can control the ability of the initializer to ignore certain errors in the SQL it executes from the scripts, e.g.</p> 
    <pre class="programlisting"><span class="hl-tag">&lt;jdbc:initialize-database</span> <span class="hl-attribute">data-source</span>=<span class="hl-value">&quot;dataSource&quot;</span> <span class="strong"><strong>ignore-failures=&quot;DROPS&quot;</strong></span>&gt;
    <span class="hl-tag">&lt;jdbc:script</span> <span class="hl-attribute">location</span>=<span class="hl-value">&quot;...&quot;</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/jdbc:initialize-database&gt;</span></pre> 
    <p>In this example we are saying we expect that sometimes the scripts will be run against an empty database and there are some DROP statements in the scripts which would therefore fail. So failed SQL <code class="literal">DROP</code> statements will be ignored, but other failures will cause an exception. This is useful if your SQL dialect doesnt support <code class="literal">DROP ... IF EXISTS</code> (or similar) but you want to unconditionally remove all test data before re-creating it. In that case the first script is usually a set of drops, followed by a set of <code class="literal">CREATE</code> statements.</p> 
    <p>The <code class="literal">ignore-failures</code> option can be set to <code class="literal">NONE</code> (the default), <code class="literal">DROPS</code> (ignore failed drops) or <code class="literal">ALL</code> (ignore all failures).</p> 
    <p>If you need more control than you get from the XML namespace, you can simply use the <code class="literal">DataSourceInitializer</code> directly, and define it as a component in your application.</p> 
    <div class="section" title="Initialization of Other Components that Depend on the Database">
     <div class="titlepage">
      <div>
       <div>
        <h4 class="title"><a name="jdbc-client-component-initialization"></a>Initialization of Other Components that Depend on the Database</h4>
       </div>
      </div>
     </div> 
     <p>A large class of applications can just use the database initializer with no further complications: those that do not use the database until after the Spring context has started. If your application is <span class="emphasis"><em>not</em></span> one of those then you might need to read the rest of this section.</p> 
     <p>The database initializer depends on a data source instance and runs the scripts provided in its initialization callback (c.f. <code class="literal">init-method</code> in an XML bean definition or <code class="literal">InitializingBean</code>). If other beans depend on the same data source and also use the data source in an initialization callback then there might be a problem because the data has not yet been initialized. A common example of this is a cache that initializes eagerly and loads up data from the database on application startup.</p> 
     <p>To get round this issue you two options: change your cache initialization strategy to a later phase, or ensure that the database initializer is initialized first.</p> 
     <p>The first option might be easy if the application is in your control, and not otherwise. Some suggestions for how to implement this are</p> 
     <div class="itemizedlist">
      <ul class="itemizedlist" type="disc">
       <li class="listitem"> Make the cache initialize lazily on first usage, which improves application startup time </li>
       <li class="listitem"> Have your cache or a separate component that initializes the cache implement <code class="literal">Lifecycle</code> or <code class="literal">SmartLifecycle</code>. When the application context starts up a <code class="literal">SmartLifecycle</code> can be automatically started if its <code class="literal">autoStartup</code> flag is set, and a <code class="literal">Lifecycle</code> can be started manually by calling <code class="literal">ConfigurableApplicationContext.start()</code> on the enclosing context. </li>
       <li class="listitem"> Use a Spring <code class="literal">ApplicationEvent</code> or similar custom observer mechanism to trigger the cache initialization. <code class="literal">ContextRefreshedEvent</code> is always published by the context when it is ready for use (after all beans have been initialized), so that is often a useful hook (this is how the <code class="literal">SmartLifecycle</code> works by default). </li>
      </ul>
     </div> 
     <p>The second option can also be easy. Some suggestions on how to implement this are</p> 
     <div class="itemizedlist">
      <ul class="itemizedlist" type="disc">
       <li class="listitem"> Rely on Spring BeanFactory default behavior, which is that beans are initialized in registration order. You can easily arrange that by adopting the common practice of a set of &lt;import/&gt; elements that order your application modules, and ensure that the database and database initialization are listed first </li>
       <li class="listitem"> Separate the datasource and the business components that use it and control their startup order by putting them in separate ApplicationContext instances (e.g. parent has the datasource and child has the business components). This structure is common in Spring web applications, but can be more generally applied. </li>
       <li class="listitem"> Use a modular runtime like SpringSource dm Server and separate the data source and the components that depend on it. E.g. specify the bundle start up order as datasource &#x2192; initializer &#x2192; business components. </li>
      </ul>
     </div> 
    </div> 
   </div> 
  </div> 
 </div> 
 <div class="chapter" title="14.&nbsp;Object Relational Mapping (ORM) Data Access">
  <div class="titlepage">
   <div>
    <div>
     <h2 class="title"><a name="orm"></a>14.&nbsp;Object Relational Mapping (ORM) Data Access</h2>
    </div>
   </div>
  </div> 
  <div class="section" title="14.1&nbsp;Introduction to ORM with Spring">
   <div class="titlepage">
    <div>
     <div>
      <h2 class="title" style="clear: both"><a name="orm-introduction"></a>14.1&nbsp;Introduction to ORM with Spring</h2>
     </div>
    </div>
   </div> 
   <p>The Spring Framework supports integration with Hibernate, Java Persistence API (JPA) and Java Data Objects (JDO) for resource management, data access object (DAO) implementations, and transaction strategies. For example, for Hibernate there is first-class support with several convenient IoC features that address many typical Hibernate integration issues. You can configure all of the supported features for O/R (object relational) mapping tools through Dependency Injection. They can participate in Springs resource and transaction management, and they comply with Springs generic transaction and DAO exception hierarchies. The recommended integration style is to code DAOs against plain Hibernate, JPA, and JDO APIs. The older style of using Springs DAO templates is no longer recommended; however, coverage of this style can be found in the <a class="xref" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#classic-spring-orm" title="31.1&nbsp;Classic ORM usage">Section&nbsp;31.1, Classic ORM usage</a> in the appendices.</p> 
   <p>Spring adds significant enhancements to the ORM layer of your choice when you create data access applications. You can leverage as much of the integration support as you wish, and you should compare this integration effort with the cost and risk of building a similar infrastructure in-house. You can use much of the ORM support as you would a library, regardless of technology, because everything is designed as a set of reusable JavaBeans. ORM in a Spring IoC container facilitates configuration and deployment. Thus most examples in this section show configuration inside a Spring container.</p> 
   <p>Benefits of using the Spring Framework to create your ORM DAOs include:</p> 
   <div class="itemizedlist">
    <ul class="itemizedlist" type="disc">
     <li class="listitem"> <span class="emphasis"><em>Easier testing.</em></span> Springs IoC approach makes it easy to swap the implementations and configuration locations of Hibernate <code class="literal">SessionFactory</code> instances, JDBC <code class="literal">DataSource</code> instances, transaction managers, and mapped object implementations (if needed). This in turn makes it much easier to test each piece of persistence-related code in isolation. </li>
     <li class="listitem"> <span class="emphasis"><em>Common data access exceptions.</em></span> Spring can wrap exceptions from your ORM tool, converting them from proprietary (potentially checked) exceptions to a common runtime DataAccessException hierarchy. This feature allows you to handle most persistence exceptions, which are non-recoverable, only in the appropriate layers, without annoying boilerplate catches, throws, and exception declarations. You can still trap and handle exceptions as necessary. Remember that JDBC exceptions (including DB-specific dialects) are also converted to the same hierarchy, meaning that you can perform some operations with JDBC within a consistent programming model. </li>
     <li class="listitem"> <span class="emphasis"><em>General resource management.</em></span> Spring application contexts can handle the location and configuration of Hibernate <code class="literal">SessionFactory</code> instances, JPA <code class="literal">EntityManagerFactory</code> instances, JDBC <code class="literal">DataSource</code> instances, and other related resources. This makes these values easy to manage and change. Spring offers efficient, easy, and safe handling of persistence resources. For example, related code that uses Hibernate generally needs to use the same Hibernate <code class="literal">Session</code> to ensure efficiency and proper transaction handling. Spring makes it easy to create and bind a <code class="literal">Session</code> to the current thread transparently, by exposing a current <code class="literal">Session</code> through the Hibernate <code class="literal">SessionFactory</code>. Thus Spring solves many chronic problems of typical Hibernate usage, for any local or JTA transaction environment. </li>
     <li class="listitem"> <span class="emphasis"><em>Integrated transaction management.</em></span> You can wrap your ORM code with a declarative, aspect-oriented programming (AOP) style method interceptor either through the <code class="literal">@Transactional</code> annotation or by explicitly configuring the transaction AOP advice in an XML configuration file. In both cases, transaction semantics and exception handling (rollback, and so on) are handled for you. As discussed below, in <a class="link" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#orm-resource-mngmnt" title="14.2.1&nbsp;Resource and transaction management">Resource and transaction management</a>, you can also swap various transaction managers, without affecting your ORM-related code. For example, you can swap between local transactions and JTA, with the same full services (such as declarative transactions) available in both scenarios. Additionally, JDBC-related code can fully integrate transactionally with the code you use to do ORM. This is useful for data access that is not suitable for ORM, such as batch processing and BLOB streaming, which still need to share common transactions with ORM operations. </li>
    </ul>
   </div> 
   <div class="tip" title="Tip" style="margin-left: 0.5in; margin-right: 0.5in;">
    <table border="0" summary="Tip">
     <tbody>
      <tr>
       <td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="./Spring Framework Reference Documentation_files/tip.png" /></td>
       <th align="left">Tip</th>
      </tr>
      <tr>
       <td align="left" valign="top"> <p>For more comprehensive ORM support, including support for alternative database technologies such as MongoDB, you might want to check out the <a class="ulink" href="http://projects.spring.io/spring-data/" target="_top">Spring Data</a> suite of projects. If you are a JPA user, the <a class="ulink" href="https://spring.io/guides/gs/accessing-data-jpa/" target="_top">Getting Started Accessing Data with JPA</a> guide from <a class="ulink" href="http://spring.io/" target="_top">http://spring.io</a> provides a great introduction.</p> </td>
      </tr>
     </tbody>
    </table>
   </div> 
  </div> 
  <div class="section" title="14.2&nbsp;General ORM integration considerations">
   <div class="titlepage">
    <div>
     <div>
      <h2 class="title" style="clear: both"><a name="orm-general"></a>14.2&nbsp;General ORM integration considerations</h2>
     </div>
    </div>
   </div> 
   <p>This section highlights considerations that apply to all ORM technologies. The <a class="xref" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#orm-hibernate" title="14.3&nbsp;Hibernate">Section&nbsp;14.3, Hibernate</a> section provides more details and also show these features and configurations in a concrete context.</p> 
   <p>The major goal of Springs ORM integration is clear application layering, with any data access and transaction technology, and for loose coupling of application objects. No more business service dependencies on the data access or transaction strategy, no more hard-coded resource lookups, no more hard-to-replace singletons, no more custom service registries. One simple and consistent approach to wiring up application objects, keeping them as reusable and free from container dependencies as possible. All the individual data access features are usable on their own but integrate nicely with Springs application context concept, providing XML-based configuration and cross-referencing of plain JavaBean instances that need not be Spring-aware. In a typical Spring application, many important objects are JavaBeans: data access templates, data access objects, transaction managers, business services that use the data access objects and transaction managers, web view resolvers, web controllers that use the business services,and so on.</p> 
   <div class="section" title="14.2.1&nbsp;Resource and transaction management">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="orm-resource-mngmnt"></a>14.2.1&nbsp;Resource and transaction management</h3>
      </div>
     </div>
    </div> 
    <p>Typical business applications are cluttered with repetitive resource management code. Many projects try to invent their own solutions, sometimes sacrificing proper handling of failures for programming convenience. Spring advocates simple solutions for proper resource handling, namely IoC through templating in the case of JDBC and applying AOP interceptors for the ORM technologies.</p> 
    <p>The infrastructure provides proper resource handling and appropriate conversion of specific API exceptions to an unchecked infrastructure exception hierarchy. Spring introduces a DAO exception hierarchy, applicable to any data access strategy. For direct JDBC, the <code class="literal">JdbcTemplate</code> class mentioned in a previous section provides connection handling and proper conversion of <code class="literal">SQLException</code> to the <code class="literal">DataAccessException</code> hierarchy, including translation of database-specific SQL error codes to meaningful exception classes. For ORM technologies, see the next section for how to get the same exception translation benefits.</p> 
    <p>When it comes to transaction management, the <code class="literal">JdbcTemplate</code> class hooks in to the Spring transaction support and supports both JTA and JDBC transactions, through respective Spring transaction managers. For the supported ORM technologies Spring offers Hibernate, JPA and JDO support through the Hibernate, JPA, and JDO transaction managers as well as JTA support. For details on transaction support, see the <a class="xref" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#transaction" title="11.&nbsp;Transaction Management">Chapter&nbsp;11, <i>Transaction Management</i></a> chapter.</p> 
   </div> 
   <div class="section" title="14.2.2&nbsp;Exception translation">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="orm-exception-translation"></a>14.2.2&nbsp;Exception translation</h3>
      </div>
     </div>
    </div> 
    <p>When you use Hibernate, JPA, or JDO in a DAO, you must decide how to handle the persistence technologys native exception classes. The DAO throws a subclass of a <code class="literal">HibernateException</code>, <code class="literal">PersistenceException</code> or <code class="literal">JDOException</code> depending on the technology. These exceptions are all run-time exceptions and do not have to be declared or caught. You may also have to deal with <code class="literal">IllegalArgumentException</code> and <code class="literal">IllegalStateException</code>. This means that callers can only treat exceptions as generally fatal, unless they want to depend on the persistence technologys own exception structure. Catching specific causes such as an optimistic locking failure is not possible without tying the caller to the implementation strategy. This trade off might be acceptable to applications that are strongly ORM-based and/or do not need any special exception treatment. However, Spring enables exception translation to be applied transparently through the <code class="literal">@Repository</code> annotation:</p> 
    <pre class="programlisting"><i><span class="hl-annotation" style="color: gray">@Repository</span></i>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ProductDaoImpl <span class="hl-keyword">implements</span> ProductDao {

    <span class="hl-comment">// class body here...</span>

}</pre> 
    <pre class="programlisting"><span class="hl-tag">&lt;beans&gt;</span>

    <span class="hl-comment">&lt;!-- Exception translation bean post processor --&gt;</span>
    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor&quot;</span><span class="hl-tag">/&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;myProductDao&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;product.ProductDaoImpl&quot;</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre> 
    <p>The postprocessor automatically looks for all exception translators (implementations of the <code class="literal">PersistenceExceptionTranslator</code> interface) and advises all beans marked with the <code class="literal">@Repository</code> annotation so that the discovered translators can intercept and apply the appropriate translation on the thrown exceptions.</p> 
    <p>In summary: you can implement DAOs based on the plain persistence technologys API and annotations, while still benefiting from Spring-managed transactions, dependency injection, and transparent exception conversion (if desired) to Springs custom exception hierarchies.</p> 
   </div> 
  </div> 
  <div class="section" title="14.3&nbsp;Hibernate">
   <div class="titlepage">
    <div>
     <div>
      <h2 class="title" style="clear: both"><a name="orm-hibernate"></a>14.3&nbsp;Hibernate</h2>
     </div>
    </div>
   </div> 
   <p>We will start with a coverage of <a class="ulink" href="http://www.hibernate.org/" target="_top">Hibernate 3</a> in a Spring environment, using it to demonstrate the approach that Spring takes towards integrating O/R mappers. This section will cover many issues in detail and show different variations of DAO implementations and transaction demarcation. Most of these patterns can be directly translated to all other supported ORM tools. The following sections in this chapter will then cover the other ORM technologies, showing briefer examples there.</p> 
   <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;">
    <table border="0" summary="Note">
     <tbody>
      <tr>
       <td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Framework Reference Documentation_files/note.png" /></td>
       <th align="left">Note</th>
      </tr>
      <tr>
       <td align="left" valign="top"> <p>As of Spring 4.0, Spring requires Hibernate 3.6 or later.</p> </td>
      </tr>
     </tbody>
    </table>
   </div> 
   <div class="section" title="14.3.1&nbsp;SessionFactory setup in a Spring container">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="orm-session-factory-setup"></a>14.3.1&nbsp;SessionFactory setup in a Spring container</h3>
      </div>
     </div>
    </div> 
    <p>To avoid tying application objects to hard-coded resource lookups, you can define resources such as a JDBC <code class="literal">DataSource</code> or a Hibernate <code class="literal">SessionFactory</code> as beans in the Spring container. Application objects that need to access resources receive references to such predefined instances through bean references, as illustrated in the DAO definition in the next section.</p> 
    <p>The following excerpt from an XML application context definition shows how to set up a JDBC <code class="literal">DataSource</code> and a Hibernate <code class="literal">SessionFactory</code> on top of it:</p> 
    <pre class="programlisting"><span class="hl-tag">&lt;beans&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;myDataSource&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span> <span class="hl-attribute">destroy-method</span>=<span class="hl-value">&quot;close&quot;</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;driverClassName&quot;</span> <span class="hl-attribute">value</span>=<span class="hl-value">&quot;org.hsqldb.jdbcDriver&quot;</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;url&quot;</span> <span class="hl-attribute">value</span>=<span class="hl-value">&quot;jdbc:hsqldb:hsql://localhost:9001&quot;</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;username&quot;</span> <span class="hl-attribute">value</span>=<span class="hl-value">&quot;sa&quot;</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;password&quot;</span> <span class="hl-attribute">value</span>=<span class="hl-value">&quot;&quot;</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;mySessionFactory&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;org.springframework.orm.hibernate3.LocalSessionFactoryBean&quot;</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;dataSource&quot;</span> <span class="hl-attribute">ref</span>=<span class="hl-value">&quot;myDataSource&quot;</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;mappingResources&quot;</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;list&gt;</span>
                <span class="hl-tag">&lt;value&gt;</span>product.hbm.xml<span class="hl-tag">&lt;/value&gt;</span>
            <span class="hl-tag">&lt;/list&gt;</span>
        <span class="hl-tag">&lt;/property&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;hibernateProperties&quot;</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;value&gt;</span>
                hibernate.dialect=org.hibernate.dialect.HSQLDialect
            <span class="hl-tag">&lt;/value&gt;</span>
        <span class="hl-tag">&lt;/property&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre> 
    <p>Switching from a local Jakarta Commons DBCP <code class="literal">BasicDataSource</code> to a JNDI-located <code class="literal">DataSource</code> (usually managed by an application server) is just a matter of configuration:</p> 
    <pre class="programlisting"><span class="hl-tag">&lt;beans&gt;</span>
    <span class="hl-tag">&lt;jee:jndi-lookup</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;myDataSource&quot;</span> <span class="hl-attribute">jndi-name</span>=<span class="hl-value">&quot;java:comp/env/jdbc/myds&quot;</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/beans&gt;</span></pre> 
    <p>You can also access a JNDI-located <code class="literal">SessionFactory</code>, using Springs <code class="literal">JndiObjectFactoryBean</code> / <code class="literal">&lt;jee:jndi-lookup&gt;</code> to retrieve and expose it. However, that is typically not common outside of an EJB context.</p> 
   </div> 
   <div class="section" title="14.3.2&nbsp;Implementing DAOs based on plain Hibernate 3 API">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="orm-hibernate-straight"></a>14.3.2&nbsp;Implementing DAOs based on plain Hibernate 3 API</h3>
      </div>
     </div>
    </div> 
    <p>Hibernate 3 has a feature called contextual sessions, wherein Hibernate itself manages one current <code class="literal">Session</code> per transaction. This is roughly equivalent to Springs synchronization of one Hibernate <code class="literal">Session</code> per transaction. A corresponding DAO implementation resembles the following example, based on the plain Hibernate API:</p> 
    <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ProductDaoImpl <span class="hl-keyword">implements</span> ProductDao {

    <span class="hl-keyword">private</span> SessionFactory sessionFactory;

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setSessionFactory(SessionFactory sessionFactory) {
        <span class="hl-keyword">this</span>.sessionFactory = sessionFactory;
    }

    <span class="hl-keyword">public</span> Collection loadProductsByCategory(String category) {
        <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>.sessionFactory.getCurrentSession()
                .createQuery(<span class="hl-string">&quot;from test.Product product where product.category=?&quot;</span>)
                .setParameter(<span class="hl-number">0</span>, category)
                .list();
    }
}</pre> 
    <p>This style is similar to that of the Hibernate reference documentation and examples, except for holding the <code class="literal">SessionFactory</code> in an instance variable. We strongly recommend such an instance-based setup over the old-school <code class="literal">static</code> <code class="literal">HibernateUtil</code> class from Hibernates CaveatEmptor sample application. (In general, do not keep any resources in <code class="literal">static</code> variables unless <span class="emphasis"><em>absolutely</em></span> necessary.)</p> 
    <p>The above DAO follows the dependency injection pattern: it fits nicely into a Spring IoC container, just as it would if coded against Springs <code class="literal">HibernateTemplate</code>. Of course, such a DAO can also be set up in plain Java (for example, in unit tests). Simply instantiate it and call <code class="literal">setSessionFactory(..)</code> with the desired factory reference. As a Spring bean definition, the DAO would resemble the following:</p> 
    <pre class="programlisting"><span class="hl-tag">&lt;beans&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;myProductDao&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;product.ProductDaoImpl&quot;</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;sessionFactory&quot;</span> <span class="hl-attribute">ref</span>=<span class="hl-value">&quot;mySessionFactory&quot;</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre> 
    <p>The main advantage of this DAO style is that it depends on Hibernate API only; no import of any Spring class is required. This is of course appealing from a non-invasiveness perspective, and will no doubt feel more natural to Hibernate developers.</p> 
    <p>However, the DAO throws plain <code class="literal">HibernateException</code> (which is unchecked, so does not have to be declared or caught), which means that callers can only treat exceptions as generally fatal - unless they want to depend on Hibernates own exception hierarchy. Catching specific causes such as an optimistic locking failure is not possible without tying the caller to the implementation strategy. This trade off might be acceptable to applications that are strongly Hibernate-based and/or do not need any special exception treatment.</p> 
    <p>Fortunately, Springs <code class="literal">LocalSessionFactoryBean</code> supports Hibernates <code class="literal">SessionFactory.getCurrentSession()</code> method for any Spring transaction strategy, returning the current Spring-managed transactional <code class="literal">Session</code> even with <code class="literal">HibernateTransactionManager</code>. Of course, the standard behavior of that method remains the return of the current <code class="literal">Session</code> associated with the ongoing JTA transaction, if any. This behavior applies regardless of whether you are using Springs <code class="literal">JtaTransactionManager</code>, EJB container managed transactions (CMTs), or JTA.</p> 
    <p>In summary: you can implement DAOs based on the plain Hibernate 3 API, while still being able to participate in Spring-managed transactions.</p> 
   </div> 
   <div class="section" title="14.3.3&nbsp;Declarative transaction demarcation">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="orm-hibernate-tx-declarative"></a>14.3.3&nbsp;Declarative transaction demarcation</h3>
      </div>
     </div>
    </div> 
    <p>We recommend that you use Springs declarative transaction support, which enables you to replace explicit transaction demarcation API calls in your Java code with an AOP transaction interceptor. This transaction interceptor can be configured in a Spring container using either Java annotations or XML.This declarative transaction capability allows you to keep business services free of repetitive transaction demarcation code and to focus on adding business logic, which is the real value of your application.</p> 
    <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;">
     <table border="0" summary="Note">
      <tbody>
       <tr>
        <td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Framework Reference Documentation_files/note.png" /></td>
        <th align="left">Note</th>
       </tr>
       <tr>
        <td align="left" valign="top"> <p>Prior to continuing, you are <span class="emphasis"><em>strongly</em></span> encouraged to read <a class="xref" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#transaction-declarative" title="11.5&nbsp;Declarative transaction management">Section&nbsp;11.5, Declarative transaction management</a> if you have not done so.</p> </td>
       </tr>
      </tbody>
     </table>
    </div> 
    <p>Furthermore, transaction semantics like propagation behavior and isolation level can be changed in a configuration file and do not affect the business service implementations.</p> 
    <p>The following example shows how you can configure an AOP transaction interceptor, using XML, for a simple service class:</p> 
    <pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">&quot;http://www.springframework.org/schema/beans&quot;</span>
    <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>
    <span class="hl-attribute">xmlns:aop</span>=<span class="hl-value">&quot;http://www.springframework.org/schema/aop&quot;</span>
    <span class="hl-attribute">xmlns:tx</span>=<span class="hl-value">&quot;http://www.springframework.org/schema/tx&quot;</span>
    <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">&quot;
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx
        http://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span><span class="hl-tag">&gt;</span>

    <span class="hl-comment">&lt;!-- SessionFactory, DataSource, etc. omitted --&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;transactionManager&quot;</span>
            <span class="hl-attribute">class</span>=<span class="hl-value">&quot;org.springframework.orm.hibernate3.HibernateTransactionManager&quot;</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;sessionFactory&quot;</span> <span class="hl-attribute">ref</span>=<span class="hl-value">&quot;sessionFactory&quot;</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

    <span class="hl-tag">&lt;aop:config&gt;</span>
        <span class="hl-tag">&lt;aop:pointcut</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;productServiceMethods&quot;</span>
                <span class="hl-attribute">expression</span>=<span class="hl-value">&quot;execution(* product.ProductService.</span><span class="strong"><strong>(..))&quot;/&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;productServiceMethods&quot;/&gt; &lt;/aop:config&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;myTxManager&quot;&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;increasePrice</strong></span>&quot; propagation=&quot;REQUIRED&quot;/&gt;
            <span class="hl-tag">&lt;tx:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;someOtherBusinessMethod&quot;</span> <span class="hl-attribute">propagation</span>=<span class="hl-value">&quot;REQUIRES_NEW&quot;</span><span class="hl-tag">/&gt;</span>
            <span class="hl-tag">&lt;tx:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;*&quot;</span> <span class="hl-attribute">propagation</span>=<span class="hl-value">&quot;SUPPORTS&quot;</span> <span class="hl-attribute">read-only</span>=<span class="hl-value">&quot;true&quot;</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;/tx:attributes&gt;</span>
    <span class="hl-tag">&lt;/tx:advice&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;myProductService&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;product.SimpleProductService&quot;</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;productDao&quot;</span> <span class="hl-attribute">ref</span>=<span class="hl-value">&quot;myProductDao&quot;</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre> 
    <p>This is the service class that is advised:</p> 
    <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ProductServiceImpl <span class="hl-keyword">implements</span> ProductService {

    <span class="hl-keyword">private</span> ProductDao productDao;

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setProductDao(ProductDao productDao) {
        <span class="hl-keyword">this</span>.productDao = productDao;
    }

    <span class="hl-comment">// notice the absence of transaction demarcation code in this method</span>
    <span class="hl-comment">// Spring's declarative transaction infrastructure will be demarcating</span>
    <span class="hl-comment">// transactions on your behalf</span>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> increasePriceOfAllProductsInCategory(<span class="hl-keyword">final</span> String category) {
        List productsToChange = <span class="hl-keyword">this</span>.productDao.loadProductsByCategory(category);
        <span class="hl-comment">// ...</span>
    }
}</pre> 
    <p>We also show an attribute-support based configuration, in the following example. You annotate the service layer with @Transactional annotations and instruct the Spring container to find these annotations and provide transactional semantics for these annotated methods.</p> 
    <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ProductServiceImpl <span class="hl-keyword">implements</span> ProductService {

    <span class="hl-keyword">private</span> ProductDao productDao;

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setProductDao(ProductDao productDao) {
        <span class="hl-keyword">this</span>.productDao = productDao;
    }

    <i><span class="hl-annotation" style="color: gray">@Transactional</span></i>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> increasePriceOfAllProductsInCategory(<span class="hl-keyword">final</span> String category) {
        List productsToChange = <span class="hl-keyword">this</span>.productDao.loadProductsByCategory(category);
        <span class="hl-comment">// ...</span>
    }

    <i><span class="hl-annotation" style="color: gray">@Transactional(readOnly = true)</span></i>
    <span class="hl-keyword">public</span> List&lt;Product&gt; findAllProducts() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>.productDao.findAllProducts();
    }

}</pre> 
    <p>As you can see from the following configuration example, the configuration is much simplified, compared to the XML example above, while still providing the same functionality driven by the annotations in the service layer code. All you need to provide is the TransactionManager implementation and a &quot;&lt;tx:annotation-driven/&gt;&quot; entry.</p> 
    <pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">&quot;http://www.springframework.org/schema/beans&quot;</span>
    <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>
    <span class="hl-attribute">xmlns:aop</span>=<span class="hl-value">&quot;http://www.springframework.org/schema/aop&quot;</span>
    <span class="hl-attribute">xmlns:tx</span>=<span class="hl-value">&quot;http://www.springframework.org/schema/tx&quot;</span>
    <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">&quot;
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx
        http://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span><span class="hl-tag">&gt;</span>

    <span class="hl-comment">&lt;!-- SessionFactory, DataSource, etc. omitted --&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;transactionManager&quot;</span>
            <span class="hl-attribute">class</span>=<span class="hl-value">&quot;org.springframework.orm.hibernate3.HibernateTransactionManager&quot;</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;sessionFactory&quot;</span> <span class="hl-attribute">ref</span>=<span class="hl-value">&quot;sessionFactory&quot;</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

    <span class="hl-tag">&lt;tx:annotation-driven/&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;myProductService&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;product.SimpleProductService&quot;</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;productDao&quot;</span> <span class="hl-attribute">ref</span>=<span class="hl-value">&quot;myProductDao&quot;</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre> 
   </div> 
   <div class="section" title="14.3.4&nbsp;Programmatic transaction demarcation">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="orm-hibernate-tx-programmatic"></a>14.3.4&nbsp;Programmatic transaction demarcation</h3>
      </div>
     </div>
    </div> 
    <p>You can demarcate transactions in a higher level of the application, on top of such lower-level data access services spanning any number of operations. Nor do restrictions exist on the implementation of the surrounding business service; it just needs a Spring <code class="literal">PlatformTransactionManager</code>. Again, the latter can come from anywhere, but preferably as a bean reference through a <code class="literal">setTransactionManager(..)</code> method, just as the <code class="literal">productDAO</code> should be set by a <code class="literal">setProductDao(..)</code> method. The following snippets show a transaction manager and a business service definition in a Spring application context, and an example for a business method implementation:</p> 
    <pre class="programlisting"><span class="hl-tag">&lt;beans&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;myTxManager&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;org.springframework.orm.hibernate3.HibernateTransactionManager&quot;</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;sessionFactory&quot;</span> <span class="hl-attribute">ref</span>=<span class="hl-value">&quot;mySessionFactory&quot;</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;myProductService&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;product.ProductServiceImpl&quot;</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;transactionManager&quot;</span> <span class="hl-attribute">ref</span>=<span class="hl-value">&quot;myTxManager&quot;</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;productDao&quot;</span> <span class="hl-attribute">ref</span>=<span class="hl-value">&quot;myProductDao&quot;</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre> 
    <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ProductServiceImpl <span class="hl-keyword">implements</span> ProductService {

    <span class="hl-keyword">private</span> TransactionTemplate transactionTemplate;
    <span class="hl-keyword">private</span> ProductDao productDao;

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setTransactionManager(PlatformTransactionManager transactionManager) {
        <span class="hl-keyword">this</span>.transactionTemplate = <span class="hl-keyword">new</span> TransactionTemplate(transactionManager);
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setProductDao(ProductDao productDao) {
        <span class="hl-keyword">this</span>.productDao = productDao;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> increasePriceOfAllProductsInCategory(<span class="hl-keyword">final</span> String category) {
        <span class="hl-keyword">this</span>.transactionTemplate.execute(<span class="hl-keyword">new</span> TransactionCallbackWithoutResult() {
            <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> doInTransactionWithoutResult(TransactionStatus status) {
                List productsToChange = <span class="hl-keyword">this</span>.productDao.loadProductsByCategory(category);
                <span class="hl-comment">// do the price increase...</span>
            }
        });
    }
}</pre> 
    <p>Springs <code class="literal">TransactionInterceptor</code> allows any checked application exception to be thrown with the callback code, while <code class="literal">TransactionTemplate</code> is restricted to unchecked exceptions within the callback. <code class="literal">TransactionTemplate</code> triggers a rollback in case of an unchecked application exception, or if the transaction is marked rollback-only by the application (via <code class="literal">TransactionStatus</code>). <code class="literal">TransactionInterceptor</code> behaves the same way by default but allows configurable rollback policies per method.</p> 
   </div> 
   <div class="section" title="14.3.5&nbsp;Transaction management strategies">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="orm-hibernate-tx-strategies"></a>14.3.5&nbsp;Transaction management strategies</h3>
      </div>
     </div>
    </div> 
    <p>Both <code class="literal">TransactionTemplate</code> and <code class="literal">TransactionInterceptor</code> delegate the actual transaction handling to a <code class="literal">PlatformTransactionManager</code> instance, which can be a <code class="literal">HibernateTransactionManager</code> (for a single Hibernate <code class="literal">SessionFactory</code>, using a <code class="literal">ThreadLocal</code> <code class="literal">Session</code> under the hood) or a <code class="literal">JtaTransactionManager</code> (delegating to the JTA subsystem of the container) for Hibernate applications. You can even use a custom <code class="literal">PlatformTransactionManager</code> implementation. Switching from native Hibernate transaction management to JTA, such as when facing distributed transaction requirements for certain deployments of your application, is just a matter of configuration. Simply replace the Hibernate transaction manager with Springs JTA transaction implementation. Both transaction demarcation and data access code will work without changes, because they just use the generic transaction management APIs.</p> 
    <p>For distributed transactions across multiple Hibernate session factories, simply combine <code class="literal">JtaTransactionManager</code> as a transaction strategy with multiple <code class="literal">LocalSessionFactoryBean</code> definitions. Each DAO then gets one specific <code class="literal">SessionFactory</code> reference passed into its corresponding bean property. If all underlying JDBC data sources are transactional container ones, a business service can demarcate transactions across any number of DAOs and any number of session factories without special regard, as long as it is using <code class="literal">JtaTransactionManager</code> as the strategy.</p> 
    <pre class="programlisting"><span class="hl-tag">&lt;beans&gt;</span>

    <span class="hl-tag">&lt;jee:jndi-lookup</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;dataSource1&quot;</span> <span class="hl-attribute">jndi-name</span>=<span class="hl-value">&quot;java:comp/env/jdbc/myds1&quot;</span><span class="hl-tag">/&gt;</span>

    <span class="hl-tag">&lt;jee:jndi-lookup</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;dataSource2&quot;</span> <span class="hl-attribute">jndi-name</span>=<span class="hl-value">&quot;java:comp/env/jdbc/myds2&quot;</span><span class="hl-tag">/&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;mySessionFactory1&quot;</span>
            <span class="hl-attribute">class</span>=<span class="hl-value">&quot;org.springframework.orm.hibernate3.LocalSessionFactoryBean&quot;</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;dataSource&quot;</span> <span class="hl-attribute">ref</span>=<span class="hl-value">&quot;myDataSource1&quot;</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;mappingResources&quot;</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;list&gt;</span>
                <span class="hl-tag">&lt;value&gt;</span>product.hbm.xml<span class="hl-tag">&lt;/value&gt;</span>
            <span class="hl-tag">&lt;/list&gt;</span>
        <span class="hl-tag">&lt;/property&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;hibernateProperties&quot;</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;value&gt;</span>
                hibernate.dialect=org.hibernate.dialect.MySQLDialect
                hibernate.show_sql=true
            <span class="hl-tag">&lt;/value&gt;</span>
        <span class="hl-tag">&lt;/property&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;mySessionFactory2&quot;</span>
            <span class="hl-attribute">class</span>=<span class="hl-value">&quot;org.springframework.orm.hibernate3.LocalSessionFactoryBean&quot;</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;dataSource&quot;</span> <span class="hl-attribute">ref</span>=<span class="hl-value">&quot;myDataSource2&quot;</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;mappingResources&quot;</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;list&gt;</span>
                <span class="hl-tag">&lt;value&gt;</span>inventory.hbm.xml<span class="hl-tag">&lt;/value&gt;</span>
            <span class="hl-tag">&lt;/list&gt;</span>
        <span class="hl-tag">&lt;/property&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;hibernateProperties&quot;</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;value&gt;</span>
                hibernate.dialect=org.hibernate.dialect.OracleDialect
            <span class="hl-tag">&lt;/value&gt;</span>
        <span class="hl-tag">&lt;/property&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;myTxManager&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;org.springframework.transaction.jta.JtaTransactionManager&quot;</span><span class="hl-tag">/&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;myProductDao&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;product.ProductDaoImpl&quot;</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;sessionFactory&quot;</span> <span class="hl-attribute">ref</span>=<span class="hl-value">&quot;mySessionFactory1&quot;</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;myInventoryDao&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;product.InventoryDaoImpl&quot;</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;sessionFactory&quot;</span> <span class="hl-attribute">ref</span>=<span class="hl-value">&quot;mySessionFactory2&quot;</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;myProductService&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;product.ProductServiceImpl&quot;</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;productDao&quot;</span> <span class="hl-attribute">ref</span>=<span class="hl-value">&quot;myProductDao&quot;</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;inventoryDao&quot;</span> <span class="hl-attribute">ref</span>=<span class="hl-value">&quot;myInventoryDao&quot;</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

    <span class="hl-tag">&lt;aop:config&gt;</span>
        <span class="hl-tag">&lt;aop:pointcut</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;productServiceMethods&quot;</span>
                <span class="hl-attribute">expression</span>=<span class="hl-value">&quot;execution(* product.ProductService.</span><span class="strong"><strong>(..))&quot;/&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;productServiceMethods&quot;/&gt; &lt;/aop:config&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;myTxManager&quot;&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;increasePrice</strong></span>&quot; propagation=&quot;REQUIRED&quot;/&gt;
            <span class="hl-tag">&lt;tx:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;someOtherBusinessMethod&quot;</span> <span class="hl-attribute">propagation</span>=<span class="hl-value">&quot;REQUIRES_NEW&quot;</span><span class="hl-tag">/&gt;</span>
            <span class="hl-tag">&lt;tx:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;*&quot;</span> <span class="hl-attribute">propagation</span>=<span class="hl-value">&quot;SUPPORTS&quot;</span> <span class="hl-attribute">read-only</span>=<span class="hl-value">&quot;true&quot;</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;/tx:attributes&gt;</span>
    <span class="hl-tag">&lt;/tx:advice&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre> 
    <p>Both <code class="literal">HibernateTransactionManager</code> and <code class="literal">JtaTransactionManager</code> allow for proper JVM-level cache handling with Hibernate, without container-specific transaction manager lookup or a JCA connector (if you are not using EJB to initiate transactions).</p> 
    <p><code class="literal">HibernateTransactionManager</code> can export the Hibernate JDBC <code class="literal">Connection</code> to plain JDBC access code, for a specific <code class="literal">DataSource</code>. This capability allows for high-level transaction demarcation with mixed Hibernate and JDBC data access completely without JTA, if you are accessing only one database. <code class="literal">HibernateTransactionManager</code> automatically exposes the Hibernate transaction as a JDBC transaction if you have set up the passed-in <code class="literal">SessionFactory</code> with a <code class="literal">DataSource</code> through the <code class="literal">dataSource</code> property of the <code class="literal">LocalSessionFactoryBean</code> class. Alternatively, you can specify explicitly the <code class="literal">DataSource</code> for which the transactions are supposed to be exposed through the <code class="literal">dataSource</code> property of the <code class="literal">HibernateTransactionManager</code> class.</p> 
   </div> 
   <div class="section" title="14.3.6&nbsp;Comparing container-managed and locally defined resources">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="orm-hibernate-resources"></a>14.3.6&nbsp;Comparing container-managed and locally defined resources</h3>
      </div>
     </div>
    </div> 
    <p>You can switch between a container-managed JNDI <code class="literal">SessionFactory</code> and a locally defined one, without having to change a single line of application code. Whether to keep resource definitions in the container or locally within the application is mainly a matter of the transaction strategy that you use. Compared to a Spring-defined local <code class="literal">SessionFactory</code>, a manually registered JNDI <code class="literal">SessionFactory</code> does not provide any benefits. Deploying a <code class="literal">SessionFactory</code> through Hibernates JCA connector provides the added value of participating in the Java EE servers management infrastructure, but does not add actual value beyond that.</p> 
    <p>Springs transaction support is not bound to a container. Configured with any strategy other than JTA, transaction support also works in a stand-alone or test environment. Especially in the typical case of single-database transactions, Springs single-resource local transaction support is a lightweight and powerful alternative to JTA. When you use local EJB stateless session beans to drive transactions, you depend both on an EJB container and JTA, even if you access only a single database, and only use stateless session beans to provide declarative transactions through container-managed transactions. Also, direct use of JTA programmatically requires a Java EE environment as well. JTA does not involve only container dependencies in terms of JTA itself and of JNDI <code class="literal">DataSource</code> instances. For non-Spring, JTA-driven Hibernate transactions, you have to use the Hibernate JCA connector, or extra Hibernate transaction code with the <code class="literal">TransactionManagerLookup</code> configured for proper JVM-level caching.</p> 
    <p>Spring-driven transactions can work as well with a locally defined Hibernate <code class="literal">SessionFactory</code> as they do with a local JDBC <code class="literal">DataSource</code> if they are accessing a single database. Thus you only have to use Springs JTA transaction strategy when you have distributed transaction requirements. A JCA connector requires container-specific deployment steps, and obviously JCA support in the first place. This configuration requires more work than deploying a simple web application with local resource definitions and Spring-driven transactions. Also, you often need the Enterprise Edition of your container if you are using, for example, WebLogic Express, which does not provide JCA. A Spring application with local resources and transactions spanning one single database works in any Java EE web container (without JTA, JCA, or EJB) such as Tomcat, Resin, or even plain Jetty. Additionally, you can easily reuse such a middle tier in desktop applications or test suites.</p> 
    <p>All things considered, if you do not use EJBs, stick with local <code class="literal">SessionFactory</code> setup and Springs <code class="literal">HibernateTransactionManager</code> or <code class="literal">JtaTransactionManager</code>. You get all of the benefits, including proper transactional JVM-level caching and distributed transactions, without the inconvenience of container deployment. JNDI registration of a Hibernate <code class="literal">SessionFactory</code> through the JCA connector only adds value when used in conjunction with EJBs.</p> 
   </div> 
   <div class="section" title="14.3.7&nbsp;Spurious application server warnings with Hibernate">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="orm-hibernate-invalid-jdbc-access-error"></a>14.3.7&nbsp;Spurious application server warnings with Hibernate</h3>
      </div>
     </div>
    </div> 
    <p>In some JTA environments with very strict <code class="literal">XADataSource</code> implementations&#x2009;&#x2009;currently only some WebLogic Server and WebSphere versions&#x2009;&#x2009;when Hibernate is configured without regard to the JTA <code class="literal">PlatformTransactionManager</code> object for that environment, it is possible for spurious warning or exceptions to show up in the application server log. These warnings or exceptions indicate that the connection being accessed is no longer valid, or JDBC access is no longer valid, possibly because the transaction is no longer active. As an example, here is an actual exception from WebLogic:</p> 
    <pre class="literallayout">java.sql.SQLException: The transaction is no longer active - status: <span class="emphasis"><em>Committed</em></span>. No
further JDBC access is allowed within this transaction.</pre> 
    <p>You resolve this warning by simply making Hibernate aware of the JTA <code class="literal">PlatformTransactionManager</code> instance, to which it will synchronize (along with Spring). You have two options for doing this:</p> 
    <div class="itemizedlist">
     <ul class="itemizedlist" type="disc">
      <li class="listitem"> If in your application context you are already directly obtaining the JTA <code class="literal">PlatformTransactionManager</code> object (presumably from JNDI through <code class="literal">JndiObjectFactoryBean</code> or <code class="literal">&lt;jee:jndi-lookup&gt;</code>) and feeding it, for example, to Springs <code class="literal">JtaTransactionManager</code>, then the easiest way is to specify a reference to the bean defining this JTA <code class="literal">PlatformTransactionManager</code> instance as the value of the <code class="literal">jtaTransactionManager</code> property for <code class="literal">LocalSessionFactoryBean.</code> Spring then makes the object available to Hibernate. </li>
      <li class="listitem"> More likely you do not already have the JTA <code class="literal">PlatformTransactionManager</code> instance, because Springs <code class="literal">JtaTransactionManager</code> can find it itself. Thus you need to configure Hibernate to look up JTA <code class="literal">PlatformTransactionManager</code> directly. You do this by configuring an application server- specific <code class="literal">TransactionManagerLookup</code> class in the Hibernate configuration, as described in the Hibernate manual. </li>
     </ul>
    </div> 
    <p>The remainder of this section describes the sequence of events that occur with and without Hibernates awareness of the JTA <code class="literal">PlatformTransactionManager</code>.</p> 
    <p>When Hibernate is not configured with any awareness of the JTA <code class="literal">PlatformTransactionManager</code>, the following events occur when a JTA transaction commits:</p> 
    <div class="itemizedlist">
     <ul class="itemizedlist" type="disc">
      <li class="listitem"> The JTA transaction commits. </li>
      <li class="listitem"> Springs <code class="literal">JtaTransactionManager</code> is synchronized to the JTA transaction, so it is called back through an <span class="emphasis"><em>afterCompletion</em></span> callback by the JTA transaction manager. </li>
      <li class="listitem"> Among other activities, this synchronization can trigger a callback by Spring to Hibernate, through Hibernates <code class="literal">afterTransactionCompletion</code> callback (used to clear the Hibernate cache), followed by an explicit <code class="literal">close()</code> call on the Hibernate Session, which causes Hibernate to attempt to <code class="literal">close()</code> the JDBC Connection. </li>
      <li class="listitem"> In some environments, this <code class="literal">Connection.close()</code> call then triggers the warning or error, as the application server no longer considers the <code class="literal">Connection</code> usable at all, because the transaction has already been committed. </li>
     </ul>
    </div> 
    <p>When Hibernate is configured with awareness of the JTA <code class="literal">PlatformTransactionManager</code>, the following events occur when a JTA transaction commits:</p> 
    <div class="itemizedlist">
     <ul class="itemizedlist" type="disc">
      <li class="listitem"> the JTA transaction is ready to commit. </li>
      <li class="listitem"> Springs <code class="literal">JtaTransactionManager</code> is synchronized to the JTA transaction, so the transaction is called back through a <span class="emphasis"><em>beforeCompletion</em></span> callback by the JTA transaction manager. </li>
      <li class="listitem"> Spring is aware that Hibernate itself is synchronized to the JTA transaction, and behaves differently than in the previous scenario. Assuming the Hibernate <code class="literal">Session</code> needs to be closed at all, Spring will close it now. </li>
      <li class="listitem"> The JTA transaction commits. </li>
      <li class="listitem"> Hibernate is synchronized to the JTA transaction, so the transaction is called back through an <span class="emphasis"><em>afterCompletion</em></span> callback by the JTA transaction manager, and can properly clear its cache. </li>
     </ul>
    </div> 
   </div> 
  </div> 
  <div class="section" title="14.4&nbsp;JDO">
   <div class="titlepage">
    <div>
     <div>
      <h2 class="title" style="clear: both"><a name="orm-jdo"></a>14.4&nbsp;JDO</h2>
     </div>
    </div>
   </div> 
   <p>Spring supports the standard JDO 2.0 and 2.1 APIs as data access strategy, following the same style as the Hibernate support. The corresponding integration classes reside in the <code class="literal">org.springframework.orm.jdo</code> package.</p> 
   <div class="section" title="14.4.1&nbsp;PersistenceManagerFactory setup">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="orm-jdo-setup"></a>14.4.1&nbsp;PersistenceManagerFactory setup</h3>
      </div>
     </div>
    </div> 
    <p>Spring provides a <code class="literal">LocalPersistenceManagerFactoryBean</code> class that allows you to define a local JDO <code class="literal">PersistenceManagerFactory</code> within a Spring application context:</p> 
    <pre class="programlisting"><span class="hl-tag">&lt;beans&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;myPmf&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;org.springframework.orm.jdo.LocalPersistenceManagerFactoryBean&quot;</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;configLocation&quot;</span> <span class="hl-attribute">value</span>=<span class="hl-value">&quot;classpath:kodo.properties&quot;</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre> 
    <p>Alternatively, you can set up a <code class="literal">PersistenceManagerFactory</code> through direct instantiation of a <code class="literal">PersistenceManagerFactory</code> implementation class. A JDO <code class="literal">PersistenceManagerFactory</code> implementation class follows the JavaBeans pattern, just like a JDBC <code class="literal">DataSource</code> implementation class, which is a natural fit for a configuration that uses Spring. This setup style usually supports a Spring-defined JDBC <code class="literal">DataSource</code>, passed into the <code class="literal">connectionFactory</code> property. For example, for the open source JDO implementation DataNucleus (formerly JPOX) ( <a class="ulink" href="http://www.datanucleus.org/" target="_top">http://www.datanucleus.org/</a>), this is the XML configuration of the <code class="literal">PersistenceManagerFactory</code> implementation:</p> 
    <pre class="programlisting"><span class="hl-tag">&lt;beans&gt;</span>

 <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;dataSource&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span> <span class="hl-attribute">destroy-method</span>=<span class="hl-value">&quot;close&quot;</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;driverClassName&quot;</span> <span class="hl-attribute">value</span>=<span class="hl-value">&quot;${jdbc.driverClassName}&quot;</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;url&quot;</span> <span class="hl-attribute">value</span>=<span class="hl-value">&quot;${jdbc.url}&quot;</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;username&quot;</span> <span class="hl-attribute">value</span>=<span class="hl-value">&quot;${jdbc.username}&quot;</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;password&quot;</span> <span class="hl-attribute">value</span>=<span class="hl-value">&quot;${jdbc.password}&quot;</span><span class="hl-tag">/&gt;</span>
 <span class="hl-tag">&lt;/bean&gt;</span>

 <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;myPmf&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;org.datanucleus.jdo.JDOPersistenceManagerFactory&quot;</span> <span class="hl-attribute">destroy-method</span>=<span class="hl-value">&quot;close&quot;</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;connectionFactory&quot;</span> <span class="hl-attribute">ref</span>=<span class="hl-value">&quot;dataSource&quot;</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;nontransactionalRead&quot;</span> <span class="hl-attribute">value</span>=<span class="hl-value">&quot;true&quot;</span><span class="hl-tag">/&gt;</span>
 <span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre> 
    <p>You can also set up JDO <code class="literal">PersistenceManagerFactory</code> in the JNDI environment of a Java EE application server, usually through the JCA connector provided by the particular JDO implementation. Springs standard <code class="literal">JndiObjectFactoryBean</code> or <code class="literal">&lt;jee:jndi-lookup&gt;</code> can be used to retrieve and expose such a <code class="literal">PersistenceManagerFactory</code>. However, outside an EJB context, no real benefit exists in holding the <code class="literal">PersistenceManagerFactory</code> in JNDI: only choose such a setup for a good reason. See <a class="xref" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#orm-hibernate-resources" title="14.3.6&nbsp;Comparing container-managed and locally defined resources">Section&nbsp;14.3.6, Comparing container-managed and locally defined resources</a> for a discussion; the arguments there apply to JDO as well.</p> 
   </div> 
   <div class="section" title="14.4.2&nbsp;Implementing DAOs based on the plain JDO API">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="orm-jdo-daos-straight"></a>14.4.2&nbsp;Implementing DAOs based on the plain JDO API</h3>
      </div>
     </div>
    </div> 
    <p>DAOs can also be written directly against plain JDO API, without any Spring dependencies, by using an injected <code class="literal">PersistenceManagerFactory</code>. The following is an example of a corresponding DAO implementation:</p> 
    <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ProductDaoImpl <span class="hl-keyword">implements</span> ProductDao {

    <span class="hl-keyword">private</span> PersistenceManagerFactory persistenceManagerFactory;

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setPersistenceManagerFactory(PersistenceManagerFactory pmf) {
        <span class="hl-keyword">this</span>.persistenceManagerFactory = pmf;
    }

    <span class="hl-keyword">public</span> Collection loadProductsByCategory(String category) {
        PersistenceManager pm = <span class="hl-keyword">this</span>.persistenceManagerFactory.getPersistenceManager();
        <span class="hl-keyword">try</span> {
            Query query = pm.newQuery(Product.<span class="hl-keyword">class</span>, <span class="hl-string">&quot;category = pCategory&quot;</span>);
            query.declareParameters(<span class="hl-string">&quot;String pCategory&quot;</span>);
            <span class="hl-keyword">return</span> query.execute(category);
        }
        <span class="hl-keyword">finally</span> {
            pm.close();
        }
    }
}</pre> 
    <p>Because the above DAO follows the dependency injection pattern, it fits nicely into a Spring container, just as it would if coded against Springs <code class="literal">JdoTemplate</code>:</p> 
    <pre class="programlisting"><span class="hl-tag">&lt;beans&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;myProductDao&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;product.ProductDaoImpl&quot;</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;persistenceManagerFactory&quot;</span> <span class="hl-attribute">ref</span>=<span class="hl-value">&quot;myPmf&quot;</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre> 
    <p>The main problem with such DAOs is that they always get a new <code class="literal">PersistenceManager</code> from the factory. To access a Spring-managed transactional <code class="literal">PersistenceManager</code>, define a <code class="literal">TransactionAwarePersistenceManagerFactoryProxy</code> (as included in Spring) in front of your target <code class="literal">PersistenceManagerFactory</code>, then passing a reference to that proxy into your DAOs as in the following example:</p> 
    <pre class="programlisting"><span class="hl-tag">&lt;beans&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;myPmfProxy&quot;</span>
            <span class="hl-attribute">class</span>=<span class="hl-value">&quot;org.springframework.orm.jdo.TransactionAwarePersistenceManagerFactoryProxy&quot;</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;targetPersistenceManagerFactory&quot;</span> <span class="hl-attribute">ref</span>=<span class="hl-value">&quot;myPmf&quot;</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;myProductDao&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;product.ProductDaoImpl&quot;</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;persistenceManagerFactory&quot;</span> <span class="hl-attribute">ref</span>=<span class="hl-value">&quot;myPmfProxy&quot;</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre> 
    <p>Your data access code will receive a transactional <code class="literal">PersistenceManager</code> (if any) from the <code class="literal">PersistenceManagerFactory.getPersistenceManager()</code> method that it calls. The latter method call goes through the proxy, which first checks for a current transactional <code class="literal">PersistenceManager</code> before getting a new one from the factory. Any <code class="literal">close()</code> calls on the <code class="literal">PersistenceManager</code> are ignored in case of a transactional <code class="literal">PersistenceManager</code>.</p> 
    <p>If your data access code always runs within an active transaction (or at least within active transaction synchronization), it is safe to omit the <code class="literal">PersistenceManager.close()</code> call and thus the entire <code class="literal">finally</code> block, which you might do to keep your DAO implementations concise:</p> 
    <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ProductDaoImpl <span class="hl-keyword">implements</span> ProductDao {

    <span class="hl-keyword">private</span> PersistenceManagerFactory persistenceManagerFactory;

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setPersistenceManagerFactory(PersistenceManagerFactory pmf) {
        <span class="hl-keyword">this</span>.persistenceManagerFactory = pmf;
    }

    <span class="hl-keyword">public</span> Collection loadProductsByCategory(String category) {
        PersistenceManager pm = <span class="hl-keyword">this</span>.persistenceManagerFactory.getPersistenceManager();
        Query query = pm.newQuery(Product.<span class="hl-keyword">class</span>, <span class="hl-string">&quot;category = pCategory&quot;</span>);
        query.declareParameters(<span class="hl-string">&quot;String pCategory&quot;</span>);
        <span class="hl-keyword">return</span> query.execute(category);
    }
}</pre> 
    <p>With such DAOs that rely on active transactions, it is recommended that you enforce active transactions through turning off <code class="literal">TransactionAwarePersistenceManagerFactoryProxy</code>'s <code class="literal">allowCreate</code> flag:</p> 
    <pre class="programlisting"><span class="hl-tag">&lt;beans&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;myPmfProxy&quot;</span>
            <span class="hl-attribute">class</span>=<span class="hl-value">&quot;org.springframework.orm.jdo.TransactionAwarePersistenceManagerFactoryProxy&quot;</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;targetPersistenceManagerFactory&quot;</span> <span class="hl-attribute">ref</span>=<span class="hl-value">&quot;myPmf&quot;</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;allowCreate&quot;</span> <span class="hl-attribute">value</span>=<span class="hl-value">&quot;false&quot;</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;myProductDao&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;product.ProductDaoImpl&quot;</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;persistenceManagerFactory&quot;</span> <span class="hl-attribute">ref</span>=<span class="hl-value">&quot;myPmfProxy&quot;</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre> 
    <p>The main advantage of this DAO style is that it depends on JDO API only; no import of any Spring class is required. This is of course appealing from a non-invasiveness perspective, and might feel more natural to JDO developers.</p> 
    <p>However, the DAO throws plain <code class="literal">JDOException</code> (which is unchecked, so does not have to be declared or caught), which means that callers can only treat exceptions as fatal, unless you want to depend on JDOs own exception structure. Catching specific causes such as an optimistic locking failure is not possible without tying the caller to the implementation strategy. This trade off might be acceptable to applications that are strongly JDO-based and/or do not need any special exception treatment.</p> 
    <p>In summary, you can DAOs based on the plain JDO API, and they can still participate in Spring-managed transactions. This strategy might appeal to you if you are already familiar with JDO. However, such DAOs throw plain <code class="literal">JDOException</code>, and you would have to convert explicitly to Springs <code class="literal">DataAccessException</code> (if desired).</p> 
   </div> 
   <div class="section" title="14.4.3&nbsp;Transaction management">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="orm-jdo-tx"></a>14.4.3&nbsp;Transaction management</h3>
      </div>
     </div>
    </div> 
    <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;">
     <table border="0" summary="Note">
      <tbody>
       <tr>
        <td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Framework Reference Documentation_files/note.png" /></td>
        <th align="left">Note</th>
       </tr>
       <tr>
        <td align="left" valign="top"> <p>You are <span class="emphasis"><em>strongly</em></span> encouraged to read <a class="xref" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#transaction-declarative" title="11.5&nbsp;Declarative transaction management">Section&nbsp;11.5, Declarative transaction management</a> if you have not done so, to get a more detailed coverage of Springs declarative transaction support.</p> </td>
       </tr>
      </tbody>
     </table>
    </div> 
    <p>To execute service operations within transactions, you can use Springs common declarative transaction facilities. For example:</p> 
    <pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">&quot;http://www.springframework.org/schema/beans&quot;</span>
    <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>
    <span class="hl-attribute">xmlns:aop</span>=<span class="hl-value">&quot;http://www.springframework.org/schema/aop&quot;</span>
    <span class="hl-attribute">xmlns:tx</span>=<span class="hl-value">&quot;http://www.springframework.org/schema/tx&quot;</span>
    <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">&quot;
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx
        http://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span><span class="hl-tag">&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;myTxManager&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;org.springframework.orm.jdo.JdoTransactionManager&quot;</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;persistenceManagerFactory&quot;</span> <span class="hl-attribute">ref</span>=<span class="hl-value">&quot;myPmf&quot;</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;myProductService&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;product.ProductServiceImpl&quot;</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;productDao&quot;</span> <span class="hl-attribute">ref</span>=<span class="hl-value">&quot;myProductDao&quot;</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

    <span class="hl-tag">&lt;tx:advice</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;txAdvice&quot;</span> <span class="hl-attribute">transaction-manager</span>=<span class="hl-value">&quot;txManager&quot;</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;tx:attributes&gt;</span>
            <span class="hl-tag">&lt;tx:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;increasePrice*&quot;</span> <span class="hl-attribute">propagation</span>=<span class="hl-value">&quot;REQUIRED&quot;</span><span class="hl-tag">/&gt;</span>
            <span class="hl-tag">&lt;tx:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;someOtherBusinessMethod&quot;</span> <span class="hl-attribute">propagation</span>=<span class="hl-value">&quot;REQUIRES_NEW&quot;</span><span class="hl-tag">/&gt;</span>
            <span class="hl-tag">&lt;tx:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;</span><span class="strong"><strong>&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;aop:config&gt; &lt;aop:pointcut id=&quot;productServiceMethods&quot; expression=&quot;execution(</strong></span> product.ProductService.*(..))&quot;/&gt;
        <span class="hl-tag">&lt;aop:advisor</span> <span class="hl-attribute">advice-ref</span>=<span class="hl-value">&quot;txAdvice&quot;</span> <span class="hl-attribute">pointcut-ref</span>=<span class="hl-value">&quot;productServiceMethods&quot;</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/aop:config&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre> 
    <p>JDO requires an active transaction to modify a persistent object. The non-transactional flush concept does not exist in JDO, in contrast to Hibernate. For this reason, you need to set up the chosen JDO implementation for a specific environment. Specifically, you need to set it up explicitly for JTA synchronization, to detect an active JTA transaction itself. This is not necessary for local transactions as performed by Springs <code class="literal">JdoTransactionManager</code>, but it is necessary to participate in JTA transactions, whether driven by Springs <code class="literal">JtaTransactionManager</code> or by EJB CMT and plain JTA.</p> 
    <p><code class="literal">JdoTransactionManager</code> is capable of exposing a JDO transaction to JDBC access code that accesses the same JDBC <code class="literal">DataSource</code>, provided that the registered <code class="literal">JdoDialect</code> supports retrieval of the underlying JDBC <code class="literal">Connection</code>. This is the case for JDBC-based JDO 2.0 implementations by default.</p> 
   </div> 
   <div class="section" title="14.4.4&nbsp;JdoDialect">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="orm-jdo-dialect"></a>14.4.4&nbsp;JdoDialect</h3>
      </div>
     </div>
    </div> 
    <p>As an advanced feature, both <code class="literal">JdoTemplate</code> and <code class="literal">JdoTransactionManager</code> support a custom <code class="literal">JdoDialect</code> that can be passed into the <code class="literal">jdoDialect</code> bean property. In this scenario, the DAOs will not receive a <code class="literal">PersistenceManagerFactory</code> reference but rather a full <code class="literal">JdoTemplate</code> instance (for example, passed into the <code class="literal">jdoTemplate</code> property of <code class="literal">JdoDaoSupport</code>). Using a <code class="literal">JdoDialect</code> implementation, you can enable advanced features supported by Spring, usually in a vendor-specific manner:</p> 
    <div class="itemizedlist">
     <ul class="itemizedlist" type="disc">
      <li class="listitem"> Applying specific transaction semantics such as custom isolation level or transaction timeout </li>
      <li class="listitem"> Retrieving the transactional JDBC <code class="literal">Connection</code> for exposure to JDBC-based DAOs </li>
      <li class="listitem"> Applying query timeouts, which are automatically calculated from Spring-managed transaction timeouts </li>
      <li class="listitem"> Eagerly flushing a <code class="literal">PersistenceManager,</code> to make transactional changes visible to JDBC-based data access code </li>
      <li class="listitem"> Advanced translation of <code class="literal">JDOExceptions</code> to Spring <code class="literal">DataAccessExceptions</code> </li>
     </ul>
    </div> 
    <p>See the <code class="literal">JdoDialect</code> Javadoc for more details on its operations and how to use them within Springs JDO support.</p> 
   </div> 
  </div> 
  <div class="section" title="14.5&nbsp;JPA">
   <div class="titlepage">
    <div>
     <div>
      <h2 class="title" style="clear: both"><a name="orm-jpa"></a>14.5&nbsp;JPA</h2>
     </div>
    </div>
   </div> 
   <p>The Spring JPA, available under the <code class="literal">org.springframework.orm.jpa</code> package, offers comprehensive support for the <a class="ulink" href="http://www.oracle.com/technetwork/articles/javaee/jpa-137156.html" target="_top">Java Persistence API</a> in a similar manner to the integration with Hibernate or JDO, while being aware of the underlying implementation in order to provide additional features.</p> 
   <div class="section" title="14.5.1&nbsp;Three options for JPA setup in a Spring environment">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="orm-jpa-setup"></a>14.5.1&nbsp;Three options for JPA setup in a Spring environment</h3>
      </div>
     </div>
    </div> 
    <p>The Spring JPA support offers three ways of setting up the JPA <code class="literal">EntityManagerFactory</code> that will be used by the application to obtain an entity manager.</p> 
    <div class="section" title="LocalEntityManagerFactoryBean">
     <div class="titlepage">
      <div>
       <div>
        <h4 class="title"><a name="orm-jpa-setup-lemfb"></a>LocalEntityManagerFactoryBean</h4>
       </div>
      </div>
     </div> 
     <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;">
      <table border="0" summary="Note">
       <tbody>
        <tr>
         <td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Framework Reference Documentation_files/note.png" /></td>
         <th align="left">Note</th>
        </tr>
        <tr>
         <td align="left" valign="top"> <p>Only use this option in simple deployment environments such as stand-alone applications and integration tests.</p> </td>
        </tr>
       </tbody>
      </table>
     </div> 
     <p>The <code class="literal">LocalEntityManagerFactoryBean</code> creates an <code class="literal">EntityManagerFactory</code> suitable for simple deployment environments where the application uses only JPA for data access. The factory bean uses the JPA <code class="literal">PersistenceProvider</code> autodetection mechanism (according to JPAs Java SE bootstrapping) and, in most cases, requires you to specify only the persistence unit name:</p> 
     <pre class="programlisting"><span class="hl-tag">&lt;beans&gt;</span>
    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;myEmf&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;org.springframework.orm.jpa.LocalEntityManagerFactoryBean&quot;</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;persistenceUnitName&quot;</span> <span class="hl-attribute">value</span>=<span class="hl-value">&quot;myPersistenceUnit&quot;</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>
<span class="hl-tag">&lt;/beans&gt;</span></pre> 
     <p>This form of JPA deployment is the simplest and the most limited. You cannot refer to an existing JDBC <code class="literal">DataSource</code> bean definition and no support for global transactions exists. Furthermore, weaving (byte-code transformation) of persistent classes is provider-specific, often requiring a specific JVM agent to specified on startup. This option is sufficient only for stand-alone applications and test environments, for which the JPA specification is designed.</p> 
    </div> 
    <div class="section" title="Obtaining an EntityManagerFactory from JNDI">
     <div class="titlepage">
      <div>
       <div>
        <h4 class="title"><a name="orm-jpa-setup-jndi"></a>Obtaining an EntityManagerFactory from JNDI</h4>
       </div>
      </div>
     </div> 
     <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;">
      <table border="0" summary="Note">
       <tbody>
        <tr>
         <td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Framework Reference Documentation_files/note.png" /></td>
         <th align="left">Note</th>
        </tr>
        <tr>
         <td align="left" valign="top"> <p>Use this option when deploying to a Java EE 5 server. Check your servers documentation on how to deploy a custom JPA provider into your server, allowing for a different provider than the servers default.</p> </td>
        </tr>
       </tbody>
      </table>
     </div> 
     <p>Obtaining an <code class="literal">EntityManagerFactory</code> from JNDI (for example in a Java EE 5 environment), is simply a matter of changing the XML configuration:</p> 
     <pre class="programlisting"><span class="hl-tag">&lt;beans&gt;</span>
    <span class="hl-tag">&lt;jee:jndi-lookup</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;myEmf&quot;</span> <span class="hl-attribute">jndi-name</span>=<span class="hl-value">&quot;persistence/myPersistenceUnit&quot;</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/beans&gt;</span></pre> 
     <p>This action assumes standard Java EE 5 bootstrapping: the Java EE server autodetects persistence units (in effect, <code class="literal">META-INF/persistence.xml</code> files in application jars) and <code class="literal">persistence-unit-ref</code> entries in the Java EE deployment descriptor (for example, <code class="literal">web.xml</code>) and defines environment naming context locations for those persistence units.</p> 
     <p>In such a scenario, the entire persistence unit deployment, including the weaving (byte-code transformation) of persistent classes, is up to the Java EE server. The JDBC <code class="literal">DataSource</code> is defined through a JNDI location in the <code class="literal">META-INF/persistence.xml</code> file; EntityManager transactions are integrated with the servers JTA subsystem. Spring merely uses the obtained <code class="literal">EntityManagerFactory</code>, passing it on to application objects through dependency injection, and managing transactions for the persistence unit, typically through <code class="literal">JtaTransactionManager</code>.</p> 
     <p>If multiple persistence units are used in the same application, the bean names of such JNDI-retrieved persistence units should match the persistence unit names that the application uses to refer to them, for example, in <code class="literal">@PersistenceUnit</code> and <code class="literal">@PersistenceContext</code> annotations.</p> 
    </div> 
    <div class="section" title="LocalContainerEntityManagerFactoryBean">
     <div class="titlepage">
      <div>
       <div>
        <h4 class="title"><a name="orm-jpa-setup-lcemfb"></a>LocalContainerEntityManagerFactoryBean</h4>
       </div>
      </div>
     </div> 
     <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;">
      <table border="0" summary="Note">
       <tbody>
        <tr>
         <td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Framework Reference Documentation_files/note.png" /></td>
         <th align="left">Note</th>
        </tr>
        <tr>
         <td align="left" valign="top"> <p>Use this option for full JPA capabilities in a Spring-based application environment. This includes web containers such as Tomcat as well as stand-alone applications and integration tests with sophisticated persistence requirements.</p> </td>
        </tr>
       </tbody>
      </table>
     </div> 
     <p>The <code class="literal">LocalContainerEntityManagerFactoryBean</code> gives full control over <code class="literal">EntityManagerFactory</code> configuration and is appropriate for environments where fine-grained customization is required. The <code class="literal">LocalContainerEntityManagerFactoryBean</code> creates a <code class="literal">PersistenceUnitInfo</code> instance based on the <code class="literal">persistence.xml</code> file, the supplied <code class="literal">dataSourceLookup</code> strategy, and the specified <code class="literal">loadTimeWeaver</code>. It is thus possible to work with custom data sources outside of JNDI and to control the weaving process. The following example shows a typical bean definition for a <code class="literal">LocalContainerEntityManagerFactoryBean</code>:</p> 
     <pre class="programlisting"><span class="hl-tag">&lt;beans&gt;</span>
    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;myEmf&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean&quot;</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;dataSource&quot;</span> <span class="hl-attribute">ref</span>=<span class="hl-value">&quot;someDataSource&quot;</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;loadTimeWeaver&quot;</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;org.springframework.instrument.classloading.InstrumentationLoadTimeWeaver&quot;</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;/property&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>
<span class="hl-tag">&lt;/beans&gt;</span></pre> 
     <p>The following example shows a typical <code class="literal">persistence.xml</code> file:</p> 
     <pre class="programlisting"><span class="hl-tag">&lt;persistence</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">&quot;http://java.sun.com/xml/ns/persistence&quot;</span> <span class="hl-attribute">version</span>=<span class="hl-value">&quot;1.0&quot;</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;persistence-unit</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;myUnit&quot;</span> <span class="hl-attribute">transaction-type</span>=<span class="hl-value">&quot;RESOURCE_LOCAL&quot;</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;mapping-file&gt;</span>META-INF/orm.xml<span class="hl-tag">&lt;/mapping-file&gt;</span>
        <span class="hl-tag">&lt;exclude-unlisted-classes/&gt;</span>
    <span class="hl-tag">&lt;/persistence-unit&gt;</span>
<span class="hl-tag">&lt;/persistence&gt;</span></pre> 
     <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;">
      <table border="0" summary="Note">
       <tbody>
        <tr>
         <td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Framework Reference Documentation_files/note.png" /></td>
         <th align="left">Note</th>
        </tr>
        <tr>
         <td align="left" valign="top"> <p>The <code class="literal">exclude-unlisted-classes</code> element always indicates that <span class="emphasis"><em>no</em></span> scanning for annotated entity classes is supposed to occur, in order to support the <code class="literal">&lt;exclude-unlisted-classes/&gt;</code> shortcut. This is in line with the JPA specification, which suggests that shortcut, but unfortunately is in conflict with the JPA XSD, which implies <code class="literal">false</code> for that shortcut. Consequently, <code class="literal">&lt;exclude-unlisted-classes&gt; false &lt;/exclude-unlisted-classes/&gt;</code> is not supported. Simply omit the <code class="literal">exclude-unlisted-classes</code> element if you want entity class scanning to occur.</p> </td>
        </tr>
       </tbody>
      </table>
     </div> 
     <p>Using the <code class="literal">LocalContainerEntityManagerFactoryBean</code> is the most powerful JPA setup option, allowing for flexible local configuration within the application. It supports links to an existing JDBC <code class="literal">DataSource</code>, supports both local and global transactions, and so on. However, it also imposes requirements on the runtime environment, such as the availability of a weaving-capable class loader if the persistence provider demands byte-code transformation.</p> 
     <p>This option may conflict with the built-in JPA capabilities of a Java EE 5 server. In a full Java EE 5 environment, consider obtaining your <code class="literal">EntityManagerFactory</code> from JNDI. Alternatively, specify a custom <code class="literal">persistenceXmlLocation</code> on your <code class="literal">LocalContainerEntityManagerFactoryBean</code> definition, for example, META-INF/my-persistence.xml, and only include a descriptor with that name in your application jar files. Because the Java EE 5 server only looks for default <code class="literal">META-INF/persistence.xml</code> files, it ignores such custom persistence units and hence avoid conflicts with a Spring-driven JPA setup upfront. (This applies to Resin 3.1, for example.)</p> 
     <div class="sidebar" title="When is load-time weaving required?">
      <p class="title"><b>When is load-time weaving required?</b></p> 
      <p>Not all JPA providers require a JVM agent ; Hibernate is an example of one that does not. If your provider does not require an agent or you have other alternatives, such as applying enhancements at build time through a custom compiler or an ant task, the load-time weaver <span class="emphasis"><em>should not</em></span> be used.</p> 
     </div> 
     <p>The <code class="literal">LoadTimeWeaver</code> interface is a Spring-provided class that allows JPA <code class="literal">ClassTransformer</code> instances to be plugged in a specific manner, depending whether the environment is a web container or application server. Hooking <code class="literal">ClassTransformers</code> through an <a class="ulink" href="http://docs.oracle.com/javase/6/docs/api/java/lang/instrument/package-summary.html" target="_top">agent</a> typically is not efficient. The agents work against the <span class="emphasis"><em>entire virtual machine</em></span> and inspect <span class="emphasis"><em>every</em></span> class that is loaded, which is usually undesirable in a production server environment.</p> 
     <p>Spring provides a number of <code class="literal">LoadTimeWeaver</code> implementations for various environments, allowing <code class="literal">ClassTransformer</code> instances to be applied only <span class="emphasis"><em>per class loader</em></span> and not per VM.</p> 
     <p>Refer to <a class="xref" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#aop-aj-ltw-spring" title="Spring configuration">the section called Spring configuration</a> in the AOP chapter for more insight regarding the <code class="literal">LoadTimeWeaver</code> implementations and their setup, either generic or customized to various platforms (such as Tomcat, WebLogic, GlassFish, Resin and JBoss).</p> 
     <p>As described in the aforementioned section, you can configure a context-wide <code class="literal">LoadTimeWeaver</code> using the <code class="literal">@EnableLoadTimeWeaving</code> annotation of <code class="literal">context:load-time-weaver</code> XML element. Such a global weaver is picked up by all JPA <code class="literal">LocalContainerEntityManagerFactoryBeans</code> automatically. This is the preferred way of setting up a load-time weaver, delivering autodetection of the platform (WebLogic, GlassFish, Tomcat, Resin, JBoss or VM agent) and automatic propagation of the weaver to all weaver-aware beans:</p> 
     <pre class="programlisting"><span class="hl-tag">&lt;context:load-time-weaver/&gt;</span>
<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;emf&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean&quot;</span><span class="hl-tag">&gt;</span>
    ...
<span class="hl-tag">&lt;/bean&gt;</span></pre> 
     <p>However, if needed, one can manually specify a dedicated weaver through the <code class="literal">loadTimeWeaver</code> property:</p> 
     <pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;emf&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean&quot;</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;loadTimeWeaver&quot;</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;org.springframework.instrument.classloading.ReflectiveLoadTimeWeaver&quot;</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/property&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre> 
     <p>No matter how the LTW is configured, using this technique, JPA applications relying on instrumentation can run in the target platform (ex: Tomcat) without needing an agent. This is important especially when the hosting applications rely on different JPA implementations because the JPA transformers are applied only at class loader level and thus are isolated from each other.</p> 
    </div> 
    <div class="section" title="Dealing with multiple persistence units">
     <div class="titlepage">
      <div>
       <div>
        <h4 class="title"><a name="orm-jpa-multiple-pu"></a>Dealing with multiple persistence units</h4>
       </div>
      </div>
     </div> 
     <p>For applications that rely on multiple persistence units locations, stored in various JARS in the classpath, for example, Spring offers the <code class="literal">PersistenceUnitManager</code> to act as a central repository and to avoid the persistence units discovery process, which can be expensive. The default implementation allows multiple locations to be specified that are parsed and later retrieved through the persistence unit name. (By default, the classpath is searched for <code class="literal">META-INF/persistence.xml</code> files.)</p> 
     <pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;pum&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;org.springframework.orm.jpa.persistenceunit.DefaultPersistenceUnitManager&quot;</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;persistenceXmlLocations&quot;</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;list&gt;</span>
            <span class="hl-tag">&lt;value&gt;</span>org/springframework/orm/jpa/domain/persistence-multi.xml<span class="hl-tag">&lt;/value&gt;</span>
            <span class="hl-tag">&lt;value&gt;</span>classpath:/my/package/<span class="strong"><strong>*/custom-persistence.xml&lt;/value&gt; &lt;value&gt;classpath</strong></span>:META-INF/persistence.xml<span class="hl-tag">&lt;/value&gt;</span>
        <span class="hl-tag">&lt;/list&gt;</span>
    <span class="hl-tag">&lt;/property&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;dataSources&quot;</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;map&gt;</span>
            <span class="hl-tag">&lt;entry</span> <span class="hl-attribute">key</span>=<span class="hl-value">&quot;localDataSource&quot;</span> <span class="hl-attribute">value-ref</span>=<span class="hl-value">&quot;local-db&quot;</span><span class="hl-tag">/&gt;</span>
            <span class="hl-tag">&lt;entry</span> <span class="hl-attribute">key</span>=<span class="hl-value">&quot;remoteDataSource&quot;</span> <span class="hl-attribute">value-ref</span>=<span class="hl-value">&quot;remote-db&quot;</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;/map&gt;</span>
    <span class="hl-tag">&lt;/property&gt;</span>
    <span class="hl-comment">&lt;!-- if no datasource is specified, use this one --&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;defaultDataSource&quot;</span> <span class="hl-attribute">ref</span>=<span class="hl-value">&quot;remoteDataSource&quot;</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span>

<span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;emf&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean&quot;</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;persistenceUnitManager&quot;</span> <span class="hl-attribute">ref</span>=<span class="hl-value">&quot;pum&quot;</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;persistenceUnitName&quot;</span> <span class="hl-attribute">value</span>=<span class="hl-value">&quot;myCustomUnit&quot;</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/bean&gt;</span></pre> 
     <p>The default implementation allows customization of the <code class="literal">PersistenceUnitInfo</code> instances, before they are fed to the JPA provider, declaratively through its properties, which affect <span class="emphasis"><em>all</em></span> hosted units, or programmatically, through the <code class="literal">PersistenceUnitPostProcessor</code>, which allows persistence unit selection. If no <code class="literal">PersistenceUnitManager</code> is specified, one is created and used internally by <code class="literal">LocalContainerEntityManagerFactoryBean</code>.</p> 
    </div> 
   </div> 
   <div class="section" title="14.5.2&nbsp;Implementing DAOs based on plain JPA">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="orm-jpa-straight"></a>14.5.2&nbsp;Implementing DAOs based on plain JPA</h3>
      </div>
     </div>
    </div> 
    <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;">
     <table border="0" summary="Note">
      <tbody>
       <tr>
        <td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Framework Reference Documentation_files/note.png" /></td>
        <th align="left">Note</th>
       </tr>
       <tr>
        <td align="left" valign="top"> <p>Although <code class="literal">EntityManagerFactory</code> instances are thread-safe, <code class="literal">EntityManager</code> instances are not. The injected JPA <code class="literal">EntityManager</code> behaves like an <code class="literal">EntityManager</code> fetched from an application servers JNDI environment, as defined by the JPA specification. It delegates all calls to the current transactional <code class="literal">EntityManager</code>, if any; otherwise, it falls back to a newly created <code class="literal">EntityManager</code> per operation, in effect making its usage thread-safe.</p> </td>
       </tr>
      </tbody>
     </table>
    </div> 
    <p>It is possible to write code against the plain JPA without any Spring dependencies, by using an injected <code class="literal">EntityManagerFactory</code> or <code class="literal">EntityManager</code>. Spring can understand <code class="literal">@PersistenceUnit</code> and <code class="literal">@PersistenceContext</code> annotations both at field and method level if a <code class="literal">PersistenceAnnotationBeanPostProcessor</code> is enabled. A plain JPA DAO implementation using the <code class="literal">@PersistenceUnit</code> annotation might look like this:</p> 
    <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ProductDaoImpl <span class="hl-keyword">implements</span> ProductDao {

    <span class="hl-keyword">private</span> EntityManagerFactory emf;

    <i><span class="hl-annotation" style="color: gray">@PersistenceUnit</span></i>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setEntityManagerFactory(EntityManagerFactory emf) {
        <span class="hl-keyword">this</span>.emf = emf;
    }

    <span class="hl-keyword">public</span> Collection loadProductsByCategory(String category) {
        EntityManager em = <span class="hl-keyword">this</span>.emf.createEntityManager();
        <span class="hl-keyword">try</span> {
            Query query = em.createQuery(<span class="hl-string">&quot;from Product as p where p.category = ?1&quot;</span>);
            query.setParameter(<span class="hl-number">1</span>, category);
            <span class="hl-keyword">return</span> query.getResultList();
        }
        <span class="hl-keyword">finally</span> {
            <span class="hl-keyword">if</span> (em != null) {
                em.close();
            }
        }
    }
}</pre> 
    <p>The DAO above has no dependency on Spring and still fits nicely into a Spring application context. Moreover, the DAO takes advantage of annotations to require the injection of the default <code class="literal">EntityManagerFactory</code>:</p> 
    <pre class="programlisting"><span class="hl-tag">&lt;beans&gt;</span>

    <span class="hl-comment">&lt;!-- bean post-processor for JPA annotations --&gt;</span>
    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor&quot;</span><span class="hl-tag">/&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;myProductDao&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;product.ProductDaoImpl&quot;</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre> 
    <p>As an alternative to defining a <code class="literal">PersistenceAnnotationBeanPostProcessor</code> explicitly, consider using the Spring <code class="literal">context:annotation-config</code> XML element in your application context configuration. Doing so automatically registers all Spring standard post-processors for annotation-based configuration, including <code class="literal">CommonAnnotationBeanPostProcessor</code> and so on.</p> 
    <pre class="programlisting"><span class="hl-tag">&lt;beans&gt;</span>

    <span class="hl-comment">&lt;!-- post-processors for all standard config annotations --&gt;</span>
    <span class="hl-tag">&lt;context:annotation-config/&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;myProductDao&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;product.ProductDaoImpl&quot;</span><span class="hl-tag">/&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre> 
    <p>The main problem with such a DAO is that it always creates a new <code class="literal">EntityManager</code> through the factory. You can avoid this by requesting a transactional <code class="literal">EntityManager</code> (also called &quot;shared EntityManager&quot; because it is a shared, thread-safe proxy for the actual transactional EntityManager) to be injected instead of the factory:</p> 
    <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ProductDaoImpl <span class="hl-keyword">implements</span> ProductDao {

    <i><span class="hl-annotation" style="color: gray">@PersistenceContext</span></i>
    <span class="hl-keyword">private</span> EntityManager em;

    <span class="hl-keyword">public</span> Collection loadProductsByCategory(String category) {
        Query query = em.createQuery(<span class="hl-string">&quot;from Product as p where p.category = :category&quot;</span>);
        query.setParameter(<span class="hl-string">&quot;category&quot;</span>, category);
        <span class="hl-keyword">return</span> query.getResultList();
    }
}</pre> 
    <p>The <code class="literal">@PersistenceContext</code> annotation has an optional attribute <code class="literal">type</code>, which defaults to <code class="literal">PersistenceContextType.TRANSACTION</code>. This default is what you need to receive a shared EntityManager proxy. The alternative, <code class="literal">PersistenceContextType.EXTENDED</code>, is a completely different affair: This results in a so-called extended EntityManager, which is <span class="emphasis"><em>not thread-safe</em></span> and hence must not be used in a concurrently accessed component such as a Spring-managed singleton bean. Extended EntityManagers are only supposed to be used in stateful components that, for example, reside in a session, with the lifecycle of the EntityManager not tied to a current transaction but rather being completely up to the application.</p> 
    <div class="sidebar" title="Method- and field-level Injection">
     <p class="title"><b>Method- and field-level Injection</b></p> 
     <p>Annotations that indicate dependency injections (such as <code class="literal">@PersistenceUnit</code> and <code class="literal">@PersistenceContext</code>) can be applied on field or methods inside a class, hence the expressions <span class="emphasis"><em>method-level injection</em></span> and <span class="emphasis"><em>field-level injection</em></span>. Field-level annotations are concise and easier to use while method-level allows for further processing of the injected dependency. In both cases the member visibility (public, protected, private) does not matter.</p> 
     <p>What about class-level annotations?</p> 
     <p>On the Java EE 5 platform, they are used for dependency declaration and not for resource injection.</p> 
    </div> 
    <p>The injected <code class="literal">EntityManager</code> is Spring-managed (aware of the ongoing transaction). It is important to note that even though the new DAO implementation uses method level injection of an <code class="literal">EntityManager</code> instead of an <code class="literal">EntityManagerFactory</code>, no change is required in the application context XML due to annotation usage.</p> 
    <p>The main advantage of this DAO style is that it only depends on Java Persistence API; no import of any Spring class is required. Moreover, as the JPA annotations are understood, the injections are applied automatically by the Spring container. This is appealing from a non-invasiveness perspective, and might feel more natural to JPA developers.</p> 
   </div> 
   <div class="section" title="14.5.3&nbsp;Transaction Management">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="orm-jpa-tx"></a>14.5.3&nbsp;Transaction Management</h3>
      </div>
     </div>
    </div> 
    <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;">
     <table border="0" summary="Note">
      <tbody>
       <tr>
        <td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Framework Reference Documentation_files/note.png" /></td>
        <th align="left">Note</th>
       </tr>
       <tr>
        <td align="left" valign="top"> <p>You are <span class="emphasis"><em>strongly</em></span> encouraged to read <a class="xref" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#transaction-declarative" title="11.5&nbsp;Declarative transaction management">Section&nbsp;11.5, Declarative transaction management</a> if you have not done so, to get a more detailed coverage of Springs declarative transaction support.</p> </td>
       </tr>
      </tbody>
     </table>
    </div> 
    <p>To execute service operations within transactions, you can use Springs common declarative transaction facilities. For example:</p> 
    <pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">&quot;http://www.springframework.org/schema/beans&quot;</span>
    <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>
    <span class="hl-attribute">xmlns:aop</span>=<span class="hl-value">&quot;http://www.springframework.org/schema/aop&quot;</span>
    <span class="hl-attribute">xmlns:tx</span>=<span class="hl-value">&quot;http://www.springframework.org/schema/tx&quot;</span>
    <span class="hl-attribute">xsi:schemaLocation</span>=<span class="hl-value">&quot;
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/tx
        http://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span><span class="hl-tag">&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;myTxManager&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;org.springframework.orm.jpa.JpaTransactionManager&quot;</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;entityManagerFactory&quot;</span> <span class="hl-attribute">ref</span>=<span class="hl-value">&quot;myEmf&quot;</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;myProductService&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;product.ProductServiceImpl&quot;</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;productDao&quot;</span> <span class="hl-attribute">ref</span>=<span class="hl-value">&quot;myProductDao&quot;</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

    <span class="hl-tag">&lt;aop:config&gt;</span>
        <span class="hl-tag">&lt;aop:pointcut</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;productServiceMethods&quot;</span> <span class="hl-attribute">expression</span>=<span class="hl-value">&quot;execution(* product.ProductService.</span><span class="strong"><strong>(..))&quot;/&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;productServiceMethods&quot;/&gt; &lt;/aop:config&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;myTxManager&quot;&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;increasePrice</strong></span>&quot; propagation=&quot;REQUIRED&quot;/&gt;
            <span class="hl-tag">&lt;tx:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;someOtherBusinessMethod&quot;</span> <span class="hl-attribute">propagation</span>=<span class="hl-value">&quot;REQUIRES_NEW&quot;</span><span class="hl-tag">/&gt;</span>
            <span class="hl-tag">&lt;tx:method</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;*&quot;</span> <span class="hl-attribute">propagation</span>=<span class="hl-value">&quot;SUPPORTS&quot;</span> <span class="hl-attribute">read-only</span>=<span class="hl-value">&quot;true&quot;</span><span class="hl-tag">/&gt;</span>
        <span class="hl-tag">&lt;/tx:attributes&gt;</span>
    <span class="hl-tag">&lt;/tx:advice&gt;</span>

<span class="hl-tag">&lt;/beans&gt;</span></pre> 
    <p>Spring JPA allows a configured <code class="literal">JpaTransactionManager</code> to expose a JPA transaction to JDBC access code that accesses the same JDBC <code class="literal">DataSource</code>, provided that the registered <code class="literal">JpaDialect</code> supports retrieval of the underlying JDBC <code class="literal">Connection</code>. Out of the box, Spring provides dialects for the Toplink, Hibernate and OpenJPA JPA implementations. See the next section for details on the <code class="literal">JpaDialect</code> mechanism.</p> 
   </div> 
   <div class="section" title="14.5.4&nbsp;JpaDialect">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="orm-jpa-dialect"></a>14.5.4&nbsp;JpaDialect</h3>
      </div>
     </div>
    </div> 
    <p>As an advanced feature <code class="literal">JpaTemplate</code>, <code class="literal">JpaTransactionManager</code> and subclasses of <code class="literal">AbstractEntityManagerFactoryBean</code> support a custom <code class="literal">JpaDialect</code>, to be passed into the <code class="literal">jpaDialect</code> bean property. In such a scenario, the DAOs do not receive an <code class="literal">EntityManagerFactory</code> reference but rather a full <code class="literal">JpaTemplate</code> instance (for example, passed into the <code class="literal">jpaTemplate</code> property of <code class="literal">JpaDaoSupport</code>). A <code class="literal">JpaDialect</code> implementation can enable some advanced features supported by Spring, usually in a vendor-specific manner:</p> 
    <div class="itemizedlist">
     <ul class="itemizedlist" type="disc">
      <li class="listitem"> Applying specific transaction semantics such as custom isolation level or transaction timeout) </li>
      <li class="listitem"> Retrieving the transactional JDBC <code class="literal">Connection</code> for exposure to JDBC-based DAOs) </li>
      <li class="listitem"> Advanced translation of <code class="literal">PersistenceExceptions</code> to Spring <code class="literal">DataAccessExceptions</code> </li>
     </ul>
    </div> 
    <p>This is particularly valuable for special transaction semantics and for advanced translation of exception. The default implementation used ( <code class="literal">DefaultJpaDialect</code>) does not provide any special capabilities and if the above features are required, you have to specify the appropriate dialect.</p> 
    <p>See the <code class="literal">JpaDialect</code> Javadoc for more details of its operations and how they are used within Springs JPA support.</p> 
   </div> 
  </div> 
 </div> 
 <div class="chapter" title="15.&nbsp;Marshalling XML using O/X Mappers">
  <div class="titlepage">
   <div>
    <div>
     <h2 class="title"><a name="oxm"></a>15.&nbsp;Marshalling XML using O/X Mappers</h2>
    </div>
   </div>
  </div> 
  <div class="section" title="15.1&nbsp;Introduction">
   <div class="titlepage">
    <div>
     <div>
      <h2 class="title" style="clear: both"><a name="oxm-introduction"></a>15.1&nbsp;Introduction</h2>
     </div>
    </div>
   </div> 
   <p>In this chapter, we will describe Springs Object/XML Mapping support. Object/XML Mapping, or O/X mapping for short, is the act of converting an XML document to and from an object. This conversion process is also known as XML Marshalling, or XML Serialization. This chapter uses these terms interchangeably.</p> 
   <p>Within the field of O/X mapping, a <span class="emphasis"><em>marshaller</em></span> is responsible for serializing an object (graph) to XML. In similar fashion, an <span class="emphasis"><em>unmarshaller</em></span> deserializes the XML to an object graph. This XML can take the form of a DOM document, an input or output stream, or a SAX handler.</p> 
   <p>Some of the benefits of using Spring for your O/X mapping needs are:</p> 
   <div class="section" title="15.1.1&nbsp;Ease of configuration">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="_ease_of_configuration"></a>15.1.1&nbsp;Ease of configuration</h3>
      </div>
     </div>
    </div> 
    <p>Springs bean factory makes it easy to configure marshallers, without needing to construct JAXB context, JiBX binding factories, etc. The marshallers can be configured as any other bean in your application context. Additionally, XML Schema-based configuration is available for a number of marshallers, making the configuration even simpler.</p> 
   </div> 
   <div class="section" title="15.1.2&nbsp;Consistent Interfaces">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="_consistent_interfaces"></a>15.1.2&nbsp;Consistent Interfaces</h3>
      </div>
     </div>
    </div> 
    <p>Springs O/X mapping operates through two global interfaces: the <code class="literal">Marshaller</code> and <code class="literal">Unmarshaller</code> interface. These abstractions allow you to switch O/X mapping frameworks with relative ease, with little or no changes required on the classes that do the marshalling. This approach has the additional benefit of making it possible to do XML marshalling with a mix-and-match approach (e.g. some marshalling performed using JAXB, other using XMLBeans) in a non-intrusive fashion, leveraging the strength of each technology.</p> 
   </div> 
   <div class="section" title="15.1.3&nbsp;Consistent Exception Hierarchy">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="_consistent_exception_hierarchy"></a>15.1.3&nbsp;Consistent Exception Hierarchy</h3>
      </div>
     </div>
    </div> 
    <p>Spring provides a conversion from exceptions from the underlying O/X mapping tool to its own exception hierarchy with the <code class="literal">XmlMappingException</code> as the root exception. As can be expected, these runtime exceptions wrap the original exception so no information is lost.</p> 
   </div> 
  </div> 
  <div class="section" title="15.2&nbsp;Marshaller and Unmarshaller">
   <div class="titlepage">
    <div>
     <div>
      <h2 class="title" style="clear: both"><a name="oxm-marshaller-unmarshaller"></a>15.2&nbsp;Marshaller and Unmarshaller</h2>
     </div>
    </div>
   </div> 
   <p>As stated in the introduction, a <span class="emphasis"><em>marshaller</em></span> serializes an object to XML, and an <span class="emphasis"><em>unmarshaller</em></span> deserializes XML stream to an object. In this section, we will describe the two Spring interfaces used for this purpose.</p> 
   <div class="section" title="15.2.1&nbsp;Marshaller">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="oxm-marshaller"></a>15.2.1&nbsp;Marshaller</h3>
      </div>
     </div>
    </div> 
    <p>Spring abstracts all marshalling operations behind the <code class="literal">org.springframework.oxm.Marshaller</code> interface, the main methods of which is listed below.</p> 
    <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> Marshaller {

    <b class="hl-tag" style="color: blue">/**
     * Marshals the object graph with the given root into the provided Result.
     */</b>
    <span class="hl-keyword">void</span> marshal(Object graph, Result result) <span class="hl-keyword">throws</span> XmlMappingException, IOException;

}</pre> 
    <p>The <code class="literal">Marshaller</code> interface has one main method, which marshals the given object to a given <code class="literal">javax.xml.transform.Result</code>. Result is a tagging interface that basically represents an XML output abstraction: concrete implementations wrap various XML representations, as indicated in the table below.</p> 
    <div class="informaltable">
     <a name="oxm-marshller-tbl"></a> 
     <table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; ">
      <colgroup>
       <col />
       <col />
      </colgroup>
      <thead>
       <tr>
        <th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">Result implementation</th>
        <th style="border-bottom: 0.5pt solid ; " align="left" valign="top">Wraps XML representation</th>
       </tr>
      </thead>
      <tbody>
       <tr>
        <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">DOMResult</code></p></td>
        <td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">org.w3c.dom.Node</code></p></td>
       </tr>
       <tr>
        <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">SAXResult</code></p></td>
        <td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">org.xml.sax.ContentHandler</code></p></td>
       </tr>
       <tr>
        <td style="border-right: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">StreamResult</code></p></td>
        <td style="" align="left" valign="top"><p><code class="literal">java.io.File</code>, <code class="literal">java.io.OutputStream</code>, or <code class="literal">java.io.Writer</code></p></td>
       </tr>
      </tbody>
     </table> 
    </div> 
    <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;">
     <table border="0" summary="Note">
      <tbody>
       <tr>
        <td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Framework Reference Documentation_files/note.png" /></td>
        <th align="left">Note</th>
       </tr>
       <tr>
        <td align="left" valign="top"> <p>Although the <code class="literal">marshal()</code> method accepts a plain object as its first parameter, most <code class="literal">Marshaller</code> implementations cannot handle arbitrary objects. Instead, an object class must be mapped in a mapping file, marked with an annotation, registered with the marshaller, or have a common base class. Refer to the further sections in this chapter to determine how your O/X technology of choice manages this.</p> </td>
       </tr>
      </tbody>
     </table>
    </div> 
   </div> 
   <div class="section" title="15.2.2&nbsp;Unmarshaller">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="oxm-unmarshaller"></a>15.2.2&nbsp;Unmarshaller</h3>
      </div>
     </div>
    </div> 
    <p>Similar to the <code class="literal">Marshaller</code>, there is the <code class="literal">org.springframework.oxm.Unmarshaller</code> interface.</p> 
    <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">interface</span> Unmarshaller {

    <b class="hl-tag" style="color: blue">/**
     * Unmarshals the given provided Source into an object graph.
     */</b>
    Object unmarshal(Source source) <span class="hl-keyword">throws</span> XmlMappingException, IOException;
}</pre> 
    <p>This interface also has one method, which reads from the given <code class="literal">javax.xml.transform.Source</code> (an XML input abstraction), and returns the object read. As with Result, Source is a tagging interface that has three concrete implementations. Each wraps a different XML representation, as indicated in the table below.</p> 
    <div class="informaltable">
     <a name="oxm-unmarshller-tbl"></a> 
     <table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; ">
      <colgroup>
       <col />
       <col />
      </colgroup>
      <thead>
       <tr>
        <th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">Source implementation</th>
        <th style="border-bottom: 0.5pt solid ; " align="left" valign="top">Wraps XML representation</th>
       </tr>
      </thead>
      <tbody>
       <tr>
        <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">DOMSource</code></p></td>
        <td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">org.w3c.dom.Node</code></p></td>
       </tr>
       <tr>
        <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">SAXSource</code></p></td>
        <td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">org.xml.sax.InputSource</code>, and <code class="literal">org.xml.sax.XMLReader</code></p></td>
       </tr>
       <tr>
        <td style="border-right: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">StreamSource</code></p></td>
        <td style="" align="left" valign="top"><p><code class="literal">java.io.File</code>, <code class="literal">java.io.InputStream</code>, or <code class="literal">java.io.Reader</code></p></td>
       </tr>
      </tbody>
     </table> 
    </div> 
    <p>Even though there are two separate marshalling interfaces ( <code class="literal">Marshaller</code> and <code class="literal">Unmarshaller</code>), all implementations found in Spring-WS implement both in one class. This means that you can wire up one marshaller class and refer to it both as a marshaller and an unmarshaller in your <code class="literal">applicationContext.xml</code>.</p> 
   </div> 
   <div class="section" title="15.2.3&nbsp;XmlMappingException">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="oxm-xmlmappingexception"></a>15.2.3&nbsp;XmlMappingException</h3>
      </div>
     </div>
    </div> 
    <p>Spring converts exceptions from the underlying O/X mapping tool to its own exception hierarchy with the <code class="literal">XmlMappingException</code> as the root exception. As can be expected, these runtime exceptions wrap the original exception so no information will be lost.</p> 
    <p>Additionally, the <code class="literal">MarshallingFailureException</code> and <code class="literal">UnmarshallingFailureException</code> provide a distinction between marshalling and unmarshalling operations, even though the underlying O/X mapping tool does not do so.</p> 
    <p>The O/X Mapping exception hierarchy is shown in the following figure: image::images/oxm-exceptions.png[width=400]</p> 
    <p>O/X Mapping exception hierarchy</p> 
   </div> 
  </div> 
  <div class="section" title="15.3&nbsp;Using Marshaller and Unmarshaller">
   <div class="titlepage">
    <div>
     <div>
      <h2 class="title" style="clear: both"><a name="oxm-usage"></a>15.3&nbsp;Using Marshaller and Unmarshaller</h2>
     </div>
    </div>
   </div> 
   <p>Springs OXM can be used for a wide variety of situations. In the following example, we will use it to marshal the settings of a Spring-managed application as an XML file. We will use a simple JavaBean to represent the settings:</p> 
   <pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Settings {

    <span class="hl-keyword">private</span> <span class="hl-keyword">boolean</span> fooEnabled;

    <span class="hl-keyword">public</span> <span class="hl-keyword">boolean</span> isFooEnabled() {
        <span class="hl-keyword">return</span> fooEnabled;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setFooEnabled(<span class="hl-keyword">boolean</span> fooEnabled) {
        <span class="hl-keyword">this</span>.fooEnabled = fooEnabled;
    }
}</pre> 
   <p>The application class uses this bean to store its settings. Besides a main method, the class has two methods: <code class="literal">saveSettings()</code> saves the settings bean to a file named <code class="literal">settings.xml</code>, and <code class="literal">loadSettings()</code> loads these settings again. A <code class="literal">main()</code> method constructs a Spring application context, and calls these two methods.</p> 
   <pre class="programlisting"><span class="hl-keyword">import</span> java.io.FileInputStream;
<span class="hl-keyword">import</span> java.io.FileOutputStream;
<span class="hl-keyword">import</span> java.io.IOException;
<span class="hl-keyword">import</span> javax.xml.transform.stream.StreamResult;
<span class="hl-keyword">import</span> javax.xml.transform.stream.StreamSource;

<span class="hl-keyword">import</span> org.springframework.context.ApplicationContext;
<span class="hl-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;
<span class="hl-keyword">import</span> org.springframework.oxm.Marshaller;
<span class="hl-keyword">import</span> org.springframework.oxm.Unmarshaller;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Application {

    <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> <span class="hl-keyword">final</span> String FILE_NAME = <span class="hl-string">&quot;settings.xml&quot;</span>;
    <span class="hl-keyword">private</span> Settings settings = <span class="hl-keyword">new</span> Settings();
    <span class="hl-keyword">private</span> Marshaller marshaller;
    <span class="hl-keyword">private</span> Unmarshaller unmarshaller;

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setMarshaller(Marshaller marshaller) {
        <span class="hl-keyword">this</span>.marshaller = marshaller;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setUnmarshaller(Unmarshaller unmarshaller) {
        <span class="hl-keyword">this</span>.unmarshaller = unmarshaller;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> saveSettings() <span class="hl-keyword">throws</span> IOException {
        FileOutputStream os = null;
        <span class="hl-keyword">try</span> {
            os = <span class="hl-keyword">new</span> FileOutputStream(FILE_NAME);
            <span class="hl-keyword">this</span>.marshaller.marshal(settings, <span class="hl-keyword">new</span> StreamResult(os));
        } <span class="hl-keyword">finally</span> {
            <span class="hl-keyword">if</span> (os != null) {
                os.close();
            }
        }
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> loadSettings() <span class="hl-keyword">throws</span> IOException {
        FileInputStream is = null;
        <span class="hl-keyword">try</span> {
            is = <span class="hl-keyword">new</span> FileInputStream(FILE_NAME);
            <span class="hl-keyword">this</span>.settings = (Settings) <span class="hl-keyword">this</span>.unmarshaller.unmarshal(<span class="hl-keyword">new</span> StreamSource(is));
        } <span class="hl-keyword">finally</span> {
            <span class="hl-keyword">if</span> (is != null) {
                is.close();
            }
        }
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">static</span> <span class="hl-keyword">void</span> main(String[] args) <span class="hl-keyword">throws</span> IOException {
        ApplicationContext appContext =
                <span class="hl-keyword">new</span> ClassPathXmlApplicationContext(<span class="hl-string">&quot;applicationContext.xml&quot;</span>);
        Application application = (Application) appContext.getBean(<span class="hl-string">&quot;application&quot;</span>);
        application.saveSettings();
        application.loadSettings();
    }
}</pre> 
   <p>The <code class="literal">Application</code> requires both a <code class="literal">marshaller</code> and <code class="literal">unmarshaller</code> property to be set. We can do so using the following <code class="literal">applicationContext.xml</code>:</p> 
   <pre class="programlisting"><span class="hl-tag">&lt;beans&gt;</span>
    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;application&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;Application&quot;</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;marshaller&quot;</span> <span class="hl-attribute">ref</span>=<span class="hl-value">&quot;castorMarshaller&quot;</span><span class="hl-tag"> /&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;unmarshaller&quot;</span> <span class="hl-attribute">ref</span>=<span class="hl-value">&quot;castorMarshaller&quot;</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>
    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;castorMarshaller&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;org.springframework.oxm.castor.CastorMarshaller&quot;</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/beans&gt;</span></pre> 
   <p>This application context uses Castor, but we could have used any of the other marshaller instances described later in this chapter. Note that Castor does not require any further configuration by default, so the bean definition is rather simple. Also note that the <code class="literal">CastorMarshaller</code> implements both <code class="literal">Marshaller</code> and <code class="literal">Unmarshaller</code>, so we can refer to the <code class="literal">castorMarshaller</code> bean in both the <code class="literal">marshaller</code> and <code class="literal">unmarshaller</code> property of the application.</p> 
   <p>This sample application produces the following <code class="literal">settings.xml</code> file:</p> 
   <pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="hl-tag">&lt;settings</span> <span class="hl-attribute">foo-enabled</span>=<span class="hl-value">&quot;false&quot;</span><span class="hl-tag">/&gt;</span></pre> 
  </div> 
  <div class="section" title="15.4&nbsp;XML Schema-based Configuration">
   <div class="titlepage">
    <div>
     <div>
      <h2 class="title" style="clear: both"><a name="oxm-schema-based-config"></a>15.4&nbsp;XML Schema-based Configuration</h2>
     </div>
    </div>
   </div> 
   <p>Marshallers could be configured more concisely using tags from the OXM namespace. To make these tags available, the appropriate schema has to be referenced first in the preamble of the XML configuration file. Note the <span class="emphasis"><em>oxm</em></span> related text below:</p> 
   <pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="hl-tag">&lt;beans</span> <span class="hl-attribute">xmlns</span>=<span class="hl-value">&quot;http://www.springframework.org/schema/beans&quot;</span>
    <span class="hl-attribute">xmlns:xsi</span>=<span class="hl-value">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>
    <span class="strong"><strong>xmlns:oxm=&quot;http://www.springframework.org/schema/oxm&quot;</strong></span> xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd <span class="strong"><strong>http://www.springframework.org/schema/oxm http://www.springframework.org/schema/oxm/spring-oxm.xsd&quot;</strong></span>&gt;</pre> 
   <p>Currently, the following tags are available:</p> 
   <div class="itemizedlist">
    <ul class="itemizedlist" type="disc">
     <li class="listitem"> <a class="link" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#oxm-jaxb2-xsd" title="XML Schema-based Configuration"><code class="literal">jaxb2-marshaller</code></a> </li>
     <li class="listitem"> <a class="link" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#oxm-xmlbeans-xsd" title="XML Schema-based Configuration"><code class="literal">xmlbeans-marshaller</code></a> </li>
     <li class="listitem"> <a class="link" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#oxm-castor-xsd" title="XML Schema-based Configuration"><code class="literal">castor-marshaller</code></a> </li>
     <li class="listitem"> <a class="link" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#oxm-jibx-xsd" title="XML Schema-based Configuration"><code class="literal">jibx-marshaller</code></a> </li>
    </ul>
   </div> 
   <p>Each tag will be explained in its respective marshallers section. As an example though, here is how the configuration of a JAXB2 marshaller might look like:</p> 
   <pre class="programlisting"><span class="hl-tag">&lt;oxm:jaxb2-marshaller</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;marshaller&quot;</span> <span class="hl-attribute">contextPath</span>=<span class="hl-value">&quot;org.springframework.ws.samples.airline.schema&quot;</span><span class="hl-tag">/&gt;</span></pre> 
  </div> 
  <div class="section" title="15.5&nbsp;JAXB">
   <div class="titlepage">
    <div>
     <div>
      <h2 class="title" style="clear: both"><a name="oxm-jaxb"></a>15.5&nbsp;JAXB</h2>
     </div>
    </div>
   </div> 
   <p>The JAXB binding compiler translates a W3C XML Schema into one or more Java classes, a <code class="literal">jaxb.properties</code> file, and possibly some resource files. JAXB also offers a way to generate a schema from annotated Java classes.</p> 
   <p>Spring supports the JAXB 2.0 API as XML marshalling strategies, following the <code class="literal">Marshaller</code> and <code class="literal">Unmarshaller</code> interfaces described in <a class="xref" href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/spring-framework-reference/htmlsingle/#oxm-marshaller-unmarshaller" title="15.2&nbsp;Marshaller and Unmarshaller">Section&nbsp;15.2, Marshaller and Unmarshaller</a>. The corresponding integration classes reside in the <code class="literal">org.springframework.oxm.jaxb</code> package.</p> 
   <div class="section" title="15.5.1&nbsp;Jaxb2Marshaller">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="oxm-jaxb2"></a>15.5.1&nbsp;Jaxb2Marshaller</h3>
      </div>
     </div>
    </div> 
    <p>The <code class="literal">Jaxb2Marshaller</code> class implements both the Spring <code class="literal">Marshaller</code> and <code class="literal">Unmarshaller</code> interface. It requires a context path to operate, which you can set using the <code class="literal">contextPath</code> property. The context path is a list of colon (:) separated Java package names that contain schema derived classes. It also offers a <code class="literal">classesToBeBound</code> property, which allows you to set an array of classes to be supported by the marshaller. Schema validation is performed by specifying one or more schema resource to the bean, like so:</p> 
    <pre class="programlisting"><span class="hl-tag">&lt;beans&gt;</span>
    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;jaxb2Marshaller&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;org.springframework.oxm.jaxb.Jaxb2Marshaller&quot;</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;classesToBeBound&quot;</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;list&gt;</span>
                <span class="hl-tag">&lt;value&gt;</span>org.springframework.oxm.jaxb.Flight<span class="hl-tag">&lt;/value&gt;</span>
                <span class="hl-tag">&lt;value&gt;</span>org.springframework.oxm.jaxb.Flights<span class="hl-tag">&lt;/value&gt;</span>
            <span class="hl-tag">&lt;/list&gt;</span>
        <span class="hl-tag">&lt;/property&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;schema&quot;</span> <span class="hl-attribute">value</span>=<span class="hl-value">&quot;classpath:org/springframework/oxm/schema.xsd&quot;</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>

    ...

<span class="hl-tag">&lt;/beans&gt;</span></pre> 
    <div class="section" title="XML Schema-based Configuration">
     <div class="titlepage">
      <div>
       <div>
        <h4 class="title"><a name="oxm-jaxb2-xsd"></a>XML Schema-based Configuration</h4>
       </div>
      </div>
     </div> 
     <p>The <code class="literal">jaxb2-marshaller</code> tag configures a <code class="literal">org.springframework.oxm.jaxb.Jaxb2Marshaller</code>. Here is an example:</p> 
     <pre class="programlisting"><span class="hl-tag">&lt;oxm:jaxb2-marshaller</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;marshaller&quot;</span> <span class="hl-attribute">contextPath</span>=<span class="hl-value">&quot;org.springframework.ws.samples.airline.schema&quot;</span><span class="hl-tag">/&gt;</span></pre> 
     <p>Alternatively, the list of classes to bind can be provided to the marshaller via the <code class="literal">class-to-be-bound</code> child tag:</p> 
     <pre class="programlisting"><span class="hl-tag">&lt;oxm:jaxb2-marshaller</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;marshaller&quot;</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;oxm:class-to-be-bound</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;org.springframework.ws.samples.airline.schema.Airport&quot;</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;oxm:class-to-be-bound</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;org.springframework.ws.samples.airline.schema.Flight&quot;</span><span class="hl-tag">/&gt;</span>
    ...
<span class="hl-tag">&lt;/oxm:jaxb2-marshaller&gt;</span></pre> 
     <p>Available attributes are:</p> 
     <div class="informaltable"> 
      <table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; ">
       <colgroup>
        <col />
        <col />
        <col />
       </colgroup>
       <thead>
        <tr>
         <th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">Attribute</th>
         <th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">Description</th>
         <th style="border-bottom: 0.5pt solid ; " align="left" valign="top">Required</th>
        </tr>
       </thead>
       <tbody>
        <tr>
         <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">id</code></p></td>
         <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>the id of the marshaller</p></td>
         <td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>no</p></td>
        </tr>
        <tr>
         <td style="border-right: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">contextPath</code></p></td>
         <td style="border-right: 0.5pt solid ; " align="left" valign="top"><p>the JAXB Context path</p></td>
         <td style="" align="left" valign="top"><p>no</p></td>
        </tr>
       </tbody>
      </table> 
     </div> 
    </div> 
   </div> 
  </div> 
  <div class="section" title="15.6&nbsp;Castor">
   <div class="titlepage">
    <div>
     <div>
      <h2 class="title" style="clear: both"><a name="oxm-castor"></a>15.6&nbsp;Castor</h2>
     </div>
    </div>
   </div> 
   <p>Castor XML mapping is an open source XML binding framework. It allows you to transform the data contained in a java object model into/from an XML document. By default, it does not require any further configuration, though a mapping file can be used to have more control over the behavior of Castor.</p> 
   <p>For more information on Castor, refer to the <a class="ulink" href="http://castor.codehaus.org/xml-framework.html" target="_top"><span class="emphasis"><em>Castor web site</em></span></a>. The Spring integration classes reside in the <code class="literal">org.springframework.oxm.castor</code> package.</p> 
   <div class="section" title="15.6.1&nbsp;CastorMarshaller">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="oxm-castor-marshaller"></a>15.6.1&nbsp;CastorMarshaller</h3>
      </div>
     </div>
    </div> 
    <p>As with JAXB, the <code class="literal">CastorMarshaller</code> implements both the <code class="literal">Marshaller</code> and <code class="literal">Unmarshaller</code> interface. It can be wired up as follows:</p> 
    <pre class="programlisting"><span class="hl-tag">&lt;beans&gt;</span>
    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;castorMarshaller&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;org.springframework.oxm.castor.CastorMarshaller&quot;</span><span class="hl-tag"> /&gt;</span>
    ...
<span class="hl-tag">&lt;/beans&gt;</span></pre> 
   </div> 
   <div class="section" title="15.6.2&nbsp;Mapping">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="oxm-castor-mapping"></a>15.6.2&nbsp;Mapping</h3>
      </div>
     </div>
    </div> 
    <p>Although it is possible to rely on Castors default marshalling behavior, it might be necessary to have more control over it. This can be accomplished using a Castor mapping file. For more information, refer to <a class="ulink" href="http://castor.codehaus.org/xml-mapping.html" target="_top">Castor XML Mapping</a>.</p> 
    <p>The mapping can be set using the <code class="literal">mappingLocation</code> resource property, indicated below with a classpath resource.</p> 
    <pre class="programlisting"><span class="hl-tag">&lt;beans&gt;</span>
    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;castorMarshaller&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;org.springframework.oxm.castor.CastorMarshaller&quot;</span><span class="hl-tag"> &gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;mappingLocation&quot;</span> <span class="hl-attribute">value</span>=<span class="hl-value">&quot;classpath:mapping.xml&quot;</span><span class="hl-tag"> /&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>
<span class="hl-tag">&lt;/beans&gt;</span></pre> 
    <div class="section" title="XML Schema-based Configuration">
     <div class="titlepage">
      <div>
       <div>
        <h4 class="title"><a name="oxm-castor-xsd"></a>XML Schema-based Configuration</h4>
       </div>
      </div>
     </div> 
     <p>The <code class="literal">castor-marshaller</code> tag configures a <code class="literal">org.springframework.oxm.castor.CastorMarshaller</code>. Here is an example:</p> 
     <pre class="programlisting"><span class="hl-tag">&lt;oxm:castor-marshaller</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;marshaller&quot;</span> <span class="hl-attribute">mapping-location</span>=<span class="hl-value">&quot;classpath:org/springframework/oxm/castor/mapping.xml&quot;</span><span class="hl-tag">/&gt;</span></pre> 
     <p>The marshaller instance can be configured in two ways, by specifying either the location of a mapping file (through the <code class="literal">mapping-location</code> property), or by identifying Java POJOs (through the <code class="literal">target-class</code> or <code class="literal">target-package</code> properties) for which there exist corresponding XML descriptor classes. The latter way is usually used in conjunction with XML code generation from XML schemas.</p> 
     <p>Available attributes are:</p> 
     <div class="informaltable"> 
      <table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; ">
       <colgroup>
        <col />
        <col />
        <col />
       </colgroup>
       <thead>
        <tr>
         <th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">Attribute</th>
         <th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">Description</th>
         <th style="border-bottom: 0.5pt solid ; " align="left" valign="top">Required</th>
        </tr>
       </thead>
       <tbody>
        <tr>
         <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">id</code></p></td>
         <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>the id of the marshaller</p></td>
         <td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>no</p></td>
        </tr>
        <tr>
         <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">encoding</code></p></td>
         <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>the encoding to use for unmarshalling from XML</p></td>
         <td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>no</p></td>
        </tr>
        <tr>
         <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">target-class</code></p></td>
         <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>a Java class name for a POJO for which an XML class descriptor is available (as generated through code generation)</p></td>
         <td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>no</p></td>
        </tr>
        <tr>
         <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">target-package</code></p></td>
         <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>a Java package name that identifies a package that contains POJOs and their corresponding Castor XML descriptor classes (as generated through code generation from XML schemas)</p></td>
         <td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>no</p></td>
        </tr>
        <tr>
         <td style="border-right: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">mapping-location</code></p></td>
         <td style="border-right: 0.5pt solid ; " align="left" valign="top"><p>location of a Castor XML mapping file</p></td>
         <td style="" align="left" valign="top"><p>no</p></td>
        </tr>
       </tbody>
      </table> 
     </div> 
    </div> 
   </div> 
  </div> 
  <div class="section" title="15.7&nbsp;XMLBeans">
   <div class="titlepage">
    <div>
     <div>
      <h2 class="title" style="clear: both"><a name="oxm-xmlbeans"></a>15.7&nbsp;XMLBeans</h2>
     </div>
    </div>
   </div> 
   <p>XMLBeans is an XML binding tool that has full XML Schema support, and offers full XML Infoset fidelity. It takes a different approach to that of most other O/X mapping frameworks, in that all classes that are generated from an XML Schema are all derived from <code class="literal">XmlObject</code>, and contain XML binding information in them.</p> 
   <p>For more information on XMLBeans, refer to the <a class="ulink" href="http://xmlbeans.apache.org/" target="_top"><span class="emphasis"><em>XMLBeans web site </em></span></a>. The Spring-WS integration classes reside in the <code class="literal">org.springframework.oxm.xmlbeans</code> package.</p> 
   <div class="section" title="15.7.1&nbsp;XmlBeansMarshaller">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="oxm-xmlbeans-marshaller"></a>15.7.1&nbsp;XmlBeansMarshaller</h3>
      </div>
     </div>
    </div> 
    <p>The <code class="literal">XmlBeansMarshaller</code> implements both the <code class="literal">Marshaller</code> and <code class="literal">Unmarshaller</code> interfaces. It can be configured as follows:</p> 
    <pre class="programlisting"><span class="hl-tag">&lt;beans&gt;</span>

    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;xmlBeansMarshaller&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;org.springframework.oxm.xmlbeans.XmlBeansMarshaller&quot;</span><span class="hl-tag"> /&gt;</span>
    ...

<span class="hl-tag">&lt;/beans&gt;</span></pre> 
    <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;">
     <table border="0" summary="Note">
      <tbody>
       <tr>
        <td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="./Spring Framework Reference Documentation_files/note.png" /></td>
        <th align="left">Note</th>
       </tr>
       <tr>
        <td align="left" valign="top"> <p>Note that the <code class="literal">XmlBeansMarshaller</code> can only marshal objects of type <code class="literal">XmlObject</code>, and not every <code class="literal">java.lang.Object</code>.</p> </td>
       </tr>
      </tbody>
     </table>
    </div> 
    <div class="section" title="XML Schema-based Configuration">
     <div class="titlepage">
      <div>
       <div>
        <h4 class="title"><a name="oxm-xmlbeans-xsd"></a>XML Schema-based Configuration</h4>
       </div>
      </div>
     </div> 
     <p>The <code class="literal">xmlbeans-marshaller</code> tag configures a <code class="literal">org.springframework.oxm.xmlbeans.XmlBeansMarshaller</code>. Here is an example:</p> 
     <pre class="programlisting"><span class="hl-tag">&lt;oxm:xmlbeans-marshaller</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;marshaller&quot;</span><span class="hl-tag">/&gt;</span></pre> 
     <p>Available attributes are:</p> 
     <div class="informaltable"> 
      <table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; ">
       <colgroup>
        <col />
        <col />
        <col />
       </colgroup>
       <thead>
        <tr>
         <th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">Attribute</th>
         <th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">Description</th>
         <th style="border-bottom: 0.5pt solid ; " align="left" valign="top">Required</th>
        </tr>
       </thead>
       <tbody>
        <tr>
         <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">id</code></p></td>
         <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>the id of the marshaller</p></td>
         <td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>no</p></td>
        </tr>
        <tr>
         <td style="border-right: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">options</code></p></td>
         <td style="border-right: 0.5pt solid ; " align="left" valign="top"><p>the bean name of the XmlOptions that is to be used for this marshaller. Typically a <code class="literal">XmlOptionsFactoryBean</code> definition</p></td>
         <td style="" align="left" valign="top"><p>no</p></td>
        </tr>
       </tbody>
      </table> 
     </div> 
    </div> 
   </div> 
  </div> 
  <div class="section" title="15.8&nbsp;JiBX">
   <div class="titlepage">
    <div>
     <div>
      <h2 class="title" style="clear: both"><a name="oxm-jibx"></a>15.8&nbsp;JiBX</h2>
     </div>
    </div>
   </div> 
   <p>The JiBX framework offers a solution similar to that which JDO provides for ORM: a binding definition defines the rules for how your Java objects are converted to or from XML. After preparing the binding and compiling the classes, a JiBX binding compiler enhances the class files, and adds code to handle converting instances of the classes from or to XML.</p> 
   <p>For more information on JiBX, refer to the <a class="ulink" href="http://jibx.sourceforge.net/" target="_top"><span class="emphasis"><em>JiBX web site</em></span></a>. The Spring integration classes reside in the <code class="literal">org.springframework.oxm.jibx</code> package.</p> 
   <div class="section" title="15.8.1&nbsp;JibxMarshaller">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="oxm-jibx-marshaller"></a>15.8.1&nbsp;JibxMarshaller</h3>
      </div>
     </div>
    </div> 
    <p>The <code class="literal">JibxMarshaller</code> class implements both the <code class="literal">Marshaller</code> and <code class="literal">Unmarshaller</code> interface. To operate, it requires the name of the class to marshal in, which you can set using the <code class="literal">targetClass</code> property. Optionally, you can set the binding name using the <code class="literal">bindingName</code> property. In the next sample, we bind the <code class="literal">Flights</code> class:</p> 
    <pre class="programlisting"><span class="hl-tag">&lt;beans&gt;</span>
    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;jibxFlightsMarshaller&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;org.springframework.oxm.jibx.JibxMarshaller&quot;</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;targetClass&quot;</span><span class="hl-tag">&gt;</span>org.springframework.oxm.jibx.Flights<span class="hl-tag">&lt;/property&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>
    ...
<span class="hl-tag">&lt;/beans&gt;</span></pre> 
    <p>A <code class="literal">JibxMarshaller</code> is configured for a single class. If you want to marshal multiple classes, you have to configure multiple <code class="literal">JibxMarshaller</code> s with different <code class="literal">targetClass</code> property values.</p> 
    <div class="section" title="XML Schema-based Configuration">
     <div class="titlepage">
      <div>
       <div>
        <h4 class="title"><a name="oxm-jibx-xsd"></a>XML Schema-based Configuration</h4>
       </div>
      </div>
     </div> 
     <p>The <code class="literal">jibx-marshaller</code> tag configures a <code class="literal">org.springframework.oxm.jibx.JibxMarshaller</code>. Here is an example:</p> 
     <pre class="programlisting"><span class="hl-tag">&lt;oxm:jibx-marshaller</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;marshaller&quot;</span> <span class="hl-attribute">target-class</span>=<span class="hl-value">&quot;org.springframework.ws.samples.airline.schema.Flight&quot;</span><span class="hl-tag">/&gt;</span></pre> 
     <p>Available attributes are:</p> 
     <div class="informaltable"> 
      <table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; ">
       <colgroup>
        <col />
        <col />
        <col />
       </colgroup>
       <thead>
        <tr>
         <th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">Attribute</th>
         <th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top">Description</th>
         <th style="border-bottom: 0.5pt solid ; " align="left" valign="top">Required</th>
        </tr>
       </thead>
       <tbody>
        <tr>
         <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">id</code></p></td>
         <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>the id of the marshaller</p></td>
         <td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>no</p></td>
        </tr>
        <tr>
         <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">target-class</code></p></td>
         <td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " align="left" valign="top"><p>the target class for this marshaller</p></td>
         <td style="border-bottom: 0.5pt solid ; " align="left" valign="top"><p>yes</p></td>
        </tr>
        <tr>
         <td style="border-right: 0.5pt solid ; " align="left" valign="top"><p><code class="literal">bindingName</code></p></td>
         <td style="border-right: 0.5pt solid ; " align="left" valign="top"><p>the binding name used by this marshaller</p></td>
         <td style="" align="left" valign="top"><p>no</p></td>
        </tr>
       </tbody>
      </table> 
     </div> 
    </div> 
   </div> 
  </div> 
  <div class="section" title="15.9&nbsp;XStream">
   <div class="titlepage">
    <div>
     <div>
      <h2 class="title" style="clear: both"><a name="oxm-xstream"></a>15.9&nbsp;XStream</h2>
     </div>
    </div>
   </div> 
   <p>XStream is a simple library to serialize objects to XML and back again. It does not require any mapping, and generates clean XML.</p> 
   <p>For more information on XStream, refer to the <a class="ulink" href="http://xstream.codehaus.org/" target="_top"><span class="emphasis"><em>XStream web site</em></span></a>. The Spring integration classes reside in the <code class="literal">org.springframework.oxm.xstream</code> package.</p> 
   <div class="section" title="15.9.1&nbsp;XStreamMarshaller">
    <div class="titlepage">
     <div>
      <div>
       <h3 class="title"><a name="oxm-xstream-marshaller"></a>15.9.1&nbsp;XStreamMarshaller</h3>
      </div>
     </div>
    </div> 
    <p>The <code class="literal">XStreamMarshaller</code> does not require any configuration, and can be configured in an application context directly. To further customize the XML, you can set an<span class="emphasis"><em>alias map</em></span>, which consists of string aliases mapped to classes:</p> 
    <pre class="programlisting"><span class="hl-tag">&lt;beans&gt;</span>
    <span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;xstreamMarshaller&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;org.springframework.oxm.xstream.XStreamMarshaller&quot;</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;aliases&quot;</span><span class="hl-tag">&gt;</span>
            <span class="hl-tag">&lt;props&gt;</span>
                <span class="hl-tag">&lt;prop</span> <span class="hl-attribute">key</span>=<span class="hl-value">&quot;Flight&quot;</span><span class="hl-tag">&gt;</span>org.springframework.oxm.xstream.Flight<span class="hl-tag">&lt;/prop&gt;</span>
            <span class="hl-tag">&lt;/props&gt;</span>
        <span class="hl-tag">&lt;/property&gt;</span>
    <span class="hl-tag">&lt;/bean&gt;</span>
    ...
<span class="hl-tag">&lt;/beans&gt;</span></pre> 
    <div class="warning" title="Warning" style="margin-left: 0.5in; margin-right: 0.5in;">
     <table border="0" summary="Warning">
      <tbody>
       <tr>
        <td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="./Spring Framework Reference Documentation_files/warning.png" /></td>
        <th align="left">Warning</th>
       </tr>
       <tr>
        <td align="left" valign="top"> <p>By default, XStream allows for arbitrary classes to be unmarshalled, which can result in security vulnerabilities. As such, it is <span class="emphasis"><em>not recommended to use the <code class="literal">XStreamMarshaller</code> to unmarshal XML from external sources</em></span> (i.e. the Web), as this can result in <span class="emphasis"><em>security vulnerabilities</em></span>. If you do use the <code class="literal">XStreamMarshaller</code> to unmarshal XML from an external source, set the <code class="literal">supportedClasses</code> property on the <code class="literal">XStreamMarshaller</code>, like so:</p> <pre class="programlisting"><span class="hl-tag">&lt;bean</span> <span class="hl-attribute">id</span>=<span class="hl-value">&quot;xstreamMarshaller&quot;</span> <span class="hl-attribute">class</span>=<span class="hl-value">&quot;org.springframework.oxm.xstream.XStreamMarshaller&quot;</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">&quot;supportedClasses&quot;</span> <span class="hl-attribute">value</span>=<span class="hl-value">&quot;org.springframework.oxm.xstream.Flight&quot;</span><span class="hl-tag">/&gt;</span>
    ...
<span class="hl-tag">&lt;/bean&gt;</span></pre> <p>This will make sure that only the registered classes are eligible for unmarshalling.</p> <p>Additionally, you can register <a class="ulink" href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/oxm/xstream/XStreamMarshaller.html#setConverters(com.thoughtworks.xstream.converters.ConverterMatcher%E2%80%A6)" target="_top">custom converters</a> to make sure that only your supported classes can be unmarshalled. You might want to add a <code class="literal">CatchAllConverter</code> as the last converter in the list, in addition to converters that explicitl